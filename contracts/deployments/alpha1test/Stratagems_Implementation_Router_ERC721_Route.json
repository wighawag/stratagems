{
  "address": "0xdafbffa870778673edec657f1da2f68085816916",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract IERC20WithIERC2612",
              "name": "tokens",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "burnAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "commitPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revealPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "maxLife",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "numTokensPerGems",
              "type": "uint256"
            },
            {
              "internalType": "contract ITime",
              "name": "time",
              "type": "address"
            },
            {
              "internalType": "contract IOnStakeChange",
              "name": "generator",
              "type": "address"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CanStillReveal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CommitmentHashNotMatching",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "GameNotStarted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ImpossibleConfiguration",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InCommitmentPhase",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InRevealPhase",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "InvalidAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEpoch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFurtherMoves",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "NonExistentToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NonceOverflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAuthorized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotImplemented",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provided",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "currentOwner",
          "type": "address"
        }
      ],
      "name": "NotOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NothingToReveal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PreviousCommitmentNotRevealed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "inReserve",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expected",
          "type": "uint256"
        }
      ],
      "name": "ReserveTooLow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferRejected",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        }
      ],
      "name": "CommitmentCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentMade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": true,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "enum UsingStratagemsTypes.Color",
              "name": "color",
              "type": "uint8"
            }
          ],
          "indexed": false,
          "internalType": "struct UsingStratagemsTypes.Move[]",
          "name": "moves",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newReserveAmount",
          "type": "uint256"
        }
      ],
      "name": "CommitmentRevealed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountBurnt",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentVoid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum UsingStratagemsTypes.Color",
          "name": "oldColor",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "enum UsingStratagemsTypes.Color",
          "name": "newColor",
          "type": "uint8"
        }
      ],
      "name": "MoveProcessed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint64[]",
          "name": "positions",
          "type": "uint64[]"
        }
      ],
      "name": "MultiPoke",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountDeposited",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "ReserveDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountWithdrawn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "ReserveWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        }
      ],
      "name": "SinglePoke",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "tokenIDs",
          "type": "uint256[]"
        }
      ],
      "name": "ownerAndLastTransferBlockNumberList",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lastTransferBlockNumber",
              "type": "uint256"
            }
          ],
          "internalType": "struct IERC721WithBlocknumber.OwnerData[]",
          "name": "ownersData",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "ownerAndLastTransferBlockNumberOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "StratagemsERC721",
  "sourceName": "src/game/routes/StratagemsERC721.sol",
  "bytecode": "0x6101a0346200018557620026dd601f38829003908101601f19168301906001600160401b0390818311858410176200018a5780859460409485528539610120938491810103126200018557815190838201908111828210176200018a57825283516001600160a01b0390818116810362000185578252602085015190808216820362000185576020830191825283860151928481019384526060870151906060810191825260808801516080820190815260a08901519060ff82168203620001855760a0830191825260c08a01519360c0840194855260e08b01519386851694858103620001855760e0820152610100809c01519787891689036200018557878260ff978f8395019b8c52608052511660a0525116976101609889525160c0525160e052518952511686525191610140928352511692610180938452519361253c9586620001a18739608051866121fa015260a05186505060c051866103a2015260e0518661034f015251856103700152518461112e0152518350505182505051815050f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe608080604052600436101561001357600080fd5b60003560e01c90816301ffc9a714611cd05750806306fdde0314611c5c578063081812fc14611c02578063095ea7b314611a1357806323b872dd1461192f57806342842e0e146118ad57806348f3c51c146118175780636352211e1461177d57806370a082311461171b57806395d89b41146116a7578063a22cb465146115d8578063b88d4fde14611320578063c87b56dd1461031e578063e985e9c51461029c5763f3945282146100c457600080fd5b34610297576020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610297576004359067ffffffffffffffff8083116102975736602384011215610297578260040135908082116102975760246005943660248560051b830101116102975761013d84612041565b9561014b6040519788611f25565b8487527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe061017886612041565b0160005b81811061023e57505060005b8581106101eb57604080518881528951818a018190528a8a01928201908a60005b8281106101b65784840385f35b8551805173ffffffffffffffffffffffffffffffffffffffff16855282015184830152948101946040909301926001016101a9565b8084600192841b850101356000528188528560406000205473ffffffffffffffffffffffffffffffffffffffff8116610224848d612059565b515260b81c1688610235838c612059565b51015201610188565b604051604081018181108882111761026957604052600080825289820152898201890152870161017c565b867f4e487b710000000000000000000000000000000000000000000000000000000060005260416004526000fd5b600080fd5b346102975760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610297576102d3611e2a565b6102db611e4d565b9073ffffffffffffffffffffffffffffffffffffffff809116600052600560205260406000209116600052602052602060ff604060002054166040519015158152f35b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610297577f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000008101809111611298576103a06121e3565b7f00000000000000000000000000000000000000000000000000000000000000008082106112f6576103d19161209c565b81156112c7578181049160028301809311611298577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe62ffffff84160162ffffff81116112985762ffffff16818102918183041490151715611298576104369161209c565b50600061010060405161044881611ed0565b8281528260208201528260408201528260608201528260808201528260a08201528260c08201528260e0820152015267ffffffffffffffff6004351660005260006020526040600020906040519161049f83611ed0565b5462ffffff8116835262ffffff8160181c16602084015262ffffff8160301c16604084015260ff8160481c16600781101561105957606084015260ff8160501c1660808401528060581c60000b60a084015260ff8160601c1660c084015260ff8160681c1660e084015260ff8160701c1661010084015262ffffff835116906001821015808091611289575b6110b4575b5050600061054c60a0850151820b60ff60c08701511690612184565b810b13611088575b50506060810151600781101561105957606080918015600014610d6c5750505060405161058081611eed565b600481527f4e6f6e650000000000000000000000000000000000000000000000000000000060208201526040516105b681611eed565b600481527f67726179000000000000000000000000000000000000000000000000000000006020820152905b6105f663ffffffff6004351660030b6120d5565b9261060e63ffffffff60043560201c1660030b6120d5565b61061e60ff608084015116612355565b9161065562ffffff602061064c61064460a086015160000b60ff60c08801511690612184565b60000b6120d5565b93015116612355565b936040519260e084019084821067ffffffffffffffff831117610d3d577f3c2f747370616e3e3c2f746578743e3c2f7376673e0000000000000000000000610d2d9760c597610ba196867f293c2f747370616e3e3c747370616e2532353230783d27323536272532353230610d399e8e6102e29a60a08e7f2c000000000000000000000000000000000000000000000000000000000000009c6040528481528b6020820152886040820152876060820152896080820152015260c08d01526040519e8f998a927f646174613a696d6167652f7376672b786d6c2c3c7376672532353230786d6c6e60208501527f733d27687474703a2f2f7777772e77332e6f72672f323030302f73766727253260408501527f35323076696577426f783d27302532353230302532353230353132253235323060608501527f353132273e3c7469746c653e49736c616e64253235323000000000000000000060808501527f280000000000000000000000000000000000000000000000000000000000000060978501527f272532353230646f6d696e616e742d626173656c696e653d276d6964646c65278b825161080e816098890160208701611dbd565b84609882890101526020825192019661082d836099848401018a611dbd565b01017f293c2f7469746c653e3c726563742532353230783d273136272532353230793d60998201527f27313627253235323077696474683d273438302725323532306865696768743d60b98201527f273438302725323532307374726f6b653d27000000000000000000000000000060d9820152845160208601916108b68260eb830185611dbd565b017f2725323532307374726f6b652d77696474683d2733707827253235323066696c60eb8201527f6c3d277472616e73706172656e74272f3e3c746578742532353230783d27323561010b8201527f36272532353230793d27323536272532353230666f6e742d73697a653d27343861012b8201527f7078272532353230666f6e742d7765696768743d27626f6c642725323532306661014b8201527f696c6c3d2700000000000000000000000000000000000000000000000000000061016b82015261098c6101709651809388840190611dbd565b01938401527f2532353230746578742d616e63686f723d276d6964646c65273e3c747370616e6101908401527f2532353230783d2732353627253235323064793d272d332e37656d273e49736c6101b08401527f616e643c2f747370616e3e3c747370616e2532353230783d27323536272532356101d08401527f323064793d2731656d273e2800000000000000000000000000000000000000006101f08401526101fc92610a448251809360208785019101611dbd565b0191820152610a5c6101fd995180938b840190611dbd565b01968701527f64793d27322e32656d273e46616374696f6e3a2532353230000000000000000061021d87015261023595610a9f8251809360208a85019101611dbd565b01947f3c2f747370616e3e3c747370616e2532353230783d2732353627253235323064928380928801527f793d2731656d273e4c6966653a2532353230000000000000000000000000000061025588015261026796610b078251809360208b85019101611dbd565b01958601527f793d2731656d273e47726f7774683a253235323000000000000000000000000061028786015261029b94610b4a8251809360208985019101611dbd565b01938401527f793d27322e33656d273e45706f636825323000000000000000000000000000006102bb8401526102cd92610b8d8251809360208785019101611dbd565b0191820152036102c2810187520185611f25565b60208151910151936040519485927f646174613a6170706c69636174696f6e2f6a736f6e2c7b226e616d65223a224960208501527f736c616e642532302800000000000000000000000000000000000000000000006040850152610c0f815180926020604988019101611dbd565b83017f2c000000000000000000000000000000000000000000000000000000000000006049820152610c4b825180936020604a85019101611dbd565b017f29222c226465736372697074696f6e223a224125323050696563652532304f66604a8201527f2532304c616e64253230496e25323053747261746167656d732c253230416e25606a8201527f32304175746f6e6f6d6f7573253230576f726c64253230437265617465642532608a8201527f304279253230506c61796572732e222c22696d616765223a220000000000000060aa820152610cf882518093602060c385019101611dbd565b017f227d00000000000000000000000000000000000000000000000000000000000060c38201520360a5810184520182611f25565b60405191829182611de0565b0390f35b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60018103610dea57505050604051610d8381611eed565b600481527f426c7565000000000000000000000000000000000000000000000000000000006020820152604051610db981611eed565b600481527f626c7565000000000000000000000000000000000000000000000000000000006020820152905b6105e2565b60028103610e6757505050604051610e0181611eed565b600381527f52656400000000000000000000000000000000000000000000000000000000006020820152604051610e3781611eed565b600381527f72656400000000000000000000000000000000000000000000000000000000006020820152906105e2565b60038103610ee457505050604051610e7e81611eed565b600581527f477265656e0000000000000000000000000000000000000000000000000000006020820152604051610eb481611eed565b600581527f677265656e0000000000000000000000000000000000000000000000000000006020820152906105e2565b60048103610f6157505050604051610efb81611eed565b600681527f59656c6c6f7700000000000000000000000000000000000000000000000000006020820152604051610f3181611eed565b600681527f79656c6c6f7700000000000000000000000000000000000000000000000000006020820152906105e2565b60058103610fde57505050604051610f7881611eed565b600681527f507572706c6500000000000000000000000000000000000000000000000000006020820152604051610fae81611eed565b600681527f707572706c6500000000000000000000000000000000000000000000000000006020820152906105e2565b600603610de5575050604051610ff381611eed565b600481527f4576696c00000000000000000000000000000000000000000000000000000000602082015260405161102981611eed565b600581527f626c61636b0000000000000000000000000000000000000000000000000000006020820152906105e2565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b61109b6110a79162ffffff8094166120a9565b826040850151166120be565b1660408201528180610554565b60ff916000918061127b575b6110db575b5016608084015262ffffff821683528380610530565b905062ffffff6110ed848287166120a9565b1690811561126f5761110a838260601c168260581c60000b612184565b918260000b600081136000146111b55750908361118661116c8261119095816111767f000000000000000000000000000000000000000000000000000000000000000099611171611160848b60501c168d612318565b918416968780936122d3565b6122e7565b61232c565b168082116111ad575b501661233e565b9160501c166122d3565b90828116838316116111a5575b505b856110c5565b90508561119d565b90508c61117f565b9092906000131561126257836111f16111e061116c6111d3856122a3565b8416848760501c166122d3565b6111e9846122a3565b83169061232c565b16808411611258575b50611207611211916122a3565b841684841661233e565b838260501c168482161160001461123c57505061123662ffffff6000925b16846120be565b5061119f565b61125262ffffff91856112369460501c16612318565b9261122f565b92506112076111fa565b5082915060501c1661119f565b82915060501c1661119f565b50828160501c1615156110c0565b5060ff8260501c16151561052b565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60046040517f3a5f7b57000000000000000000000000000000000000000000000000000000008152fd5b346102975760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757611357611e2a565b61135f611e4d565b6044359060643567ffffffffffffffff811161029757366023820112156102975780600401359061138f82611f66565b9161139d6040519384611f25565b80835236602482840101116102975760009281602460209401848301370101526114218260005260016020526040600020549073ffffffffffffffffffffffffffffffffffffffff8216916affffffffffffffffffffff7f8000000000000000000000000000000000000000000000000000000000000000808316149160a01c1691565b939192905073ffffffffffffffffffffffffffffffffffffffff928381169586156115a75784811680970361155857505082168015801561154f575b61151e5750833303611494575b60046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b82611502575b50501590816114dc575b506114b2578080808061146a565b60046040517fea8e4eb5000000000000000000000000000000000000000000000000000000008152fd5b9050600052600560205260406000203360005260205260ff6040600020541615816114a4565b909150600052600660205233906040600020541614828061149a565b602490604051907f8e4c8aa60000000000000000000000000000000000000000000000000000000082526004820152fd5b5030811461145d565b6040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff918216600482015291166024820152604490fd5b602484604051907f38077a2b0000000000000000000000000000000000000000000000000000000082526004820152fd5b346102975760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102975761160f611e2a565b6024358015158091036102975733600052600560205273ffffffffffffffffffffffffffffffffffffffff60406000209216918260005260205260406000207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0081541660ff83161790556040519081527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3160203392a3005b346102975760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757610d396040516116e581611eed565b600681527f49534c414e440000000000000000000000000000000000000000000000000000602082015260405191829182611de0565b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757611752611e2a565b5060046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102975760043580600052600160205273ffffffffffffffffffffffffffffffffffffffff604060002054169081156117e657602082604051908152f35b602490604051907f38077a2b0000000000000000000000000000000000000000000000000000000082526004820152fd5b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102975760406118886004356000526001602052604060002054906affffffffffffffffffffff73ffffffffffffffffffffffffffffffffffffffff83169260a01c1690565b73ffffffffffffffffffffffffffffffffffffffff83519216825260181c6020820152f35b34610297576118bb36611e70565b9060006040516118ca81611f09565b526114218260005260016020526040600020549073ffffffffffffffffffffffffffffffffffffffff8216916affffffffffffffffffffff7f8000000000000000000000000000000000000000000000000000000000000000808316149160a01c1691565b346102975761193d36611e70565b906119a28260005260016020526040600020549073ffffffffffffffffffffffffffffffffffffffff8216916affffffffffffffffffffff7f8000000000000000000000000000000000000000000000000000000000000000808316149160a01c1691565b939192905073ffffffffffffffffffffffffffffffffffffffff928381169586156115a75784811696870361155857505082168015801561154f5761151e57508333036114945760046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b346102975760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757611a4a611e2a565b60243590611a8c826000526001602052604060002054906affffffffffffffffffffff73ffffffffffffffffffffffffffffffffffffffff83169260a01c1690565b9173ffffffffffffffffffffffffffffffffffffffff809216918215611bd1578233141580611bac575b6114b25760018401938481116112985760181c8460181c03611b82571691819083611b165784600052600160205260a01b176040600020555b7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925600080a4005b84600052600160205260a01b177f80000000000000000000000000000000000000000000000000000000000000001760406000205560066020526040600020827fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055611aef565b60046040517fadc15572000000000000000000000000000000000000000000000000000000008152fd5b5082600052600560205260406000203360005260205260ff6040600020541615611ab6565b602485604051907f38077a2b0000000000000000000000000000000000000000000000000000000082526004820152fd5b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610297576020611c3e600435611fa0565b73ffffffffffffffffffffffffffffffffffffffff60405191168152f35b346102975760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757610d39604051611c9a81611eed565b600781527f49736c616e647300000000000000000000000000000000000000000000000000602082015260405191829182611de0565b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757600435907fffffffff00000000000000000000000000000000000000000000000000000000821680920361029757817f01ffc9a70000000000000000000000000000000000000000000000000000000060209314908115611d93575b8115611d69575b5015158152f35b7f5b5e139f0000000000000000000000000000000000000000000000000000000091501483611d62565b7f80ac58cd0000000000000000000000000000000000000000000000000000000081149150611d5b565b60005b838110611dd05750506000910152565b8181015183820152602001611dc0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60409360208452611e238151809281602088015260208888019101611dbd565b0116010190565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361029757565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361029757565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60609101126102975773ffffffffffffffffffffffffffffffffffffffff90600435828116810361029757916024359081168103610297579060443590565b610120810190811067ffffffffffffffff821117610d3d57604052565b6040810190811067ffffffffffffffff821117610d3d57604052565b6020810190811067ffffffffffffffff821117610d3d57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610d3d57604052565b67ffffffffffffffff8111610d3d57601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b8060005260016020526040600020549073ffffffffffffffffffffffffffffffffffffffff917f80000000000000000000000000000000000000000000000000000000000000009083811615612010578116036120095760005260066020526040600020541690565b5050600090565b602483604051907f38077a2b0000000000000000000000000000000000000000000000000000000082526004820152fd5b67ffffffffffffffff8111610d3d5760051b60200190565b805182101561206d5760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9190820391821161129857565b62ffffff918216908216039190821161129857565b91909162ffffff8080941691160191821161129857565b612163602061212a60008412938460001461216e576040516120f681611eed565b600181527f2d0000000000000000000000000000000000000000000000000000000000000084820152945b61216657612355565b9260405193816121438693518092868087019101611dbd565b820161215782518093868085019101611dbd565b01038084520182611f25565b90565b600003612355565b60405161217a81611f09565b6000815294612121565b909190600090810b13156121bc576001915b600083810b1290816121b0575b506121aa57565b60019150565b60ff91501615386121a3565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91612196565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016801561229e576020600491604051928380927fb80777ea0000000000000000000000000000000000000000000000000000000082525afa90811561229257600091612263575090565b90506020813d60201161228a575b8161227e60209383611f25565b81010312610297575190565b3d9150612271565b6040513d6000823e3d90fd5b504290565b60000b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8081146112985760000390565b9060ff8091169116019060ff821161129857565b60ff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9116019060ff821161129857565b9060ff8091169116039060ff821161129857565b9060ff169081156112c75760ff160490565b9060ff8091169116029060ff821691820361129857565b806000917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000808210156124f8575b506d04ee2d6d415b85acef8100000000808310156124e9575b50662386f26fc10000808310156124da575b506305f5e100808310156124cb575b50612710808310156124bc575b5060648210156124ac575b600a809210156124a2575b60019081602160018601957fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe061242961241389611f66565b986124216040519a8b611f25565b808a52611f66565b01366020890137860101905b612441575b5050505090565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff849101917f30313233343536373839616263646566000000000000000000000000000000008282061a83530491821561249d57919082612435565b61243a565b91600101916123db565b91906064600291049101916123d0565b600491939204910191386123c5565b600891939204910191386123b8565b601091939204910191386123a9565b60209193920491019138612397565b60409350810491503861237e56fea2646970667358221220b233bac4be30e357ce3f8e2b4cfae995d5e7a42565bb28b30793b24b3510b3cf64736f6c63430008180033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b60003560e01c90816301ffc9a714611cd05750806306fdde0314611c5c578063081812fc14611c02578063095ea7b314611a1357806323b872dd1461192f57806342842e0e146118ad57806348f3c51c146118175780636352211e1461177d57806370a082311461171b57806395d89b41146116a7578063a22cb465146115d8578063b88d4fde14611320578063c87b56dd1461031e578063e985e9c51461029c5763f3945282146100c457600080fd5b34610297576020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610297576004359067ffffffffffffffff8083116102975736602384011215610297578260040135908082116102975760246005943660248560051b830101116102975761013d84612041565b9561014b6040519788611f25565b8487527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe061017886612041565b0160005b81811061023e57505060005b8581106101eb57604080518881528951818a018190528a8a01928201908a60005b8281106101b65784840385f35b8551805173ffffffffffffffffffffffffffffffffffffffff16855282015184830152948101946040909301926001016101a9565b8084600192841b850101356000528188528560406000205473ffffffffffffffffffffffffffffffffffffffff8116610224848d612059565b515260b81c1688610235838c612059565b51015201610188565b604051604081018181108882111761026957604052600080825289820152898201890152870161017c565b867f4e487b710000000000000000000000000000000000000000000000000000000060005260416004526000fd5b600080fd5b346102975760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610297576102d3611e2a565b6102db611e4d565b9073ffffffffffffffffffffffffffffffffffffffff809116600052600560205260406000209116600052602052602060ff604060002054166040519015158152f35b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610297577f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000008101809111611298576103a06121e3565b7f00000000000000000000000000000000000000000000000000000000000000008082106112f6576103d19161209c565b81156112c7578181049160028301809311611298577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe62ffffff84160162ffffff81116112985762ffffff16818102918183041490151715611298576104369161209c565b50600061010060405161044881611ed0565b8281528260208201528260408201528260608201528260808201528260a08201528260c08201528260e0820152015267ffffffffffffffff6004351660005260006020526040600020906040519161049f83611ed0565b5462ffffff8116835262ffffff8160181c16602084015262ffffff8160301c16604084015260ff8160481c16600781101561105957606084015260ff8160501c1660808401528060581c60000b60a084015260ff8160601c1660c084015260ff8160681c1660e084015260ff8160701c1661010084015262ffffff835116906001821015808091611289575b6110b4575b5050600061054c60a0850151820b60ff60c08701511690612184565b810b13611088575b50506060810151600781101561105957606080918015600014610d6c5750505060405161058081611eed565b600481527f4e6f6e650000000000000000000000000000000000000000000000000000000060208201526040516105b681611eed565b600481527f67726179000000000000000000000000000000000000000000000000000000006020820152905b6105f663ffffffff6004351660030b6120d5565b9261060e63ffffffff60043560201c1660030b6120d5565b61061e60ff608084015116612355565b9161065562ffffff602061064c61064460a086015160000b60ff60c08801511690612184565b60000b6120d5565b93015116612355565b936040519260e084019084821067ffffffffffffffff831117610d3d577f3c2f747370616e3e3c2f746578743e3c2f7376673e0000000000000000000000610d2d9760c597610ba196867f293c2f747370616e3e3c747370616e2532353230783d27323536272532353230610d399e8e6102e29a60a08e7f2c000000000000000000000000000000000000000000000000000000000000009c6040528481528b6020820152886040820152876060820152896080820152015260c08d01526040519e8f998a927f646174613a696d6167652f7376672b786d6c2c3c7376672532353230786d6c6e60208501527f733d27687474703a2f2f7777772e77332e6f72672f323030302f73766727253260408501527f35323076696577426f783d27302532353230302532353230353132253235323060608501527f353132273e3c7469746c653e49736c616e64253235323000000000000000000060808501527f280000000000000000000000000000000000000000000000000000000000000060978501527f272532353230646f6d696e616e742d626173656c696e653d276d6964646c65278b825161080e816098890160208701611dbd565b84609882890101526020825192019661082d836099848401018a611dbd565b01017f293c2f7469746c653e3c726563742532353230783d273136272532353230793d60998201527f27313627253235323077696474683d273438302725323532306865696768743d60b98201527f273438302725323532307374726f6b653d27000000000000000000000000000060d9820152845160208601916108b68260eb830185611dbd565b017f2725323532307374726f6b652d77696474683d2733707827253235323066696c60eb8201527f6c3d277472616e73706172656e74272f3e3c746578742532353230783d27323561010b8201527f36272532353230793d27323536272532353230666f6e742d73697a653d27343861012b8201527f7078272532353230666f6e742d7765696768743d27626f6c642725323532306661014b8201527f696c6c3d2700000000000000000000000000000000000000000000000000000061016b82015261098c6101709651809388840190611dbd565b01938401527f2532353230746578742d616e63686f723d276d6964646c65273e3c747370616e6101908401527f2532353230783d2732353627253235323064793d272d332e37656d273e49736c6101b08401527f616e643c2f747370616e3e3c747370616e2532353230783d27323536272532356101d08401527f323064793d2731656d273e2800000000000000000000000000000000000000006101f08401526101fc92610a448251809360208785019101611dbd565b0191820152610a5c6101fd995180938b840190611dbd565b01968701527f64793d27322e32656d273e46616374696f6e3a2532353230000000000000000061021d87015261023595610a9f8251809360208a85019101611dbd565b01947f3c2f747370616e3e3c747370616e2532353230783d2732353627253235323064928380928801527f793d2731656d273e4c6966653a2532353230000000000000000000000000000061025588015261026796610b078251809360208b85019101611dbd565b01958601527f793d2731656d273e47726f7774683a253235323000000000000000000000000061028786015261029b94610b4a8251809360208985019101611dbd565b01938401527f793d27322e33656d273e45706f636825323000000000000000000000000000006102bb8401526102cd92610b8d8251809360208785019101611dbd565b0191820152036102c2810187520185611f25565b60208151910151936040519485927f646174613a6170706c69636174696f6e2f6a736f6e2c7b226e616d65223a224960208501527f736c616e642532302800000000000000000000000000000000000000000000006040850152610c0f815180926020604988019101611dbd565b83017f2c000000000000000000000000000000000000000000000000000000000000006049820152610c4b825180936020604a85019101611dbd565b017f29222c226465736372697074696f6e223a224125323050696563652532304f66604a8201527f2532304c616e64253230496e25323053747261746167656d732c253230416e25606a8201527f32304175746f6e6f6d6f7573253230576f726c64253230437265617465642532608a8201527f304279253230506c61796572732e222c22696d616765223a220000000000000060aa820152610cf882518093602060c385019101611dbd565b017f227d00000000000000000000000000000000000000000000000000000000000060c38201520360a5810184520182611f25565b60405191829182611de0565b0390f35b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60018103610dea57505050604051610d8381611eed565b600481527f426c7565000000000000000000000000000000000000000000000000000000006020820152604051610db981611eed565b600481527f626c7565000000000000000000000000000000000000000000000000000000006020820152905b6105e2565b60028103610e6757505050604051610e0181611eed565b600381527f52656400000000000000000000000000000000000000000000000000000000006020820152604051610e3781611eed565b600381527f72656400000000000000000000000000000000000000000000000000000000006020820152906105e2565b60038103610ee457505050604051610e7e81611eed565b600581527f477265656e0000000000000000000000000000000000000000000000000000006020820152604051610eb481611eed565b600581527f677265656e0000000000000000000000000000000000000000000000000000006020820152906105e2565b60048103610f6157505050604051610efb81611eed565b600681527f59656c6c6f7700000000000000000000000000000000000000000000000000006020820152604051610f3181611eed565b600681527f79656c6c6f7700000000000000000000000000000000000000000000000000006020820152906105e2565b60058103610fde57505050604051610f7881611eed565b600681527f507572706c6500000000000000000000000000000000000000000000000000006020820152604051610fae81611eed565b600681527f707572706c6500000000000000000000000000000000000000000000000000006020820152906105e2565b600603610de5575050604051610ff381611eed565b600481527f4576696c00000000000000000000000000000000000000000000000000000000602082015260405161102981611eed565b600581527f626c61636b0000000000000000000000000000000000000000000000000000006020820152906105e2565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b61109b6110a79162ffffff8094166120a9565b826040850151166120be565b1660408201528180610554565b60ff916000918061127b575b6110db575b5016608084015262ffffff821683528380610530565b905062ffffff6110ed848287166120a9565b1690811561126f5761110a838260601c168260581c60000b612184565b918260000b600081136000146111b55750908361118661116c8261119095816111767f000000000000000000000000000000000000000000000000000000000000000099611171611160848b60501c168d612318565b918416968780936122d3565b6122e7565b61232c565b168082116111ad575b501661233e565b9160501c166122d3565b90828116838316116111a5575b505b856110c5565b90508561119d565b90508c61117f565b9092906000131561126257836111f16111e061116c6111d3856122a3565b8416848760501c166122d3565b6111e9846122a3565b83169061232c565b16808411611258575b50611207611211916122a3565b841684841661233e565b838260501c168482161160001461123c57505061123662ffffff6000925b16846120be565b5061119f565b61125262ffffff91856112369460501c16612318565b9261122f565b92506112076111fa565b5082915060501c1661119f565b82915060501c1661119f565b50828160501c1615156110c0565b5060ff8260501c16151561052b565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60046040517f3a5f7b57000000000000000000000000000000000000000000000000000000008152fd5b346102975760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757611357611e2a565b61135f611e4d565b6044359060643567ffffffffffffffff811161029757366023820112156102975780600401359061138f82611f66565b9161139d6040519384611f25565b80835236602482840101116102975760009281602460209401848301370101526114218260005260016020526040600020549073ffffffffffffffffffffffffffffffffffffffff8216916affffffffffffffffffffff7f8000000000000000000000000000000000000000000000000000000000000000808316149160a01c1691565b939192905073ffffffffffffffffffffffffffffffffffffffff928381169586156115a75784811680970361155857505082168015801561154f575b61151e5750833303611494575b60046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b82611502575b50501590816114dc575b506114b2578080808061146a565b60046040517fea8e4eb5000000000000000000000000000000000000000000000000000000008152fd5b9050600052600560205260406000203360005260205260ff6040600020541615816114a4565b909150600052600660205233906040600020541614828061149a565b602490604051907f8e4c8aa60000000000000000000000000000000000000000000000000000000082526004820152fd5b5030811461145d565b6040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff918216600482015291166024820152604490fd5b602484604051907f38077a2b0000000000000000000000000000000000000000000000000000000082526004820152fd5b346102975760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102975761160f611e2a565b6024358015158091036102975733600052600560205273ffffffffffffffffffffffffffffffffffffffff60406000209216918260005260205260406000207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0081541660ff83161790556040519081527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3160203392a3005b346102975760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757610d396040516116e581611eed565b600681527f49534c414e440000000000000000000000000000000000000000000000000000602082015260405191829182611de0565b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757611752611e2a565b5060046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102975760043580600052600160205273ffffffffffffffffffffffffffffffffffffffff604060002054169081156117e657602082604051908152f35b602490604051907f38077a2b0000000000000000000000000000000000000000000000000000000082526004820152fd5b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102975760406118886004356000526001602052604060002054906affffffffffffffffffffff73ffffffffffffffffffffffffffffffffffffffff83169260a01c1690565b73ffffffffffffffffffffffffffffffffffffffff83519216825260181c6020820152f35b34610297576118bb36611e70565b9060006040516118ca81611f09565b526114218260005260016020526040600020549073ffffffffffffffffffffffffffffffffffffffff8216916affffffffffffffffffffff7f8000000000000000000000000000000000000000000000000000000000000000808316149160a01c1691565b346102975761193d36611e70565b906119a28260005260016020526040600020549073ffffffffffffffffffffffffffffffffffffffff8216916affffffffffffffffffffff7f8000000000000000000000000000000000000000000000000000000000000000808316149160a01c1691565b939192905073ffffffffffffffffffffffffffffffffffffffff928381169586156115a75784811696870361155857505082168015801561154f5761151e57508333036114945760046040517fd6234725000000000000000000000000000000000000000000000000000000008152fd5b346102975760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757611a4a611e2a565b60243590611a8c826000526001602052604060002054906affffffffffffffffffffff73ffffffffffffffffffffffffffffffffffffffff83169260a01c1690565b9173ffffffffffffffffffffffffffffffffffffffff809216918215611bd1578233141580611bac575b6114b25760018401938481116112985760181c8460181c03611b82571691819083611b165784600052600160205260a01b176040600020555b7f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925600080a4005b84600052600160205260a01b177f80000000000000000000000000000000000000000000000000000000000000001760406000205560066020526040600020827fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055611aef565b60046040517fadc15572000000000000000000000000000000000000000000000000000000008152fd5b5082600052600560205260406000203360005260205260ff6040600020541615611ab6565b602485604051907f38077a2b0000000000000000000000000000000000000000000000000000000082526004820152fd5b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610297576020611c3e600435611fa0565b73ffffffffffffffffffffffffffffffffffffffff60405191168152f35b346102975760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757610d39604051611c9a81611eed565b600781527f49736c616e647300000000000000000000000000000000000000000000000000602082015260405191829182611de0565b346102975760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261029757600435907fffffffff00000000000000000000000000000000000000000000000000000000821680920361029757817f01ffc9a70000000000000000000000000000000000000000000000000000000060209314908115611d93575b8115611d69575b5015158152f35b7f5b5e139f0000000000000000000000000000000000000000000000000000000091501483611d62565b7f80ac58cd0000000000000000000000000000000000000000000000000000000081149150611d5b565b60005b838110611dd05750506000910152565b8181015183820152602001611dc0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60409360208452611e238151809281602088015260208888019101611dbd565b0116010190565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361029757565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361029757565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60609101126102975773ffffffffffffffffffffffffffffffffffffffff90600435828116810361029757916024359081168103610297579060443590565b610120810190811067ffffffffffffffff821117610d3d57604052565b6040810190811067ffffffffffffffff821117610d3d57604052565b6020810190811067ffffffffffffffff821117610d3d57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610d3d57604052565b67ffffffffffffffff8111610d3d57601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b8060005260016020526040600020549073ffffffffffffffffffffffffffffffffffffffff917f80000000000000000000000000000000000000000000000000000000000000009083811615612010578116036120095760005260066020526040600020541690565b5050600090565b602483604051907f38077a2b0000000000000000000000000000000000000000000000000000000082526004820152fd5b67ffffffffffffffff8111610d3d5760051b60200190565b805182101561206d5760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b9190820391821161129857565b62ffffff918216908216039190821161129857565b91909162ffffff8080941691160191821161129857565b612163602061212a60008412938460001461216e576040516120f681611eed565b600181527f2d0000000000000000000000000000000000000000000000000000000000000084820152945b61216657612355565b9260405193816121438693518092868087019101611dbd565b820161215782518093868085019101611dbd565b01038084520182611f25565b90565b600003612355565b60405161217a81611f09565b6000815294612121565b909190600090810b13156121bc576001915b600083810b1290816121b0575b506121aa57565b60019150565b60ff91501615386121a3565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91612196565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016801561229e576020600491604051928380927fb80777ea0000000000000000000000000000000000000000000000000000000082525afa90811561229257600091612263575090565b90506020813d60201161228a575b8161227e60209383611f25565b81010312610297575190565b3d9150612271565b6040513d6000823e3d90fd5b504290565b60000b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8081146112985760000390565b9060ff8091169116019060ff821161129857565b60ff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9116019060ff821161129857565b9060ff8091169116039060ff821161129857565b9060ff169081156112c75760ff160490565b9060ff8091169116029060ff821691820361129857565b806000917a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000808210156124f8575b506d04ee2d6d415b85acef8100000000808310156124e9575b50662386f26fc10000808310156124da575b506305f5e100808310156124cb575b50612710808310156124bc575b5060648210156124ac575b600a809210156124a2575b60019081602160018601957fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe061242961241389611f66565b986124216040519a8b611f25565b808a52611f66565b01366020890137860101905b612441575b5050505090565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff849101917f30313233343536373839616263646566000000000000000000000000000000008282061a83530491821561249d57919082612435565b61243a565b91600101916123db565b91906064600291049101916123d0565b600491939204910191386123c5565b600891939204910191386123b8565b601091939204910191386123a9565b60209193920491019138612397565b60409350810491503861237e56fea2646970667358221220b233bac4be30e357ce3f8e2b4cfae995d5e7a42565bb28b30793b24b3510b3cf64736f6c63430008180033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "errors": {
      "InvalidAddress(address)": [
        {
          "params": {
            "addr": "invalid address"
          }
        }
      ],
      "NonExistentToken(uint256)": [
        {
          "params": {
            "tokenID": "id of the expected token"
          }
        }
      ],
      "NotOwner(address,address)": [
        {
          "params": {
            "currentOwner": "the current owner",
            "provided": "the address expected to be the current owner"
          }
        }
      ],
      "ReserveTooLow(uint256,uint256)": [
        {
          "params": {
            "expected": "amount required to proceed",
            "inReserve": "amount in reserver as the time of the call"
          }
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "params": {
          "approved": "account who can know transfer on the owner's behalf",
          "owner": "current owner of the token",
          "tokenID": "id of the token being approved"
        }
      },
      "ApprovalForAll(address,address,bool)": {
        "params": {
          "approved": "whether it is approved or not",
          "operator": "account who can know transfer on the owner's behalf",
          "owner": "the account granting rights over all of its token"
        }
      },
      "CommitmentCancelled(address,uint24)": {
        "params": {
          "epoch": "epoch number on which this commit belongs to",
          "player": "account taking the staking risk (can be a different account than the one controlling the gems)"
        }
      },
      "CommitmentMade(address,uint24,bytes24)": {
        "params": {
          "commitmentHash": "the hash of moves",
          "epoch": "epoch number on which this commit belongs to",
          "player": "account taking the staking risk (can be a different account than the one controlling the gems)"
        }
      },
      "CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)": {
        "params": {
          "commitmentHash": "the hash of the moves",
          "epoch": "epoch number on which this commit belongs to",
          "furtherMoves": "hash of further moves, unless bytes32(0) which indicate end.",
          "moves": "the moves",
          "newReserveAmount": "new amount in reserve as a result",
          "player": "account who commited"
        }
      },
      "CommitmentVoid(address,uint24,uint256,bytes24)": {
        "params": {
          "amountBurnt": "amount of token to burn",
          "epoch": "epoch number on which this commit belongs to",
          "furtherMoves": "hash of further moves, unless bytes32(0) which indicate end.",
          "player": "the account that made the commitment"
        }
      },
      "MoveProcessed(uint64,address,uint8,uint8)": {
        "params": {
          "newColor": "color that takes over",
          "oldColor": "previous color of the cell",
          "player": "account making the move",
          "position": "cell at which the move take place"
        }
      },
      "MultiPoke(uint24,uint64[])": {
        "params": {
          "epoch": "epoch number at which the poke take place",
          "positions": "cells to poke"
        }
      },
      "ReserveDeposited(address,uint256,uint256)": {
        "params": {
          "amountDeposited": "the number of tokens deposited",
          "newAmount": "the number of tokens in reserver as a result",
          "player": "account receiving the token in the reserve"
        }
      },
      "ReserveWithdrawn(address,uint256,uint256)": {
        "params": {
          "amountWithdrawn": "the number of tokens withdrawnn",
          "newAmount": "the number of tokens in reserver as a result",
          "player": "account withdrawing the tokens"
        }
      },
      "SinglePoke(uint24,uint64)": {
        "params": {
          "epoch": "epoch number at which the poke take place",
          "position": "cell to poke"
        }
      },
      "Transfer(address,address,uint256)": {
        "params": {
          "from": "the account the token is sent from",
          "to": "the account the token is sent to",
          "tokenID": "id of the token being sent"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "approve(address,uint256)": {
        "params": {
          "operator": "The address receiving the approval.",
          "tokenID": "The id of the token."
        }
      },
      "getApproved(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "operator": "The address of the operator."
        }
      },
      "isApprovedForAll(address,address)": {
        "params": {
          "operator": "The address of the operator.",
          "owner": "The address of the owner."
        },
        "returns": {
          "_0": "isOperator The status of the approval."
        }
      },
      "ownerAndLastTransferBlockNumberList(uint256[])": {
        "params": {
          "tokenIDs": "The list of token ids to check."
        },
        "returns": {
          "ownersData": "The list of (owner, lastTransferBlockNumber) for each ids given as input."
        }
      },
      "ownerAndLastTransferBlockNumberOf(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "blockNumber": "The blocknumber at which the last transfer of that id happened.",
          "owner": "The address of the token owner."
        }
      },
      "ownerOf(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "owner": "The address of the token owner."
        }
      },
      "safeTransferFrom(address,address,uint256)": {
        "params": {
          "from": "The send of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "params": {
          "data": "Additional data.",
          "from": "The sender of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      },
      "setApprovalForAll(address,bool)": {
        "params": {
          "approved": "The determination of the approval.",
          "operator": "The address receiving the approval."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",
        "params": {
          "interfaceID": "The interface identifier, as specified in ERC-165"
        },
        "returns": {
          "_0": "`true` if the contract implements `interfaceID` and  `interfaceID` is not 0xffffffff, `false` otherwise"
        }
      },
      "tokenURI(uint256)": {
        "details": "Throws if `tokenID` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the \"ERC721  Metadata JSON Schema\".",
        "params": {
          "tokenID": "id of the token being queried."
        }
      },
      "transferFrom(address,address,uint256)": {
        "params": {
          "from": "The sender of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "1906400",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "approve(address,uint256)": "53247",
        "balanceOf(address)": "391",
        "getApproved(uint256)": "4629",
        "isApprovedForAll(address,address)": "2816",
        "name()": "infinite",
        "ownerAndLastTransferBlockNumberList(uint256[])": "infinite",
        "ownerAndLastTransferBlockNumberOf(uint256)": "2522",
        "ownerOf(uint256)": "2528",
        "safeTransferFrom(address,address,uint256)": "7412",
        "safeTransferFrom(address,address,uint256,bytes)": "infinite",
        "setApprovalForAll(address,bool)": "26598",
        "supportsInterface(bytes4)": "296",
        "symbol()": "infinite",
        "tokenURI(uint256)": "infinite",
        "transferFrom(address,address,uint256)": "7299"
      },
      "internal": {
        "_approveFor(address,uint256,address,uint256)": "infinite",
        "_checkOnERC721Received(address,address,address,uint256,bytes memory)": "infinite",
        "_factionDisplay(enum UsingStratagemsTypes.Color)": "infinite",
        "_ownerAndNonceOf(uint256)": "infinite",
        "_ownerAndOperatorEnabledOf(uint256)": "infinite",
        "_ownerNonceAndOperatorEnabledOf(uint256)": "infinite",
        "_safeMint(address,uint256)": "infinite",
        "_safeTransferFrom(address,address,uint256,bool,bytes memory)": "infinite",
        "_setApprovalForAll(address,address,bool)": "infinite",
        "_svgURI(struct UsingStratagemsTypes.DisplayData memory)": "infinite",
        "_transferFrom(address,address,uint256,bool)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20WithIERC2612\",\"name\":\"tokens\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"burnAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"maxLife\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numTokensPerGems\",\"type\":\"uint256\"},{\"internalType\":\"contract ITime\",\"name\":\"time\",\"type\":\"address\"},{\"internalType\":\"contract IOnStakeChange\",\"name\":\"generator\",\"type\":\"address\"}],\"internalType\":\"struct UsingStratagemsTypes.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CanStillReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CommitmentHashNotMatching\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GameNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ImpossibleConfiguration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InCommitmentPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InRevealPhase\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFurtherMoves\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"NonExistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotImplemented\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provided\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PreviousCommitmentNotRevealed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"ReserveTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferRejected\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"}],\"name\":\"CommitmentCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"}],\"name\":\"CommitmentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"color\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct UsingStratagemsTypes.Move[]\",\"name\":\"moves\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveAmount\",\"type\":\"uint256\"}],\"name\":\"CommitmentRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"}],\"name\":\"CommitmentVoid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"oldColor\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"newColor\",\"type\":\"uint8\"}],\"name\":\"MoveProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"positions\",\"type\":\"uint64[]\"}],\"name\":\"MultiPoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ReserveDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ReserveWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"}],\"name\":\"SinglePoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"ownerAndLastTransferBlockNumberList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastTransferBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct IERC721WithBlocknumber.OwnerData[]\",\"name\":\"ownersData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerAndLastTransferBlockNumberOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidAddress(address)\":[{\"params\":{\"addr\":\"invalid address\"}}],\"NonExistentToken(uint256)\":[{\"params\":{\"tokenID\":\"id of the expected token\"}}],\"NotOwner(address,address)\":[{\"params\":{\"currentOwner\":\"the current owner\",\"provided\":\"the address expected to be the current owner\"}}],\"ReserveTooLow(uint256,uint256)\":[{\"params\":{\"expected\":\"amount required to proceed\",\"inReserve\":\"amount in reserver as the time of the call\"}}]},\"events\":{\"Approval(address,address,uint256)\":{\"params\":{\"approved\":\"account who can know transfer on the owner's behalf\",\"owner\":\"current owner of the token\",\"tokenID\":\"id of the token being approved\"}},\"ApprovalForAll(address,address,bool)\":{\"params\":{\"approved\":\"whether it is approved or not\",\"operator\":\"account who can know transfer on the owner's behalf\",\"owner\":\"the account granting rights over all of its token\"}},\"CommitmentCancelled(address,uint24)\":{\"params\":{\"epoch\":\"epoch number on which this commit belongs to\",\"player\":\"account taking the staking risk (can be a different account than the one controlling the gems)\"}},\"CommitmentMade(address,uint24,bytes24)\":{\"params\":{\"commitmentHash\":\"the hash of moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"player\":\"account taking the staking risk (can be a different account than the one controlling the gems)\"}},\"CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)\":{\"params\":{\"commitmentHash\":\"the hash of the moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"furtherMoves\":\"hash of further moves, unless bytes32(0) which indicate end.\",\"moves\":\"the moves\",\"newReserveAmount\":\"new amount in reserve as a result\",\"player\":\"account who commited\"}},\"CommitmentVoid(address,uint24,uint256,bytes24)\":{\"params\":{\"amountBurnt\":\"amount of token to burn\",\"epoch\":\"epoch number on which this commit belongs to\",\"furtherMoves\":\"hash of further moves, unless bytes32(0) which indicate end.\",\"player\":\"the account that made the commitment\"}},\"MoveProcessed(uint64,address,uint8,uint8)\":{\"params\":{\"newColor\":\"color that takes over\",\"oldColor\":\"previous color of the cell\",\"player\":\"account making the move\",\"position\":\"cell at which the move take place\"}},\"MultiPoke(uint24,uint64[])\":{\"params\":{\"epoch\":\"epoch number at which the poke take place\",\"positions\":\"cells to poke\"}},\"ReserveDeposited(address,uint256,uint256)\":{\"params\":{\"amountDeposited\":\"the number of tokens deposited\",\"newAmount\":\"the number of tokens in reserver as a result\",\"player\":\"account receiving the token in the reserve\"}},\"ReserveWithdrawn(address,uint256,uint256)\":{\"params\":{\"amountWithdrawn\":\"the number of tokens withdrawnn\",\"newAmount\":\"the number of tokens in reserver as a result\",\"player\":\"account withdrawing the tokens\"}},\"SinglePoke(uint24,uint64)\":{\"params\":{\"epoch\":\"epoch number at which the poke take place\",\"position\":\"cell to poke\"}},\"Transfer(address,address,uint256)\":{\"params\":{\"from\":\"the account the token is sent from\",\"to\":\"the account the token is sent to\",\"tokenID\":\"id of the token being sent\"}}},\"kind\":\"dev\",\"methods\":{\"approve(address,uint256)\":{\"params\":{\"operator\":\"The address receiving the approval.\",\"tokenID\":\"The id of the token.\"}},\"getApproved(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"operator\":\"The address of the operator.\"}},\"isApprovedForAll(address,address)\":{\"params\":{\"operator\":\"The address of the operator.\",\"owner\":\"The address of the owner.\"},\"returns\":{\"_0\":\"isOperator The status of the approval.\"}},\"ownerAndLastTransferBlockNumberList(uint256[])\":{\"params\":{\"tokenIDs\":\"The list of token ids to check.\"},\"returns\":{\"ownersData\":\"The list of (owner, lastTransferBlockNumber) for each ids given as input.\"}},\"ownerAndLastTransferBlockNumberOf(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"blockNumber\":\"The blocknumber at which the last transfer of that id happened.\",\"owner\":\"The address of the token owner.\"}},\"ownerOf(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"owner\":\"The address of the token owner.\"}},\"safeTransferFrom(address,address,uint256)\":{\"params\":{\"from\":\"The send of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}},\"safeTransferFrom(address,address,uint256,bytes)\":{\"params\":{\"data\":\"Additional data.\",\"from\":\"The sender of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}},\"setApprovalForAll(address,bool)\":{\"params\":{\"approved\":\"The determination of the approval.\",\"operator\":\"The address receiving the approval.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.\",\"params\":{\"interfaceID\":\"The interface identifier, as specified in ERC-165\"},\"returns\":{\"_0\":\"`true` if the contract implements `interfaceID` and  `interfaceID` is not 0xffffffff, `false` otherwise\"}},\"tokenURI(uint256)\":{\"details\":\"Throws if `tokenID` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the \\\"ERC721  Metadata JSON Schema\\\".\",\"params\":{\"tokenID\":\"id of the token being queried.\"}},\"transferFrom(address,address,uint256)\":{\"params\":{\"from\":\"The sender of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"CanStillReveal()\":[{\"notice\":\"Player have to reveal if they can Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal.\"}],\"CommitmentHashNotMatching()\":[{\"notice\":\"Player have to reveal their commitment using the exact same move values  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal.\"}],\"GameNotStarted()\":[{\"notice\":\"Game has not started yet, can't perform any action\"}],\"ImpossibleConfiguration()\":[{\"notice\":\"The cell configuration is invalid This can happen win debug mode where admin can setup cell bypassing moves rules For example when setting up neighborood configuration that would require a cell to have negative life\"}],\"InCommitmentPhase()\":[{\"notice\":\"When in Commit phase, player can make new commitment but they cannot reveal their move yet.\"}],\"InRevealPhase()\":[{\"notice\":\"When in Reveal phase, it is not possible to commit new moves or cancel previous commitment  During Reveal phase, players have to reveal their commitment, if not already done.\"}],\"InvalidAddress(address)\":[{\"notice\":\"An invalid address is specified (for example: zero address)\"}],\"InvalidEpoch()\":[{\"notice\":\"Player can only reveal their move in the same epoch they commited.abi  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`\"}],\"InvalidFurtherMoves()\":[{\"notice\":\"Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves  This result in a recursive series of hash that they can then submit in turn while revealing.  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block.\"}],\"NonExistentToken(uint256)\":[{\"notice\":\"The token does not exist\"}],\"NonceOverflow()\":[{\"notice\":\"The Nonce overflowed, make a transfer to self to allow new nonces.\"}],\"NotAuthorized()\":[{\"notice\":\"Not authorized to perform this operation\"}],\"NotImplemented()\":[{\"notice\":\"function is not implemented\"}],\"NotOwner(address,address)\":[{\"notice\":\"The address from which the token is sent is not the current owner\"}],\"NothingToReveal()\":[{\"notice\":\"Player can only reveal moves they commited.\"}],\"PreviousCommitmentNotRevealed()\":[{\"notice\":\"Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\\\  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\\\If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\\\\"}],\"ReserveTooLow(uint256,uint256)\":[{\"notice\":\"to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase.\"}],\"TransferRejected()\":[{\"notice\":\"The Transfer was rejected by the destination\"}]},\"events\":{\"Approval(address,address,uint256)\":{\"notice\":\"Triggered when a token is approved to be sent by another account  Note tat the approval get reset when a Transfer event for that same token is emitted.\"},\"ApprovalForAll(address,address,bool)\":{\"notice\":\"Triggered when an account approve or disaprove another to transfer on its behalf\"},\"CommitmentCancelled(address,uint24)\":{\"notice\":\"A player has cancelled its current commitment (before it reached the reveal phase)\"},\"CommitmentMade(address,uint24,bytes24)\":{\"notice\":\"A player has commited to make a move and reveal it on the reveal phase\"},\"CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)\":{\"notice\":\"Player has revealed its previous commitment\"},\"CommitmentVoid(address,uint24,uint256,bytes24)\":{\"notice\":\"A player has canceled a previous commitment by burning some tokens\"},\"MoveProcessed(uint64,address,uint8,uint8)\":{\"notice\":\"A move has been revealed.\"},\"MultiPoke(uint24,uint64[])\":{\"notice\":\"poke multiple cells and update them if needed\"},\"ReserveDeposited(address,uint256,uint256)\":{\"notice\":\"Player has deposited token in the reserve, allowing it to use that much in game\"},\"ReserveWithdrawn(address,uint256,uint256)\":{\"notice\":\"Player have withdrawn token from the reserve\"},\"SinglePoke(uint24,uint64)\":{\"notice\":\"poke cell and update it if needed\"},\"Transfer(address,address,uint256)\":{\"notice\":\"Triggered when a token is transferred\"}},\"kind\":\"user\",\"methods\":{\"approve(address,uint256)\":{\"notice\":\"Approve an operator to transfer a specific token on the senders behalf.\"},\"balanceOf(address)\":{\"notice\":\"balanceOf is not implemented, keeping track of this add gas and we did not consider that worth it\"},\"getApproved(uint256)\":{\"notice\":\"Get the approved operator for a specific token.\"},\"isApprovedForAll(address,address)\":{\"notice\":\"Check if the sender approved the operator to transfer any of its tokens.\"},\"name()\":{\"notice\":\"A descriptive name for a collection of NFTs in this contract\"},\"ownerAndLastTransferBlockNumberList(uint256[])\":{\"notice\":\"Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\"},\"ownerAndLastTransferBlockNumberOf(uint256)\":{\"notice\":\"Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\"},\"ownerOf(uint256)\":{\"notice\":\"Get the owner of a token.\"},\"safeTransferFrom(address,address,uint256)\":{\"notice\":\"Transfer a token between 2 addresses letting the receiver know of the transfer.\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"notice\":\"Transfer a token between 2 addresses letting the receiver knows of the transfer.\"},\"setApprovalForAll(address,bool)\":{\"notice\":\"Set the approval for an operator to manage all the tokens of the sender.\"},\"supportsInterface(bytes4)\":{\"notice\":\"Query if a contract implements an interface\"},\"symbol()\":{\"notice\":\"An abbreviated name for NFTs in this contract\"},\"tokenURI(uint256)\":{\"notice\":\"A distinct Uniform Resource Identifier (URI) for a given asset.\"},\"transferFrom(address,address,uint256)\":{\"notice\":\"Transfer a token between 2 addresses.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/game/routes/StratagemsERC721.sol\":\"StratagemsERC721\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC165/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0bbdb7cf3d2c6acf95398c0ef54cb0e6ae8a3e6ce6f18fafeb0aa55cb74fb8fd\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/ERC2612/interfaces/IERC20WithIERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC20.sol\\\";\\nimport \\\"./IERC2612.sol\\\";\\n\\ninterface IERC20WithIERC2612 is IERC20, IERC2612 {}\\n\",\"keccak256\":\"0x66100d98de50a396d46feb17a2b2b400b13f033f5e01b45e95901e61a4feef05\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/ERC2612/interfaces/IERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingERC2612Errors.sol\\\";\\n\\ninterface IERC2612 {\\n    /// @notice allow `spender` to spend `value` amount of token on behalf of `owner`\\n    /// @param owner owner of the tokens\\n    /// @param spender address allowed to spend on behalf of the owner.\\n    /// @param value amount of token allowed to be spent\\n    /// @param deadline timestamp in seconds after which the permit is not valid.\\n    /// @param v signature part v\\n    /// @param r signature part r\\n    /// @param s signature part s\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /// @notice return the current nonce of the owner\\n    /// @param owner address queried\\n    /// @return nonce nonce value\\n    function nonces(address owner) external view returns (uint256 nonce);\\n\\n    /// @notice EIP-712 Domain separator hash\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x34dfefe126ef9115359eeaf4884977436dc639b991efcf490b386181cd664c06\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/ERC2612/interfaces/UsingERC2612Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC2612Errors {\\n    /// @notice The signature do not match the expected signer\\n    error InvalidSignature();\\n\\n    /// @notice The permit has expired\\n    /// @param currentTime time at which the error happen\\n    /// @param deadline the deadline\\n    error DeadlineOver(uint256 currentTime, uint256 deadline);\\n}\\n\",\"keccak256\":\"0x5d125f2509e60059af45358f0ca405e21f647b2e61502288fdc6d23aded256f6\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingERC20Events.sol\\\";\\n\\ninterface IERC20 is UsingERC20Events {\\n    /// @notice Returns the total token supply.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals the token uses.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the account balance of another account with address `owner`.\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /// @notice Transfers `amount` of tokens to address `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Allows `spender` to withdraw from your account multiple times, up to `amount`.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from address `from` to address `to`.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x3a6bcd5cf1d9e50fbe405f4c6c9c868e97ce2a84ae99fd7c1fb2d916c4d5debd\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/interfaces/UsingERC20Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC20Events {\\n    /// @notice trigger when tokens are transferred, including zero value transfers.\\n    /// @param from the account the tokens are sent from\\n    /// @param to the account the tokens are sent to\\n    /// @param value number of tokens sent\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice trigger on approval amount being set.\\n    ///   Note that Transfer events need to be considered to compute the current allowance.\\n    /// @param owner the account approving the `spender`\\n    /// @param spender the account allowed to spend\\n    /// @param value the amount granted\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x15eaa1de7fe9e02ba9e83f262b2b7f33a4bfe0f5a3ae2be4d616b6c4dce1c6fa\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/implementations/ImplementingERC721Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ImplementingERC721Internal {\\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual returns (address owner, uint256 nonce);\\n\\n    function _approveFor(\\n        address owner,\\n        uint256 nonce,\\n        address operator,\\n        uint256 tokenID\\n    ) internal virtual;\\n\\n    function _setApprovalForAll(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0xa8a6ed1a764da2589bd932b67174805ef0c47120d27fa4defc17a2368757efbe\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"./UsingERC721Events.sol\\\";\\n\\ninterface IERC721Supply {\\n    /// @notice return the total number of token in existence\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IERC721 is IERC165, UsingERC721Events {\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return balance The number of tokens owned by the address.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Get the owner of a token.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 tokenID) external view returns (address owner);\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes calldata data) external;\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function safeTransferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function transferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param tokenID The id of the token.\\n    function approve(address operator, uint256 tokenID) external;\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param tokenID The id of the token.\\n    /// @return operator The address of the operator.\\n    function getApproved(uint256 tokenID) external view returns (address operator);\\n\\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa2a5afc2f4e761179de9c718ee807e2d682ed4ae39884906ac333c20282a95d1\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface IERC721Metadata is IERC721 {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory name);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory symbol);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `tokenID` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    /// @param tokenID id of the token being queried.\\n    function tokenURI(uint256 tokenID) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x8a4ff84c39ad5c6bbf3e5486d3687bc1e15b96835ede5761f1922cf7a72f3354\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Receiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param operator The address which called `safeTransferFrom` function\\n    /// @param from The address which previously owned the token\\n    /// @param tokenID The NFT identifier which is being transferred\\n    /// @param data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenID,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x47e1a42d5906cbc70c15f0352836dc7922d857632075c858f64e6286669a5e2e\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721WithBlocknumber.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721WithBlocknumber {\\n    /// @notice Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    /// @return blockNumber The blocknumber at which the last transfer of that id happened.\\n    function ownerAndLastTransferBlockNumberOf(uint256 tokenID)\\n        external\\n        view\\n        returns (address owner, uint256 blockNumber);\\n\\n    struct OwnerData {\\n        address owner;\\n        uint256 lastTransferBlockNumber;\\n    }\\n\\n    /// @notice Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\\n    /// @param tokenIDs The list of token ids to check.\\n    /// @return ownersData The list of (owner, lastTransferBlockNumber) for each ids given as input.\\n    function ownerAndLastTransferBlockNumberList(uint256[] calldata tokenIDs)\\n        external\\n        view\\n        returns (OwnerData[] memory ownersData);\\n}\\n\",\"keccak256\":\"0x2461ec24c55a1b6c13d451e52ad7600bc2da469996041700a3775efbcde7042b\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC721Errors {\\n    /// @notice The token does not exist\\n    /// @param tokenID id of the expected token\\n    error NonExistentToken(uint256 tokenID);\\n\\n    /// @notice The address from which the token is sent is not the current owner\\n    /// @param provided the address expected to be the current owner\\n    /// @param currentOwner the current owner\\n    error NotOwner(address provided, address currentOwner);\\n\\n    /// @notice An invalid address is specified (for example: zero address)\\n    /// @param addr invalid address\\n    error InvalidAddress(address addr);\\n\\n    /// @notice The Transfer was rejected by the destination\\n    error TransferRejected();\\n\\n    /// @notice The Nonce overflowed, make a transfer to self to allow new nonces.\\n    error NonceOverflow();\\n}\\n\",\"keccak256\":\"0x1ad5bfe4e6e4867fd18da1b7dafa3b339652177c09119621a1e59590b19fe7c1\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC721Events {\\n    /// @notice Triggered when a token is transferred\\n    /// @param from the account the token is sent from\\n    /// @param to the account the token is sent to\\n    /// @param tokenID id of the token being sent\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when a token is approved to be sent by another account\\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\\n    /// @param owner current owner of the token\\n    /// @param approved account who can know transfer on the owner's behalf\\n    /// @param tokenID id of the token being approved\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\\n    /// @param owner the account granting rights over all of its token\\n    /// @param operator account who can know transfer on the owner's behalf\\n    /// @param approved whether it is approved or not\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\",\"keccak256\":\"0x1b0d4ae18443a686be830d3a6ce203d563fe2f42ac9cc3fdf722b702d18152a2\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/debug/time/interfaces/ITime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./UsingTimeEvents.sol\\\";\\n\\ninterface ITime is UsingTimeEvents {\\n    function timestamp() external view returns (uint256);\\n}\\n\\ninterface ITimeSetter is UsingTimeEvents {\\n    function increaseTime(uint256 delta) external;\\n}\\n\",\"keccak256\":\"0xa81ea4359b841652e020f83fded0488b2df8409ebaaf2c39362f2ef4bdb454e9\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/debug/time/interfaces/UsingTimeEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingTimeEvents {\\n    event TimeIncreased(uint256 newTime, uint256 delta);\\n}\\n\",\"keccak256\":\"0x73ca9f6cce68bd84d1d487bb3e7bbe4224ab413bc4007ff4a22e0abb04897de4\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Openzeppelin_Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x54a1b5eb6fdeb706049c5f570c398a49ea05f3da2d8e35f3ae344059d622350a\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/utils/UsingGenericErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingGenericErrors {\\n    /// @notice Not authorized to perform this operation\\n    error NotAuthorized();\\n\\n    /// @notice Token cannot be transfered\\n    error NonTransferable();\\n\\n    /// @notice function is not implemented\\n    error NotImplemented();\\n}\\n\",\"keccak256\":\"0x20c56b2d5fb3d35c86ba8325a342f4e7c21c8db3c5edf967f7ddd0c49f692e8f\",\"license\":\"MIT\"},\"src/game/interface/UsingStratagemsErrors.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsTypes.sol\\\";\\n\\ninterface UsingStratagemsErrors is UsingStratagemsTypes {\\n    /// @notice Game has not started yet, can't perform any action\\n    error GameNotStarted();\\n\\n    /// @notice When in Reveal phase, it is not possible to commit new moves or cancel previous commitment\\n    ///  During Reveal phase, players have to reveal their commitment, if not already done.\\n    error InRevealPhase();\\n\\n    /// @notice When in Commit phase, player can make new commitment but they cannot reveal their move yet.\\n    error InCommitmentPhase();\\n\\n    /// @notice Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\\\\\n    ///  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\\\\\n    /// @notice If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\\\\\n    error PreviousCommitmentNotRevealed();\\n\\n    /// @notice to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve\\n    ///  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase.\\n    /// @param inReserve amount in reserver as the time of the call\\n    /// @param expected amount required to proceed\\n    error ReserveTooLow(uint256 inReserve, uint256 expected);\\n\\n    /// @notice Player have to reveal their commitment using the exact same move values\\n    ///  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal.\\n    error CommitmentHashNotMatching();\\n\\n    /// @notice Player can only reveal moves they commited.\\n    error NothingToReveal();\\n\\n    /// @notice Player can only reveal their move in the same epoch they commited.abi\\n    ///  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`\\n    error InvalidEpoch();\\n\\n    /// @notice Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves\\n    ///  This result in a recursive series of hash that they can then submit in turn while revealing.\\n    ///  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block.\\n    error InvalidFurtherMoves();\\n\\n    /// @notice Player have to reveal if they can\\n    /// Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal.\\n    error CanStillReveal();\\n\\n    /// @notice The cell configuration is invalid\\n    /// This can happen win debug mode where admin can setup cell bypassing moves rules\\n    /// For example when setting up neighborood configuration that would require a cell to have negative life\\n    error ImpossibleConfiguration();\\n}\\n\",\"keccak256\":\"0xcaf7c446262b2232597af7ed62d040eea9b5c54fb3db20591b80ac96f341ad17\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsEvents.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsTypes.sol\\\";\\n\\ninterface UsingStratagemsEvents is UsingStratagemsTypes {\\n    /// @notice A player has commited to make a move and reveal it on the reveal phase\\n    /// @param player account taking the staking risk (can be a different account than the one controlling the gems)\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param commitmentHash the hash of moves\\n    event CommitmentMade(address indexed player, uint24 indexed epoch, bytes24 commitmentHash);\\n\\n    /// @notice A player has cancelled its current commitment (before it reached the reveal phase)\\n    /// @param player account taking the staking risk (can be a different account than the one controlling the gems)\\n    /// @param epoch epoch number on which this commit belongs to\\n    event CommitmentCancelled(address indexed player, uint24 indexed epoch);\\n\\n    /// @notice A player has canceled a previous commitment by burning some tokens\\n    /// @param player the account that made the commitment\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param amountBurnt amount of token to burn\\n    /// @param furtherMoves hash of further moves, unless bytes32(0) which indicate end.\\n    event CommitmentVoid(address indexed player, uint24 indexed epoch, uint256 amountBurnt, bytes24 furtherMoves);\\n\\n    /// @notice Player has revealed its previous commitment\\n    /// @param player account who commited\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param commitmentHash the hash of the moves\\n    /// @param moves the moves\\n    /// @param furtherMoves hash of further moves, unless bytes32(0) which indicate end.\\n    /// @param newReserveAmount new amount in reserve as a result\\n    event CommitmentRevealed(\\n        address indexed player,\\n        uint24 indexed epoch,\\n        bytes24 indexed commitmentHash,\\n        Move[] moves,\\n        bytes24 furtherMoves,\\n        uint256 newReserveAmount\\n    );\\n\\n    /// @notice poke cell and update it if needed\\n    /// @param position cell to poke\\n    /// @param epoch epoch number at which the poke take place\\n    event SinglePoke(uint24 indexed epoch, uint64 position);\\n\\n    /// @notice poke multiple cells and update them if needed\\n    /// @param positions cells to poke\\n    /// @param epoch epoch number at which the poke take place\\n    event MultiPoke(uint24 indexed epoch, uint64[] positions);\\n\\n    /// @notice Player have withdrawn token from the reserve\\n    /// @param player account withdrawing the tokens\\n    /// @param amountWithdrawn the number of tokens withdrawnn\\n    /// @param newAmount the number of tokens in reserver as a result\\n    event ReserveWithdrawn(address indexed player, uint256 amountWithdrawn, uint256 newAmount);\\n\\n    /// @notice Player has deposited token in the reserve, allowing it to use that much in game\\n    /// @param player account receiving the token in the reserve\\n    /// @param amountDeposited the number of tokens deposited\\n    /// @param newAmount the number of tokens in reserver as a result\\n    event ReserveDeposited(address indexed player, uint256 amountDeposited, uint256 newAmount);\\n\\n    // --------------------------------------------------------------------------------------------\\n    // Event to make it easier to check what is happening\\n    // TODO get rid ?\\n    // --------------------------------------------------------------------------------------------\\n    /// @notice A move has been revealed.\\n    /// @param position cell at which the move take place\\n    /// @param player account making the move\\n    /// @param oldColor previous color of the cell\\n    /// @param newColor color that takes over\\n    event MoveProcessed(uint64 indexed position, address indexed player, Color oldColor, Color newColor);\\n}\\n\",\"keccak256\":\"0xb015b6b04349cd51c8d07426e29d1799be6b0a4aa4672da8156feb5e5a6614e4\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsTypes.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC20/ERC2612/interfaces/IERC20WithIERC2612.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/debug/time/interfaces/ITime.sol\\\";\\nimport \\\"../../token/interface/IOnStakeChange.sol\\\";\\n\\ninterface UsingStratagemsTypes {\\n    // --------------------------------------------------------------------------------------------\\n    // EXTERNAL TYPES\\n    // --------------------------------------------------------------------------------------------\\n\\n    /// @notice The set of possible color (None indicate the Cell is empty)\\n    enum Color {\\n        None,\\n        Blue,\\n        Red,\\n        Green,\\n        Yellow,\\n        Purple,\\n        Evil\\n    }\\n\\n    /// @notice Move struct that define position and color\\n    struct Move {\\n        uint64 position; // TODO make it bigger ? uint32 * uint32 is probably infinitely big enough\\n        Color color;\\n    }\\n\\n    /// @notice Permit struct to authorize EIP2612 ERC20 contracts\\n    struct Permit {\\n        uint256 value;\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Config struct to configure the game instance\\n    struct Config {\\n        IERC20WithIERC2612 tokens;\\n        address payable burnAddress;\\n        uint256 startTime;\\n        uint256 commitPhaseDuration;\\n        uint256 revealPhaseDuration;\\n        uint8 maxLife;\\n        uint256 numTokensPerGems;\\n        ITime time;\\n        IOnStakeChange generator;\\n    }\\n\\n    /// @notice Cell struct representing the current state of a cell\\n    struct FullCell {\\n        address owner;\\n        uint24 lastEpochUpdate;\\n        uint24 epochWhenTokenIsAdded;\\n        uint24 producingEpochs;\\n        Color color;\\n        uint8 life;\\n        int8 delta;\\n        uint8 enemyMap;\\n        uint8 distribution;\\n        uint8 stake; // for Evil, else always 1\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // STORAGE TYPES\\n    // --------------------------------------------------------------------------------------------\\n\\n    struct Discovered {\\n        uint32 minX;\\n        uint32 maxX;\\n        uint32 minY;\\n        uint32 maxY;\\n    }\\n\\n    struct Cell {\\n        uint24 lastEpochUpdate;\\n        uint24 epochWhenTokenIsAdded;\\n        uint24 producingEpochs;\\n        Color color;\\n        uint8 life;\\n        int8 delta;\\n        uint8 enemyMap;\\n        uint8 distribution; // this encode who is left to be given reward (4 left most bits) and the reard (4 most right bits)\\n        uint8 stake; // for Evil, else always 1\\n    }\\n\\n    struct Commitment {\\n        bytes24 hash;\\n        uint24 epoch;\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // INTERNAL TYPES\\n    // --------------------------------------------------------------------------------------------\\n\\n    struct TokenTransfer {\\n        address payable to;\\n        uint256 amount;\\n    }\\n\\n    struct TokenTransferCollection {\\n        TokenTransfer[] transfers;\\n        uint256 numTransfers;\\n    }\\n\\n    struct MoveTokens {\\n        uint256 tokensPlaced;\\n        uint256 tokensBurnt;\\n        uint256 tokensReturned;\\n    }\\n\\n    struct DisplayData {\\n        string x;\\n        string y;\\n        string life;\\n        string delta;\\n        string creationEpoch;\\n        string factionName;\\n        string factionColor;\\n    }\\n}\\n\",\"keccak256\":\"0xfeb72ac403a20acbd460e4fa32b5bf71e11dd2fed8608a5211db0dfa1d73ed69\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsSetters.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsState.sol\\\";\\nimport \\\"../interface/UsingStratagemsEvents.sol\\\";\\nimport \\\"./UsingStratagemsUtils.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Events.sol\\\";\\n\\nabstract contract UsingStratagemsSetters is UsingStratagemsState, UsingStratagemsUtils, UsingERC721Events {\\n    using PositionUtils for uint64;\\n\\n    constructor(Config memory config) UsingStratagemsState(config) {}\\n\\n    function _makeCommitment(address player, bytes24 commitmentHash, uint256 inReserve) internal {\\n        Commitment storage commitment = _commitments[player];\\n\\n        (uint24 epoch, bool commiting) = _epoch();\\n\\n        if (!commiting) {\\n            revert InRevealPhase();\\n        }\\n        if (commitment.epoch != 0 && commitment.epoch != epoch) {\\n            revert PreviousCommitmentNotRevealed();\\n        }\\n\\n        commitment.hash = commitmentHash;\\n        commitment.epoch = epoch;\\n\\n        // for withdrawal, we still require a minimal reserve so player cannot change their mind without losing at least one token\\n        // TODO we might want to increase that value to 10x as 10 moves might quite common, at least on some networks\\n        if (inReserve < NUM_TOKENS_PER_GEMS) {\\n            // TODO? special error for this case ?\\n            revert ReserveTooLow(inReserve, NUM_TOKENS_PER_GEMS);\\n        }\\n\\n        emit CommitmentMade(player, epoch, commitmentHash);\\n    }\\n\\n    function _resolveMoves(\\n        address player,\\n        uint24 epoch,\\n        Move[] memory moves,\\n        address tokenGiver\\n    ) internal returns (uint256 newReserveAmount) {\\n        // max number of transfer is (4+1) * moves.length\\n        // (for each move's cell's neighbours potentially being a different account)\\n        // limiting the number of move per commitment reveal to 32 or, even more probably, should cover this unlikely scenario\\n        TokenTransferCollection memory transferCollection = TokenTransferCollection({\\n            transfers: new TokenTransfer[](moves.length * 5),\\n            numTransfers: 0\\n        });\\n        MoveTokens memory tokens;\\n        for (uint256 i = 0; i < moves.length; i++) {\\n            (uint256 placed, uint256 burnt, uint256 returned) = _computeMove(\\n                transferCollection,\\n                player,\\n                epoch,\\n                moves[i]\\n            );\\n\\n            tokens.tokensPlaced += placed;\\n            tokens.tokensBurnt += burnt;\\n            tokens.tokensReturned += returned;\\n        }\\n\\n        // logger.logTransfers(0, \\\"resolveMoves\\\", transferCollection);\\n\\n        newReserveAmount = _tokensInReserve[player];\\n\\n        // Note: even if funds can comes from outside the reserve, we still check it\\n        // This ensure player have to have a reserve and cannot escape the slash if not\\n        if (newReserveAmount < tokens.tokensPlaced + tokens.tokensBurnt) {\\n            revert ReserveTooLow(newReserveAmount, tokens.tokensPlaced + tokens.tokensBurnt);\\n        }\\n        if (tokenGiver == address(0)) {\\n            newReserveAmount -= tokens.tokensPlaced + tokens.tokensBurnt;\\n            _tokensInReserve[player] = newReserveAmount;\\n        } else {\\n            if (tokens.tokensPlaced != 0) {\\n                TOKENS.transferFrom(tokenGiver, address(this), tokens.tokensPlaced);\\n            }\\n            if (tokens.tokensBurnt != 0) {\\n                TOKENS.transferFrom(tokenGiver, BURN_ADDRESS, tokens.tokensBurnt);\\n            }\\n        }\\n\\n        // TODO option to return in reserve ?\\n        if (tokens.tokensReturned != 0) {\\n            // console.log(\\\"tokensReturned\\\");\\n            // console.log(tokens.tokensReturned);\\n            _collectTransfer(transferCollection, TokenTransfer({to: payable(player), amount: tokens.tokensReturned}));\\n        }\\n\\n        _multiTransfer(TOKENS, transferCollection);\\n    }\\n\\n    function _countBits(uint8 n) internal pure returns (uint8 count) {\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n    }\\n\\n    function _placeColor(\\n        address player,\\n        Cell memory currentState,\\n        Move memory move,\\n        uint24 epoch,\\n        int8 newDelta,\\n        uint8 newEnemyMap\\n    ) internal {\\n        // WE do not need this as land cannot be placed on existing one\\n        // {\\n        //     // why do we need to do this on placeColor ?\\n        //     int8 oldEffectiveDelta = _effectiveDelta(currentState.delta, currentState.enemyMap);\\n        //     int8 newEffectiveDelta = _effectiveDelta(newDelta, newEnemyMap);\\n        //     if (oldEffectiveDelta > 0 && newEffectiveDelta <= 0) {\\n        //         GENERATOR.remove(player, NUM_TOKENS_PER_GEMS);\\n        //     } else if (oldEffectiveDelta <= 0 && newEffectiveDelta > 0) {\\n        //         GENERATOR.add(player, NUM_TOKENS_PER_GEMS);\\n        //     }\\n        //     if (oldEffectiveDelta > 0) {\\n        //         currentState.producingEpochs += epoch - currentState.lastEpochUpdate;\\n        //     }\\n        // }\\n\\n        currentState.enemyMap = newEnemyMap;\\n\\n        if (currentState.color == Color.Evil && currentState.life != 0) {\\n            unchecked {\\n                currentState.stake += 1;\\n                if (currentState.stake == 0) {\\n                    // we cap it, losing stake there\\n                    // TODO reevaluate\\n                    // send it to special address ?\\n                    currentState.stake = 255;\\n                }\\n            }\\n        } else {\\n            currentState.stake = 1;\\n            currentState.producingEpochs = 0;\\n        }\\n\\n        currentState.delta = newDelta;\\n        currentState.life = 2;\\n        currentState.lastEpochUpdate = epoch;\\n\\n        address oldOwner = _ownerOf(move.position);\\n\\n        int8 newEffectiveDelta = _effectiveDelta(currentState.delta, currentState.enemyMap);\\n\\n        if (currentState.color == Color.Evil) {\\n            if (oldOwner != 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF) {\\n                if (newEffectiveDelta > 0) {\\n                    if (oldOwner == address(0)) {\\n                        GENERATOR.add(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, NUM_TOKENS_PER_GEMS);\\n                    } else {\\n                        GENERATOR.remove(oldOwner, NUM_TOKENS_PER_GEMS);\\n                        GENERATOR.add(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, NUM_TOKENS_PER_GEMS * 2);\\n                    }\\n                }\\n                emit Transfer(oldOwner, 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, move.position);\\n                _owners[move.position] = uint256(uint160(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\\n            } else {\\n                GENERATOR.add(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, NUM_TOKENS_PER_GEMS);\\n            }\\n        } else {\\n            if (newEffectiveDelta > 0) {\\n                GENERATOR.add(player, NUM_TOKENS_PER_GEMS);\\n            }\\n            emit Transfer(address(0), player, move.position);\\n            _owners[move.position] = uint256(uint160(player));\\n        }\\n    }\\n\\n    // Note on COLLISION\\n    // If one color was used more than other, we could consider the cell having N owner and N times the number of tokens\\n    // such cells would be a good target for others\\n    // On the other end, on winning agains other cells, owner of such cell would have to divide the winnings\\n    // TODO revisit this\\n    // we could also refund the part\\n    // so if there is 3 green 2 blue and 1 red, then green win and the cell become green\\n    // player who put blue or red get refunded their respective gems\\n    // the players who put green get refunded 2/3 so that the cell still contains only 1\\n    // if there was 3 green and 3 blue and 1 red then the cell becomes black\\n    // every player get refunded 6/7 so that the black cell only has 1\\n    // note that the issue with green winning above is that winnings need to be distributed to all 3 players who put green\\n    // and since the number is technically unbounded, we have to use a splitter contract where player withdraw their winnings\\n    // this add UX complexity and some cost for withdrawals\\n    // it also remove the ability to transfer the cell unless agreement and implementation for this\\n    // So the conclusion is to make it black in all cases and keep the amount\\n    function _computeMove(\\n        TokenTransferCollection memory transferCollection,\\n        address player,\\n        uint24 epoch,\\n        Move memory move\\n    ) internal returns (uint256 tokensPlaced, uint256 tokensBurnt, uint256 tokensReturned) {\\n        (Cell memory currentState, bool justDied) = _getUpdatedCell(move.position, epoch);\\n\\n        // logger.logPosition(\\\"move\\\", move.position);\\n        // logger.logCell(0, string.concat(\\\"_computeMove at epoch \\\", Strings.toString(epoch)), move.position, currentState, address(uint160(_owners[move.position])));\\n\\n        // we might have distribution still to do\\n        uint8 distribution = currentState.distribution;\\n        if (justDied) {\\n            // if we just died\\n            // we have to distribute to all\\n            distribution = (currentState.enemyMap << 4) + _countBits(currentState.enemyMap);\\n\\n            /// we are now dead for real\\n            currentState.lastEpochUpdate = 0;\\n        }\\n\\n        // we then apply our move:\\n\\n        // first we do some validity checks\\n        if (move.color == Color.None) {\\n            if (currentState.life != MAX_LIFE || _ownerOf(move.position) != player) {\\n                // invalid move\\n                return (0, 0, NUM_TOKENS_PER_GEMS);\\n            }\\n\\n            _collectTransfer(transferCollection, TokenTransfer({to: payable(player), amount: NUM_TOKENS_PER_GEMS}));\\n        }\\n        // then we consider the case of collision and transform such move as Color Evil\\n        else if (currentState.epochWhenTokenIsAdded == epoch) {\\n            if (currentState.life != 0) {\\n                move.color = Color.Evil;\\n            } else {\\n                if (currentState.life != MAX_LIFE || _ownerOf(move.position) != player) {\\n                    // invalid move\\n                    return (0, 0, NUM_TOKENS_PER_GEMS);\\n                }\\n            }\\n            // we keep currentState.epochWhenTokenIsAdded as we do not want to be overwritten by conflcit: black\\n        }\\n        emit MoveProcessed(move.position, player, currentState.color, move.color);\\n\\n        return _completeMove(transferCollection, player, epoch, move, currentState, distribution);\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER \\\", Strings.toString(epoch)),move.position,currentState,address(uint160(_owners[move.position])));\\n    }\\n\\n    function _completeMove(\\n        TokenTransferCollection memory transferCollection,\\n        address player,\\n        uint24 epoch,\\n        Move memory move,\\n        Cell memory currentState,\\n        uint8 distribution\\n    ) internal returns (uint256 tokensPlaced, uint256 tokensBurnt, uint256 tokensReturned) {\\n        unchecked {\\n            // this is not so much newDelta than delta\\n            (int8 newDelta, uint8 newEnemyMap) = _propagate(\\n                transferCollection,\\n                move,\\n                epoch,\\n                currentState.color,\\n                distribution,\\n                currentState.stake\\n            );\\n\\n            currentState.color = move.color;\\n            currentState.distribution = 0;\\n            if (!(_ownerOf(move.position) == player && currentState.life > 0)) {\\n                // we do not reset \\\"epochWhenTokenIsAdded\\\" when same player\\n                // this prevent other player to place color while it replace color\\n                currentState.epochWhenTokenIsAdded = epoch; // used to prevent overwriting, even Color.None\\n            }\\n\\n            if (currentState.color == Color.None) {\\n                currentState.producingEpochs += epoch - currentState.lastEpochUpdate;\\n                currentState.life = 0;\\n                currentState.stake = 0;\\n                currentState.lastEpochUpdate = 0;\\n                currentState.delta = 0;\\n                currentState.enemyMap = 0;\\n                emit Transfer(_ownerOf(move.position), address(0), move.position);\\n                _owners[move.position] = 0;\\n                tokensReturned = NUM_TOKENS_PER_GEMS;\\n                GENERATOR.remove(player, NUM_TOKENS_PER_GEMS);\\n            } else {\\n                tokensPlaced = NUM_TOKENS_PER_GEMS;\\n\\n                _placeColor(player, currentState, move, epoch, newDelta, newEnemyMap);\\n            }\\n\\n            _cells[move.position] = currentState;\\n        }\\n    }\\n\\n    // this can work like in conquest as even though the world works in epoch\\n    //  we do not mind if a player could use another play moves to go further\\n    //  they would just need to ensure their reveal is in order\\n    //  In practise though player would not need this as the discovery gap should be big enough\\n    // But an alternative to tracking the 4 discovery point, would be to ask player to provide land position\\n    //  for the 4 direction. THey could also provide only one position for all 4 if that is enough\\n    // NOTE: would need to set initial discovery:\\n    // `_discovered = Discovered({\\n    //         minX: _initialSpaceExpansion,\\n    //         maxX: _initialSpaceExpansion,\\n    //         minY: _initialSpaceExpansion,\\n    //         maxY: _initialSpaceExpansion\\n    //     });\\n    //     emit Initialized(\\n    //         _initialSpaceExpansion,\\n    //     );`\\n    // // solhint-disable-next-line code-complexity\\n    // function _setDiscoveryAfterStaking(uint256 location) internal returns (bool invalid) {\\n    //     Discovered memory discovered = _discovered;\\n    //     uint32 _expansionDelta = 12;\\n\\n    //     (int32 x32, int32 y32) = PositionUtils.toXY(uint64(location));\\n    //     int256 x = (int40(x32));\\n    //     int256 y = (int40(y32));\\n\\n    //     int40 UINT32_MAX = 0xffffffff;\\n\\n    //     bool changes = false;\\n    //     if (x < 0) {\\n    //         if (-x > int256(uint256(discovered.minX))) {\\n    //             return false;\\n    //         }\\n    //         x = -x + int32(_expansionDelta);\\n    //         if (x > UINT32_MAX) {\\n    //             x = UINT32_MAX;\\n    //         }\\n    //         if (int256(uint256(discovered.minX)) < x) {\\n    //             discovered.minX = uint32(uint256(x));\\n    //             changes = true;\\n    //         }\\n    //     } else {\\n    //         if (x > int256(uint256(discovered.maxX))) {\\n    //             return false;\\n    //         }\\n    //         x = x + int32(_expansionDelta);\\n    //         if (x > UINT32_MAX) {\\n    //             x = UINT32_MAX;\\n    //         }\\n    //         if (discovered.maxX < uint32(uint256(x))) {\\n    //             discovered.maxX = uint32(uint256(x));\\n    //             changes = true;\\n    //         }\\n    //     }\\n\\n    //     if (y < 0) {\\n    //         if (-y > int256(uint256(discovered.minY))) {\\n    //             return false;\\n    //         }\\n    //         y = -y + int32(_expansionDelta);\\n    //         if (y > UINT32_MAX) {\\n    //             y = UINT32_MAX;\\n    //         }\\n    //         if (int256(uint256(discovered.minY)) < y) {\\n    //             discovered.minY = uint32(uint256(y));\\n    //             changes = true;\\n    //         }\\n    //     } else {\\n    //         if (y > int256(uint256(discovered.maxY))) {\\n    //             return false;\\n    //         }\\n    //         y = y + int32(_expansionDelta);\\n    //         if (y > UINT32_MAX) {\\n    //             y = UINT32_MAX;\\n    //         }\\n    //         if (int256(uint256(discovered.maxY)) < y) {\\n    //             discovered.maxY = uint32(uint256(y));\\n    //             changes = true;\\n    //         }\\n    //     }\\n    //     if (changes) {\\n    //         _discovered = discovered;\\n    //     }\\n    // }\\n\\n    function _propagate(\\n        TokenTransferCollection memory transferCollection,\\n        Move memory move,\\n        uint24 epoch,\\n        Color color,\\n        uint8 distribution,\\n        uint8 stake\\n    ) internal returns (int8 newDelta, uint8 newEnemyMap) {\\n        (\\n            int8 newComputedDelta,\\n            uint8 newComputedEnemyMap,\\n            uint16 numDue,\\n            address[4] memory ownersToPay\\n        ) = _updateNeighbours(move.position, epoch, color, move.color, distribution);\\n\\n        if (numDue > 0) {\\n            _collectTransfer(\\n                transferCollection,\\n                TokenTransfer({to: payable(_ownerOf(move.position)), amount: (numDue * NUM_TOKENS_PER_GEMS) / 12})\\n            );\\n        }\\n        for (uint8 i = 0; i < 4; i++) {\\n            if (ownersToPay[i] != address(0)) {\\n                _collectTransfer(\\n                    transferCollection,\\n                    TokenTransfer({\\n                        to: payable(ownersToPay[i]),\\n                        amount: stake * (NUM_TOKENS_PER_GEMS / (distribution & 0x0f))\\n                    })\\n                );\\n            }\\n        }\\n        newDelta = newComputedDelta;\\n        newEnemyMap = newComputedEnemyMap;\\n    }\\n\\n    function _poke(TokenTransferCollection memory transferCollection, uint64 position, uint24 epoch) internal {\\n        (Cell memory currentState, bool justDied) = _getUpdatedCell(position, epoch);\\n\\n        // logger.logCell(0,string.concat(\\\"_poke at epoch \\\", Strings.toString(epoch)),position,currentState,address(uint160(_owners[position])));\\n\\n        // we might have distribution still to do\\n        uint8 distribution = currentState.distribution;\\n        if (justDied) {\\n            // if we just died\\n            // we have to distribute to all\\n            distribution = (currentState.enemyMap << 4) + _countBits(currentState.enemyMap);\\n\\n            /// we are now dead for real\\n            currentState.lastEpochUpdate = 0;\\n        }\\n\\n        (, , uint16 numDue, address[4] memory ownersToPay) = _updateNeighbours(\\n            position,\\n            epoch,\\n            currentState.color,\\n            currentState.color,\\n            distribution\\n        );\\n\\n        if (numDue > 0) {\\n            _collectTransfer(\\n                transferCollection,\\n                TokenTransfer({to: payable(_ownerOf(position)), amount: (numDue * NUM_TOKENS_PER_GEMS) / 12})\\n            );\\n        }\\n        for (uint8 i = 0; i < 4; i++) {\\n            if (ownersToPay[i] != address(0)) {\\n                _collectTransfer(\\n                    transferCollection,\\n                    TokenTransfer({\\n                        to: payable(ownersToPay[i]),\\n                        amount: currentState.stake * (NUM_TOKENS_PER_GEMS / (distribution & 0x0f))\\n                    })\\n                );\\n            }\\n        }\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER poke (before zeroed distribution) at epoch \\\", Strings.toString(epoch)),position,currentState,address(uint160(_owners[position])));\\n\\n        currentState.distribution = 0;\\n        _cells[position] = currentState;\\n    }\\n\\n    struct CellUpdate {\\n        int8 delta;\\n        uint8 enemymap;\\n        uint16 due;\\n    }\\n    function _updateUP(\\n        address[4] memory ownersToPay,\\n        CellUpdate memory cellUpdate,\\n        uint64 position,\\n        uint24 epoch,\\n        uint8 distribution,\\n        Color oldColor,\\n        Color newColor\\n    ) internal {\\n        uint64 upPosition = position.offset(0, -1);\\n        (int8 enemyOrFriend, uint16 due) = _updateCell(\\n            CellUpdateData({\\n                position: upPosition,\\n                epoch: epoch,\\n                neighbourIndex: 2,\\n                oldColor: oldColor,\\n                newColor: newColor\\n            })\\n        );\\n        if (enemyOrFriend < 0) {\\n            cellUpdate.enemymap = cellUpdate.enemymap | 1;\\n        }\\n        cellUpdate.due += due;\\n        cellUpdate.delta += enemyOrFriend;\\n\\n        if ((distribution >> 4) & 1 == 1) {\\n            ownersToPay[0] = _ownerOf(upPosition);\\n        }\\n    }\\n    function _updateLEFT(\\n        address[4] memory ownersToPay,\\n        CellUpdate memory cellUpdate,\\n        uint64 position,\\n        uint24 epoch,\\n        uint8 distribution,\\n        Color oldColor,\\n        Color newColor\\n    ) internal {\\n        uint64 leftPosition = position.offset(-1, 0);\\n        (int8 enemyOrFriend, uint16 due) = _updateCell(\\n            CellUpdateData({\\n                position: leftPosition,\\n                epoch: epoch,\\n                neighbourIndex: 3,\\n                oldColor: oldColor,\\n                newColor: newColor\\n            })\\n        );\\n        if (enemyOrFriend < 0) {\\n            cellUpdate.enemymap = cellUpdate.enemymap | 2;\\n        }\\n        cellUpdate.due += due;\\n        cellUpdate.delta += enemyOrFriend;\\n\\n        if ((distribution >> 4) & 2 == 2) {\\n            ownersToPay[1] = _ownerOf(leftPosition);\\n        }\\n    }\\n\\n    function _updateDOWN(\\n        address[4] memory ownersToPay,\\n        CellUpdate memory cellUpdate,\\n        uint64 position,\\n        uint24 epoch,\\n        uint8 distribution,\\n        Color oldColor,\\n        Color newColor\\n    ) internal {\\n        uint64 downPosition = position.offset(0, 1);\\n        (int8 enemyOrFriend, uint16 due) = _updateCell(\\n            CellUpdateData({\\n                position: downPosition,\\n                epoch: epoch,\\n                neighbourIndex: 0,\\n                oldColor: oldColor,\\n                newColor: newColor\\n            })\\n        );\\n        if (enemyOrFriend < 0) {\\n            cellUpdate.enemymap = cellUpdate.enemymap | 4;\\n        }\\n        cellUpdate.due += due;\\n        cellUpdate.delta += enemyOrFriend;\\n\\n        if ((distribution >> 4) & 4 == 4) {\\n            ownersToPay[2] = _ownerOf(downPosition);\\n        }\\n    }\\n\\n    function _updateRIGHT(\\n        address[4] memory ownersToPay,\\n        CellUpdate memory cellUpdate,\\n        uint64 position,\\n        uint24 epoch,\\n        uint8 distribution,\\n        Color oldColor,\\n        Color newColor\\n    ) internal {\\n        uint64 rightPosition = position.offset(1, 0);\\n        (int8 enemyOrFriend, uint16 due) = _updateCell(\\n            CellUpdateData({\\n                position: rightPosition,\\n                epoch: epoch,\\n                neighbourIndex: 1,\\n                oldColor: oldColor,\\n                newColor: newColor\\n            })\\n        );\\n        if (enemyOrFriend < 0) {\\n            cellUpdate.enemymap = cellUpdate.enemymap | 8;\\n        }\\n        cellUpdate.due += due;\\n        cellUpdate.delta += enemyOrFriend;\\n\\n        if ((distribution >> 4) & 8 == 8) {\\n            ownersToPay[3] = _ownerOf(rightPosition);\\n        }\\n    }\\n\\n    function _updateNeighbours(\\n        uint64 position,\\n        uint24 epoch,\\n        Color oldColor,\\n        Color newColor,\\n        uint8 distribution\\n    ) internal returns (int8 newDelta, uint8 newEnemyMap, uint16 numDue, address[4] memory ownersToPay) {\\n        CellUpdate memory cellUpdate;\\n        _updateUP(ownersToPay, cellUpdate, position, epoch, distribution, oldColor, newColor);\\n        _updateLEFT(ownersToPay, cellUpdate, position, epoch, distribution, oldColor, newColor);\\n        _updateDOWN(ownersToPay, cellUpdate, position, epoch, distribution, oldColor, newColor);\\n        _updateRIGHT(ownersToPay, cellUpdate, position, epoch, distribution, oldColor, newColor);\\n        newDelta = cellUpdate.delta;\\n        newEnemyMap = cellUpdate.enemymap;\\n        numDue = cellUpdate.due;\\n    }\\n\\n    struct CellUpdateData {\\n        uint64 position; // position to update\\n        uint24 epoch;\\n        uint8 neighbourIndex; // index from point of view of cell being updated\\n        Color oldColor; // old Color of the neighbor\\n        Color newColor; // new color of the neighbor\\n    }\\n    /// @dev This update the cell in storage\\n    function _updateCell(CellUpdateData memory data) internal returns (int8 enemyOrFriend, uint16 due) {\\n        Cell memory cell = _cells[data.position];\\n\\n        uint24 lastUpdate = cell.lastEpochUpdate;\\n        Color color = cell.color;\\n        if (color != Color.None) {\\n            // if the color of the cell being update is not Nome\\n            // we then check the neighbor new color\\n            // if it same as the cell color, then we report the cell as friendly to the neighbor\\n            // else it is an enemy\\n            // note that _updateCell should only be called if oldColor != newColor\\n            enemyOrFriend = color == data.newColor ? int8(1) : int8(-1);\\n        }\\n        if (lastUpdate >= 1 && color != Color.None) {\\n            // we only consider cell with color that are not dead\\n            if (cell.life > 0 && lastUpdate < data.epoch) {\\n                // of there is life to update we compute the new life\\n                (uint8 newLife, ) = _computeNewLife(lastUpdate, cell.enemyMap, cell.delta, cell.life, data.epoch);\\n                due = _updateCellFromNeighbor(data, cell, newLife);\\n            } else {\\n                due = _updateCellFromNeighbor(data, cell, cell.life);\\n            }\\n        }\\n    }\\n\\n    function _updateCellFromNeighbor(\\n        CellUpdateData memory data,\\n        Cell memory cell, // cell to be updated\\n        uint8 newLife // new life value for the cell\\n    ) internal returns (uint16 due) {\\n        if (cell.life > 0 && newLife == 0) {\\n            // we just died, we establish the distributionMap and counts\\n            // logger.logPosition(\\\"new distribution\\\", position);\\n            cell.distribution = (cell.enemyMap << 4) + _countBits(cell.enemyMap);\\n            // console.log(\\\"%i %i\\\", cell.distribution >> 4, cell.distribution & 0x0F);\\n        }\\n\\n        // logger.logCell(0,string.concat(\\\"_updateCellFromNeighbor  index\\\", Strings.toString(neighbourIndex)),position,cell,address(uint160(_owners[position])));\\n\\n        if ((cell.distribution >> 4) & (2 ** data.neighbourIndex) == 2 ** data.neighbourIndex) {\\n            due = (cell.stake * 12) / (cell.distribution & 0x0f); // TODO if stake too high we have a problem\\n\\n            cell.distribution =\\n                (uint8(uint256(cell.distribution >> 4) & (~(2 ** uint256(data.neighbourIndex)))) << 4) +\\n                (cell.distribution & 0x0f);\\n        }\\n\\n        int8 oldEffectiveDelta = _effectiveDelta(cell.delta, cell.enemyMap);\\n\\n        _handleColor(cell, data.neighbourIndex, data.oldColor, data.newColor);\\n\\n        _setCell(data.position, cell, newLife, data.epoch, oldEffectiveDelta);\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER _updateCellFromNeighbor  index\\\", Strings.toString(neighbourIndex)),position,cell,address(uint160(_owners[position])));\\n\\n        _cells[data.position] = cell;\\n    }\\n\\n    function _setCell(\\n        uint64 position, // position of the cell to be updated\\n        Cell memory cell, // cell to be updated\\n        uint8 newLife, // new life value for the celll\\n        uint24 epoch, // epoch at which the update occured (epochUsed TODO: confirm its use)\\n        int8 oldEffectiveDelta\\n    ) internal {\\n        address owner = _ownerOf(position);\\n        if (owner != address(0)) {\\n            int8 newEffectiveDelta = _effectiveDelta(cell.delta, cell.enemyMap);\\n            if (oldEffectiveDelta > 0 && newEffectiveDelta <= 0) {\\n                GENERATOR.remove(owner, NUM_TOKENS_PER_GEMS * cell.stake);\\n            } else if (oldEffectiveDelta <= 0 && newEffectiveDelta > 0) {\\n                GENERATOR.add(owner, NUM_TOKENS_PER_GEMS * cell.stake);\\n            }\\n        }\\n\\n        if (oldEffectiveDelta > 0) {\\n            cell.producingEpochs += epoch - cell.lastEpochUpdate;\\n        }\\n\\n        cell.lastEpochUpdate = epoch;\\n        cell.life = newLife;\\n    }\\n\\n    function _handleColor(\\n        Cell memory cell, // cell to be updated\\n        uint8 neighbourIndex, // the neighbor triggering the update and for which we return whether it should receive its due\\n        Color oldColor, // old color of that neighbor\\n        Color newColor // new color of that neighbor\\n    ) internal pure {\\n        if (oldColor != newColor) {\\n            if (newColor == Color.None) {\\n                if (cell.color == oldColor) {\\n                    cell.delta -= 1;\\n                } else {\\n                    cell.delta += 1;\\n                    cell.enemyMap = cell.enemyMap & uint8((1 << neighbourIndex) ^ 0xFF);\\n                }\\n            } else if (cell.color == oldColor) {\\n                // then newColor is different (see assert above)\\n                cell.enemyMap = cell.enemyMap | uint8(1 << neighbourIndex);\\n                cell.delta -= 2;\\n            } else if (cell.color == newColor) {\\n                // then old color was different\\n                cell.delta += (oldColor == Color.None ? int8(1) : int8(2));\\n                cell.enemyMap = cell.enemyMap & uint8((1 << neighbourIndex) ^ 0xFF);\\n            } else if (oldColor == Color.None) {\\n                // if there were no oldCOlor and the newColor is not your (already checked in previous if clause)\\n                cell.delta -= 1;\\n                cell.enemyMap = cell.enemyMap | uint8(1 << neighbourIndex);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaf3db3333d72cac15b1a5167cad2643cd87be1d3e1470d6c30b855eb50873cb\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsState.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsStore.sol\\\";\\nimport \\\"../interface/UsingStratagemsEvents.sol\\\";\\nimport \\\"../interface/UsingStratagemsErrors.sol\\\";\\nimport \\\"./UsingVirtualTime.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\n\\n// TODO use hardhat-preprocessor\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../../utils/StringUtils.sol\\\";\\n\\nlibrary logger {\\n    using PositionUtils for uint64;\\n\\n    address constant CONSOLE_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(staticcall(gas(), consoleAddress, add(payload, 32), mload(payload), 0, 0))\\n        }\\n    }\\n\\n    // _sendLogPayload(abi.encodeWithSignature('log(string,int256,int256)', 'cell %s', x, y));\\n\\n    function logPosition(string memory title, uint64 pos) internal view {\\n        (int32 x, int32 y) = pos.toXY();\\n        console.log(\\\"%s: (%s,%s)\\\", title, StringUtils.toString(x), StringUtils.toString(y));\\n    }\\n\\n    function logCell(\\n        uint8 ii,\\n        string memory title,\\n        uint64 id,\\n        UsingStratagemsTypes.Cell memory cell,\\n        address owner\\n    ) internal view {\\n        string memory indent = ii == 0\\n            ? \\\"\\\"\\n            : ii == 1\\n                ? \\\"    \\\"\\n                : ii == 2\\n                    ? \\\"        \\\"\\n                    : \\\"            \\\";\\n        // string memory indent = '';\\n        console.log(\\\"%s%s\\\", indent, title);\\n        (int32 x, int32 y) = id.toXY();\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        console.log(\\\"%scell (%s,%s)\\\", indent, StringUtils.toString(x), StringUtils.toString(y));\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        console.log(\\\"%s - lastEpochUpdate:  %s\\\", indent, cell.lastEpochUpdate);\\n        console.log(\\\"%s - epochWhenTokenIsAdded:  %s\\\", indent, cell.epochWhenTokenIsAdded);\\n        console.log(\\\"%s - color:  %s\\\", indent, uint8(cell.color));\\n        console.log(\\\"%s - life:  %s\\\", indent, cell.life);\\n        console.log(\\\"%s - distribution:  %s\\\", indent, cell.distribution);\\n        console.log(\\\"%s - owner:  %s\\\", indent, owner);\\n        console.log(\\\"%s - delta: %s\\\", indent, StringUtils.toString(cell.delta));\\n        console.log(\\\"%s - enemyMap:  %s\\\", indent, cell.enemyMap);\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n    }\\n\\n    function logTransfers(\\n        uint8 ii,\\n        string memory title,\\n        UsingStratagemsTypes.TokenTransferCollection memory transferCollection\\n    ) internal pure {\\n        string memory indent = ii == 0\\n            ? \\\"\\\"\\n            : ii == 1\\n                ? \\\"    \\\"\\n                : ii == 2\\n                    ? \\\"        \\\"\\n                    : \\\"            \\\";\\n        // string memory indent = '';\\n        console.log(\\\"%s%s\\\", indent, title);\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        for (uint256 i = 0; i < transferCollection.numTransfers; i++) {\\n            console.log(\\n                \\\"%stransfer (%s,%s)\\\",\\n                indent,\\n                transferCollection.transfers[i].to,\\n                StringUtils.toString(transferCollection.transfers[i].amount)\\n            );\\n        }\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n    }\\n}\\n\\nabstract contract UsingStratagemsState is\\n    UsingStratagemsStore,\\n    UsingStratagemsEvents,\\n    UsingStratagemsErrors,\\n    UsingVirtualTime\\n{\\n    /// @notice The token used for the game. Each gems on the board contains that token\\n    IERC20WithIERC2612 internal immutable TOKENS;\\n    /// @notice the timestamp (in seconds) at which the game start, it start in the commit phase\\n    uint256 internal immutable START_TIME;\\n    /// @notice the duration of the commit phase in seconds\\n    uint256 internal immutable COMMIT_PHASE_DURATION;\\n    /// @notice the duration of the reveal phase in seconds\\n    uint256 internal immutable REVEAL_PHASE_DURATION;\\n    /// @notice the max number of level a cell can reach in the game\\n    uint8 internal immutable MAX_LIFE;\\n    /// @notice the number of tokens underlying each gems on the board.\\n    uint256 internal immutable NUM_TOKENS_PER_GEMS;\\n    /// @notice the address to send the token to when burning\\n    address payable internal immutable BURN_ADDRESS;\\n    /// @notice the generator that will be called whenever a player stake state change\\n    IOnStakeChange internal immutable GENERATOR;\\n\\n    /// @notice the number of moves a hash represent, after that players make use of furtherMoves\\n    uint8 internal constant MAX_NUM_MOVES_PER_HASH = 32;\\n\\n    /// @notice Create an instance of a Stratagems game\\n    /// @param config configuration options for the game\\n    constructor(Config memory config) UsingVirtualTime(config) {\\n        TOKENS = config.tokens;\\n        BURN_ADDRESS = config.burnAddress;\\n        START_TIME = config.startTime;\\n        COMMIT_PHASE_DURATION = config.commitPhaseDuration;\\n        REVEAL_PHASE_DURATION = config.revealPhaseDuration;\\n        MAX_LIFE = config.maxLife;\\n        NUM_TOKENS_PER_GEMS = config.numTokensPerGems;\\n        GENERATOR = config.generator;\\n    }\\n\\n    function _epoch() internal view virtual returns (uint24 epoch, bool commiting) {\\n        uint256 epochDuration = COMMIT_PHASE_DURATION + REVEAL_PHASE_DURATION;\\n        uint256 time = _timestamp();\\n        if (time < START_TIME) {\\n            revert GameNotStarted();\\n        }\\n        uint256 timePassed = time - START_TIME;\\n        epoch = uint24(timePassed / epochDuration + 2); // epoch start at 2, this make the hypothetical previous reveal phase's epoch to be 1\\n        commiting = timePassed - ((epoch - 2) * epochDuration) < COMMIT_PHASE_DURATION;\\n    }\\n\\n    function _computeNewLife(\\n        uint24 lastUpdate,\\n        uint8 enemyMap,\\n        int8 delta,\\n        uint8 life,\\n        uint24 epoch\\n    ) internal view returns (uint8 newLife, uint24 epochUsed) {\\n        epochUsed = lastUpdate;\\n        if (lastUpdate >= 1 && life > 0) {\\n            uint256 epochDelta = epoch - lastUpdate;\\n            if (epochDelta > 0) {\\n                int8 effectiveDelta = _effectiveDelta(delta, enemyMap);\\n                if (effectiveDelta > 0) {\\n                    // if (life < MAX_LIFE) {\\n                    uint8 maxEpoch = ((MAX_LIFE - life) + uint8(effectiveDelta) - 1) / uint8(effectiveDelta);\\n                    if (epochDelta > maxEpoch) {\\n                        epochDelta = maxEpoch;\\n                    }\\n\\n                    life += uint8(epochDelta) * uint8(effectiveDelta);\\n                    if (life > MAX_LIFE) {\\n                        life = MAX_LIFE;\\n                    }\\n                    newLife = life;\\n\\n                    // we don not use the following: lastUpdate + epochDelta;\\n                    //   because no state change is foreseen with no life increase\\n                    epochUsed = epoch;\\n                    // } else {\\n                    // \\tnewLife = life;\\n                    // \\tepochUsed = lastUpdate;\\n                    // }\\n                } else if (effectiveDelta < 0) {\\n                    uint8 numEpochBeforeDying = (life + uint8(-effectiveDelta) - 1) / uint8(-effectiveDelta);\\n                    if (epochDelta > numEpochBeforeDying) {\\n                        epochDelta = numEpochBeforeDying;\\n                    }\\n                    uint8 lifeLoss = uint8(epochDelta) * uint8(-effectiveDelta);\\n                    if (lifeLoss > life) {\\n                        newLife = 0;\\n                    } else {\\n                        newLife = life - lifeLoss;\\n                    }\\n\\n                    // since we need to track when the cell died, we upate lastUpdate only to\\n                    //   the corresponding epoch where life reached 0\\n                    epochUsed = lastUpdate + uint24(epochDelta);\\n                } else {\\n                    newLife = life;\\n\\n                    // we don not use the following: lastUpdate + epochDelta;\\n                    //   because no state change is foreseen with no life change\\n                    epochUsed = epoch;\\n                }\\n            } else {\\n                newLife = life;\\n\\n                // no change, no need to update lastUpdate either ?\\n                epochUsed = lastUpdate;\\n            }\\n        }\\n    }\\n\\n    function _effectiveDelta(int8 delta, uint8 enemyMap) internal pure returns (int8 effectiveDelta) {\\n        // effectiveDelta = delta != 0 ? delta : -1;\\n        effectiveDelta = delta > 0 ? int8(1) : -1;\\n        if (effectiveDelta < 0 && enemyMap == 0) {\\n            effectiveDelta = int8(1);\\n            // effectiveDelta = int8(0);\\n        }\\n    }\\n\\n    function _getUpdatedCell(\\n        uint64 position,\\n        uint24 epoch\\n    ) internal view returns (Cell memory updatedCell, bool justDied) {\\n        // load from state\\n        updatedCell = _cells[position];\\n        uint24 lastUpdate = updatedCell.lastEpochUpdate;\\n        int8 delta = updatedCell.delta;\\n        uint8 life = updatedCell.life;\\n        // logger.logCell(0, 'before update', position, updatedCell, address(uint160(_owners[position])));\\n        if (lastUpdate >= 1 && life > 0) {\\n            (uint8 newLife, ) = _computeNewLife(lastUpdate, updatedCell.enemyMap, delta, life, epoch);\\n            updatedCell.life = newLife;\\n            updatedCell.lastEpochUpdate = epoch; // TODO check if this is useful to cap it to epoch where it died\\n            justDied = newLife == 0;\\n        }\\n        int8 effectiveDelta = _effectiveDelta(updatedCell.delta, updatedCell.enemyMap);\\n        if (effectiveDelta > 0) {\\n            updatedCell.producingEpochs += epoch - lastUpdate;\\n        }\\n    }\\n\\n    /// @dev Get the owner of a token.\\n    /// @param tokenID The token to query.\\n    function _ownerOf(uint256 tokenID) internal view virtual returns (address owner) {\\n        owner = address(uint160(_owners[tokenID]));\\n    }\\n}\\n\",\"keccak256\":\"0x79f384f1a05b132fa376a318fd299a2681ef49fea4066b2efd86240884bceb6c\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsStore.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\n\\ncontract UsingStratagemsStore is UsingStratagemsTypes {\\n    mapping(uint256 => Cell) internal _cells;\\n    mapping(uint256 => uint256) internal _owners; //owner + approval + ... erc721\\n\\n    Discovered _discovered;\\n\\n    mapping(address => uint256) internal _tokensInReserve;\\n    mapping(address => Commitment) internal _commitments;\\n\\n    // Operators (also used by ERC721)\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    // ERC721 balanceOf\\n    // mapping(address => uint256) internal _balances;\\n}\\n\",\"keccak256\":\"0x1530946719faf48cdbe553a506e9604a9e9633820d884e0e37d278115ba53ed1\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\nimport \\\"../interface/UsingStratagemsErrors.sol\\\";\\n\\nabstract contract UsingStratagemsUtils is UsingStratagemsTypes, UsingStratagemsErrors {\\n    function _checkHash(\\n        bytes24 commitmentHash,\\n        bytes32 secret,\\n        Move[] memory moves,\\n        bytes24 furtherMoves\\n    ) internal pure {\\n        if (furtherMoves != bytes24(0)) {\\n            bytes24 computedHash = bytes24(keccak256(abi.encode(secret, moves, furtherMoves)));\\n            if (commitmentHash != computedHash) {\\n                revert CommitmentHashNotMatching();\\n            }\\n        } else {\\n            bytes24 computedHash = bytes24(keccak256(abi.encode(secret, moves)));\\n            if (commitmentHash != computedHash) {\\n                revert CommitmentHashNotMatching();\\n            }\\n        }\\n    }\\n\\n    function _collectTransfer(\\n        TokenTransferCollection memory transferCollection,\\n        TokenTransfer memory newTransfer\\n    ) internal pure {\\n        // we look for the newTransfer address in case it is already present\\n        for (uint256 k = 0; k < transferCollection.numTransfers; k++) {\\n            if (transferCollection.transfers[k].to == newTransfer.to) {\\n                // if we found we add the amount\\n                transferCollection.transfers[k].amount += newTransfer.amount;\\n                return;\\n            }\\n        }\\n        // if we did not find that address we add it to the end\\n        transferCollection.transfers[transferCollection.numTransfers].to = newTransfer.to;\\n        transferCollection.transfers[transferCollection.numTransfers].amount = newTransfer.amount;\\n        // and increase the size to lookup for next time\\n        transferCollection.numTransfers++;\\n    }\\n\\n    function _multiTransfer(IERC20WithIERC2612 token, TokenTransferCollection memory transferCollection) internal {\\n        for (uint256 i = 0; i < transferCollection.numTransfers; i++) {\\n            token.transfer(transferCollection.transfers[i].to, transferCollection.transfers[i].amount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62eaa33b438ebcfce77a86f2da6c6fa83853b7bf949ae5524490766d282deccb\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingVirtualTime.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\n\\nabstract contract UsingVirtualTime {\\n    // TODO use hardhat-preprocessor\\n\\n    ITime immutable _time;\\n\\n    constructor(UsingStratagemsTypes.Config memory config) {\\n        _time = config.time;\\n    }\\n\\n    function _timestamp() internal view returns (uint256) {\\n        if (address(_time) == address(0)) {\\n            return block.timestamp;\\n        }\\n        return _time.timestamp();\\n    }\\n}\\n\",\"keccak256\":\"0xc879b36cc8d50d6e3e9f086845bbd62dcaddeb99b1242400314b8c6b69a211b3\",\"license\":\"AGPL-3.0\"},\"src/game/routes/StratagemsERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../internal/UsingStratagemsSetters.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Errors.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721Metadata.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721WithBlocknumber.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721Receiver.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/implementations/ImplementingERC721Internal.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/utils/UsingGenericErrors.sol\\\";\\n\\ncontract StratagemsERC721 is\\n    IERC721,\\n    IERC721Metadata,\\n    IERC721WithBlocknumber,\\n    UsingStratagemsSetters,\\n    ImplementingERC721Internal,\\n    UsingERC721Errors\\n{\\n    using Openzeppelin_Address for address;\\n\\n    constructor(Config memory config) UsingStratagemsSetters(config) {}\\n\\n    bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\\n    uint256 internal constant OPERATOR_FLAG = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n    // --------------------------------------------------------------------------------------------\\n    // Getters\\n    // --------------------------------------------------------------------------------------------\\n\\n    // /// @inheritdoc IERC721\\n    /// @notice balanceOf is not implemented, keeping track of this add gas and we did not consider that worth it\\n    function balanceOf(address) external pure override returns (uint256) {\\n        revert UsingGenericErrors.NotImplemented();\\n        // if (owner == address(0)) {\\n        // \\trevert InvalidAddress(owner);\\n        // }\\n        // balance = _balances[owner];\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenID) external view override returns (address owner) {\\n        owner = _ownerOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(uint256 tokenID) external view override returns (address operator) {\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (operatorEnabled) {\\n            return _operators[tokenID];\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\\n        /// 0x01ffc9a7 is ERC165.\\n        /// 0x80ac58cd is ERC721\\n        /// 0x5b5e139f is for ERC721 metadata\\n        return interfaceID == 0x01ffc9a7 || interfaceID == 0x80ac58cd || interfaceID == 0x5b5e139f;\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function name() external pure returns (string memory) {\\n        return \\\"Islands\\\";\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function symbol() external pure returns (string memory) {\\n        return \\\"ISLAND\\\";\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenID) external view returns (string memory) {\\n        (uint24 epoch, ) = _epoch();\\n        (Cell memory cell, ) = _getUpdatedCell(uint64(tokenID), epoch);\\n        (int32 x, int32 y) = PositionUtils.toXY(uint64(tokenID));\\n\\n        (string memory factionName, string memory factionColor) = _factionDisplay(cell.color);\\n\\n        DisplayData memory data = DisplayData({\\n            x: StringUtils.toString(x),\\n            y: StringUtils.toString(y),\\n            life: StringUtils.toString(cell.life),\\n            delta: StringUtils.toString(_effectiveDelta(cell.delta, cell.enemyMap)),\\n            creationEpoch: StringUtils.toString(cell.epochWhenTokenIsAdded),\\n            factionName: factionName,\\n            factionColor: factionColor\\n        });\\n\\n        string memory svgURI = _svgURI(data);\\n        return\\n            string.concat(\\n                'data:application/json,{\\\"name\\\":\\\"Island%20(',\\n                data.x,\\n                \\\",\\\",\\n                data.y,\\n                ')\\\",\\\"description\\\":\\\"A%20Piece%20Of%20Land%20In%20Stratagems,%20An%20Autonomous%20World%20Created%20By%20Players.\\\",\\\"image\\\":\\\"',\\n                svgURI,\\n                '\\\"}'\\n            );\\n    }\\n\\n    /// @inheritdoc IERC721WithBlocknumber\\n    function ownerAndLastTransferBlockNumberOf(\\n        uint256 tokenID\\n    ) external view override returns (address owner, uint256 blockNumber) {\\n        (address currentOwner, uint256 nonce) = _ownerAndNonceOf(tokenID);\\n        owner = currentOwner;\\n        blockNumber = (nonce >> 24);\\n    }\\n\\n    /// @inheritdoc IERC721WithBlocknumber\\n    function ownerAndLastTransferBlockNumberList(\\n        uint256[] calldata tokenIDs\\n    ) external view virtual returns (OwnerData[] memory ownersData) {\\n        ownersData = new OwnerData[](tokenIDs.length);\\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\\n            uint256 data = _owners[tokenIDs[i]];\\n            ownersData[i].owner = address(uint160(data));\\n            ownersData[i].lastTransferBlockNumber = (data >> 184) & 0xFFFFFFFFFFFFFFFF;\\n        }\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // Setters\\n    // --------------------------------------------------------------------------------------------\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data) public override {\\n        (address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (owner != from) {\\n            revert NotOwner(from, owner);\\n        }\\n\\n        if (to == address(0) || to == address(this)) {\\n            revert InvalidAddress(to);\\n        }\\n\\n        if (msg.sender != from) {\\n            if (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\\n                revert UsingGenericErrors.NotAuthorized();\\n            }\\n        }\\n        _safeTransferFrom(from, to, tokenID, (nonce >> 24) != 0, data);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(address from, address to, uint256 tokenID) external override {\\n        safeTransferFrom(from, to, tokenID, \\\"\\\");\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenID) external override {\\n        (address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (from != owner) {\\n            revert NotOwner(from, owner);\\n        }\\n        if (to == address(0) || to == address(this)) {\\n            revert InvalidAddress(to);\\n        }\\n        if (msg.sender != from) {\\n            if (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\\n                revert UsingGenericErrors.NotAuthorized();\\n            }\\n        }\\n        _transferFrom(from, to, tokenID, (nonce >> 24) != 0);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function approve(address operator, uint256 tokenID) external override {\\n        (address owner, uint256 nonce) = _ownerAndNonceOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\\n            revert UsingGenericErrors.NotAuthorized();\\n        }\\n        _approveFor(owner, nonce, operator, tokenID);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external override {\\n        _setApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    // ------------------------------------------------------------------------------------------------------------------\\n    // INTERNALS\\n    // ------------------------------------------------------------------------------------------------------------------\\n\\n    function _safeMint(address to, uint256 tokenID) internal {\\n        _safeTransferFrom(address(0), to, tokenID, false, \\\"\\\");\\n    }\\n\\n    function _safeTransferFrom(address from, address to, uint256 tokenID, bool registered, bytes memory data) internal {\\n        _transferFrom(from, to, tokenID, registered);\\n        if (to.isContract()) {\\n            if (!_checkOnERC721Received(msg.sender, from, to, tokenID, data)) {\\n                revert TransferRejected();\\n            }\\n        }\\n    }\\n\\n    function _transferFrom(address from, address to, uint256 tokenID, bool /*registered */) internal virtual {\\n        // unchecked {\\n        // \\t_balances[to]++;\\n        // \\tif (registered) {\\n        // \\t\\t_balances[from]--;\\n        // \\t}\\n        // }\\n\\n        revert UsingGenericErrors.NotImplemented();\\n\\n        // We encode the blockNumber in the token nonce. We can then use it for count voting.\\n        _owners[tokenID] = (block.number << 184) | uint256(uint160(to));\\n        Cell memory cell = _cells[uint64(tokenID)];\\n        if (_effectiveDelta(cell.delta, cell.enemyMap) > 0) {\\n            if (from != address(0)) {\\n                GENERATOR.remove(from, NUM_TOKENS_PER_GEMS);\\n            }\\n            if (to != address(0)) {\\n                GENERATOR.add(to, NUM_TOKENS_PER_GEMS);\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenID);\\n    }\\n\\n    /// @dev See approve.\\n    function _approveFor(address owner, uint256 nonce, address operator, uint256 tokenID) internal override {\\n        uint256 blockNumber = nonce >> 24;\\n        uint256 newNonce = nonce + 1;\\n        if (newNonce >> 24 != blockNumber) {\\n            revert NonceOverflow();\\n        }\\n        if (operator == address(0)) {\\n            _owners[tokenID] = (newNonce << 160) | uint256(uint160(owner));\\n        } else {\\n            _owners[tokenID] = OPERATOR_FLAG | ((newNonce << 160) | uint256(uint160(owner)));\\n            _operators[tokenID] = operator;\\n        }\\n        emit Approval(owner, operator, tokenID);\\n    }\\n\\n    /// @dev See setApprovalForAll.\\n    function _setApprovalForAll(address sender, address operator, bool approved) internal override {\\n        _operatorsForAll[sender][operator] = approved;\\n\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /// @dev Check if receiving contract accepts erc721 transfers.\\n    /// @param operator The address of the operator.\\n    /// @param from The from address, may be different from msg.sender.\\n    /// @param to The adddress we want to transfer to.\\n    /// @param tokenID The id of the token we would like to transfer.\\n    /// @param data Any additional data to send with the transfer.\\n    /// @return Whether the expected value of 0x150b7a02 is returned.\\n    function _checkOnERC721Received(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bytes memory data\\n    ) internal returns (bool) {\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, tokenID, data);\\n        return (retval == ERC721_RECEIVED);\\n    }\\n\\n    /// @dev Get the owner and operatorEnabled status of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\\n    function _ownerAndOperatorEnabledOf(\\n        uint256 tokenID\\n    ) internal view virtual returns (address owner, bool operatorEnabled) {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n    }\\n\\n    /// @dev Get the owner and the permit nonce of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual override returns (address owner, uint256 nonce) {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        nonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n\\n    // @dev Get the owner, the permit nonce of a token and operatorEnabled status of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\\n    function _ownerNonceAndOperatorEnabledOf(\\n        uint256 tokenID\\n    ) internal view virtual returns (address owner, uint256 nonce, bool operatorEnabled) {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n        nonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n\\n    function _svgURI(DisplayData memory data) internal pure returns (string memory) {\\n        return\\n            string.concat(\\n                \\\"data:image/svg+xml,<svg%2520xmlns='http://www.w3.org/2000/svg'%2520viewBox='0%25200%2520512%2520512'><title>Island%2520\\\",\\n                \\\"(\\\",\\n                data.x,\\n                \\\",\\\",\\n                data.y,\\n                \\\")</title><rect%2520x='16'%2520y='16'%2520width='480'%2520height='480'%2520stroke='\\\",\\n                data.factionColor,\\n                \\\"'%2520stroke-width='3px'%2520fill='transparent'/><text%2520x='256'%2520y='256'%2520font-size='48px'%2520font-weight='bold'%2520fill='\\\",\\n                data.factionColor,\\n                \\\"'%2520dominant-baseline='middle'%2520text-anchor='middle'><tspan%2520x='256'%2520dy='-3.7em'>Island</tspan><tspan%2520x='256'%2520dy='1em'>(\\\",\\n                data.x,\\n                \\\",\\\",\\n                data.y,\\n                \\\")</tspan><tspan%2520x='256'%2520dy='2.2em'>Faction:%2520\\\",\\n                data.factionName,\\n                \\\"</tspan><tspan%2520x='256'%2520dy='1em'>Life:%2520\\\",\\n                data.life,\\n                \\\"</tspan><tspan%2520x='256'%2520dy='1em'>Growth:%2520\\\",\\n                data.delta,\\n                \\\"</tspan><tspan%2520x='256'%2520dy='2.3em'>Epoch%20\\\",\\n                data.creationEpoch,\\n                \\\"</tspan></text></svg>\\\"\\n            );\\n    }\\n\\n    function _factionDisplay(\\n        Color color\\n    ) internal pure returns (string memory factionName, string memory factionColor) {\\n        if (color == Color.None) {\\n            factionName = \\\"None\\\";\\n            factionColor = \\\"gray\\\";\\n        } else if (color == Color.Blue) {\\n            factionName = \\\"Blue\\\";\\n            factionColor = \\\"blue\\\";\\n        } else if (color == Color.Red) {\\n            factionName = \\\"Red\\\";\\n            factionColor = \\\"red\\\";\\n        } else if (color == Color.Green) {\\n            factionName = \\\"Green\\\";\\n            factionColor = \\\"green\\\";\\n        } else if (color == Color.Yellow) {\\n            factionName = \\\"Yellow\\\";\\n            factionColor = \\\"yellow\\\";\\n        } else if (color == Color.Purple) {\\n            factionName = \\\"Purple\\\";\\n            factionColor = \\\"purple\\\";\\n        } else if (color == Color.Evil) {\\n            factionName = \\\"Evil\\\";\\n            factionColor = \\\"black\\\";\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x56491a3f50e4c8fe9cda6031c4c25560795820b29d678b302bba6919cc883b0d\",\"license\":\"AGPL-3.0\"},\"src/token/interface/IOnStakeChange.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IOnStakeChange {\\n    function add(address account, uint256 amount) external;\\n\\n    function remove(address account, uint256 amount) external;\\n\\n    function move(address from, address to, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0xb73017e0afe41fc34d5ce6382ae3f67bc08eaffeedcf7064ca4205e54035dc38\",\"license\":\"AGPL-3.0\"},\"src/utils/PositionUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary PositionUtils {\\n    function toXY(uint64 position) internal pure returns (int32 x, int32 y) {\\n        x = int32(uint32(position) & 0xFFFFFFFF);\\n        y = int32(uint32(position >> 32));\\n    }\\n\\n    function offset(uint64 position, int32 x, int32 y) internal pure returns (uint64 newPosition) {\\n        x = int32(uint32(position) & 0xFFFFFFFF) + x;\\n        y = int32(uint32(position >> 32)) + y;\\n        newPosition = (uint64(uint32(y)) << 32) + uint64(uint32(x));\\n    }\\n}\\n\",\"keccak256\":\"0x82dcff44b73db30e108027baaa503a39f30c3e1accbf0133c52f4615e8f5d70c\",\"license\":\"AGPL-3.0\"},\"src/utils/StringUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nlibrary StringUtils {\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        return Strings.toString(value);\\n    }\\n\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", Strings.toString(SignedMath.abs(value))));\\n    }\\n}\\n\",\"keccak256\":\"0x012166e145b476899e290961b2ddd6415b57604e8b6bde82c982e00b50a5105a\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 14473,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_cells",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Cell)11534_storage)"
      },
      {
        "astId": 14477,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_owners",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 14480,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_discovered",
        "offset": 0,
        "slot": "2",
        "type": "t_struct(Discovered)11514_storage"
      },
      {
        "astId": 14484,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_tokensInReserve",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 14489,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_commitments",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_struct(Commitment)11539_storage)"
      },
      {
        "astId": 14495,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_operatorsForAll",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 14499,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_operators",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes24": {
        "encoding": "inplace",
        "label": "bytes24",
        "numberOfBytes": "24"
      },
      "t_enum(Color)11440": {
        "encoding": "inplace",
        "label": "enum UsingStratagemsTypes.Color",
        "numberOfBytes": "1"
      },
      "t_int8": {
        "encoding": "inplace",
        "label": "int8",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_struct(Commitment)11539_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct UsingStratagemsTypes.Commitment)",
        "numberOfBytes": "32",
        "value": "t_struct(Commitment)11539_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Cell)11534_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct UsingStratagemsTypes.Cell)",
        "numberOfBytes": "32",
        "value": "t_struct(Cell)11534_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Cell)11534_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Cell",
        "members": [
          {
            "astId": 11516,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "lastEpochUpdate",
            "offset": 0,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 11518,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "epochWhenTokenIsAdded",
            "offset": 3,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 11520,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "producingEpochs",
            "offset": 6,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 11523,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "color",
            "offset": 9,
            "slot": "0",
            "type": "t_enum(Color)11440"
          },
          {
            "astId": 11525,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "life",
            "offset": 10,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11527,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "delta",
            "offset": 11,
            "slot": "0",
            "type": "t_int8"
          },
          {
            "astId": 11529,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "enemyMap",
            "offset": 12,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11531,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "distribution",
            "offset": 13,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11533,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "stake",
            "offset": 14,
            "slot": "0",
            "type": "t_uint8"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Commitment)11539_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Commitment",
        "members": [
          {
            "astId": 11536,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "hash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes24"
          },
          {
            "astId": 11538,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "epoch",
            "offset": 24,
            "slot": "0",
            "type": "t_uint24"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Discovered)11514_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Discovered",
        "members": [
          {
            "astId": 11507,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "minX",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 11509,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "maxX",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 11511,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "minY",
            "offset": 8,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 11513,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "maxY",
            "offset": 12,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  },
  "userdoc": {
    "errors": {
      "CanStillReveal()": [
        {
          "notice": "Player have to reveal if they can Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal."
        }
      ],
      "CommitmentHashNotMatching()": [
        {
          "notice": "Player have to reveal their commitment using the exact same move values  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal."
        }
      ],
      "GameNotStarted()": [
        {
          "notice": "Game has not started yet, can't perform any action"
        }
      ],
      "ImpossibleConfiguration()": [
        {
          "notice": "The cell configuration is invalid This can happen win debug mode where admin can setup cell bypassing moves rules For example when setting up neighborood configuration that would require a cell to have negative life"
        }
      ],
      "InCommitmentPhase()": [
        {
          "notice": "When in Commit phase, player can make new commitment but they cannot reveal their move yet."
        }
      ],
      "InRevealPhase()": [
        {
          "notice": "When in Reveal phase, it is not possible to commit new moves or cancel previous commitment  During Reveal phase, players have to reveal their commitment, if not already done."
        }
      ],
      "InvalidAddress(address)": [
        {
          "notice": "An invalid address is specified (for example: zero address)"
        }
      ],
      "InvalidEpoch()": [
        {
          "notice": "Player can only reveal their move in the same epoch they commited.abi  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`"
        }
      ],
      "InvalidFurtherMoves()": [
        {
          "notice": "Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves  This result in a recursive series of hash that they can then submit in turn while revealing.  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block."
        }
      ],
      "NonExistentToken(uint256)": [
        {
          "notice": "The token does not exist"
        }
      ],
      "NonceOverflow()": [
        {
          "notice": "The Nonce overflowed, make a transfer to self to allow new nonces."
        }
      ],
      "NotAuthorized()": [
        {
          "notice": "Not authorized to perform this operation"
        }
      ],
      "NotImplemented()": [
        {
          "notice": "function is not implemented"
        }
      ],
      "NotOwner(address,address)": [
        {
          "notice": "The address from which the token is sent is not the current owner"
        }
      ],
      "NothingToReveal()": [
        {
          "notice": "Player can only reveal moves they commited."
        }
      ],
      "PreviousCommitmentNotRevealed()": [
        {
          "notice": "Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\"
        }
      ],
      "ReserveTooLow(uint256,uint256)": [
        {
          "notice": "to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase."
        }
      ],
      "TransferRejected()": [
        {
          "notice": "The Transfer was rejected by the destination"
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "notice": "Triggered when a token is approved to be sent by another account  Note tat the approval get reset when a Transfer event for that same token is emitted."
      },
      "ApprovalForAll(address,address,bool)": {
        "notice": "Triggered when an account approve or disaprove another to transfer on its behalf"
      },
      "CommitmentCancelled(address,uint24)": {
        "notice": "A player has cancelled its current commitment (before it reached the reveal phase)"
      },
      "CommitmentMade(address,uint24,bytes24)": {
        "notice": "A player has commited to make a move and reveal it on the reveal phase"
      },
      "CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)": {
        "notice": "Player has revealed its previous commitment"
      },
      "CommitmentVoid(address,uint24,uint256,bytes24)": {
        "notice": "A player has canceled a previous commitment by burning some tokens"
      },
      "MoveProcessed(uint64,address,uint8,uint8)": {
        "notice": "A move has been revealed."
      },
      "MultiPoke(uint24,uint64[])": {
        "notice": "poke multiple cells and update them if needed"
      },
      "ReserveDeposited(address,uint256,uint256)": {
        "notice": "Player has deposited token in the reserve, allowing it to use that much in game"
      },
      "ReserveWithdrawn(address,uint256,uint256)": {
        "notice": "Player have withdrawn token from the reserve"
      },
      "SinglePoke(uint24,uint64)": {
        "notice": "poke cell and update it if needed"
      },
      "Transfer(address,address,uint256)": {
        "notice": "Triggered when a token is transferred"
      }
    },
    "kind": "user",
    "methods": {
      "approve(address,uint256)": {
        "notice": "Approve an operator to transfer a specific token on the senders behalf."
      },
      "balanceOf(address)": {
        "notice": "balanceOf is not implemented, keeping track of this add gas and we did not consider that worth it"
      },
      "getApproved(uint256)": {
        "notice": "Get the approved operator for a specific token."
      },
      "isApprovedForAll(address,address)": {
        "notice": "Check if the sender approved the operator to transfer any of its tokens."
      },
      "name()": {
        "notice": "A descriptive name for a collection of NFTs in this contract"
      },
      "ownerAndLastTransferBlockNumberList(uint256[])": {
        "notice": "Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism."
      },
      "ownerAndLastTransferBlockNumberOf(uint256)": {
        "notice": "Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism."
      },
      "ownerOf(uint256)": {
        "notice": "Get the owner of a token."
      },
      "safeTransferFrom(address,address,uint256)": {
        "notice": "Transfer a token between 2 addresses letting the receiver know of the transfer."
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "notice": "Transfer a token between 2 addresses letting the receiver knows of the transfer."
      },
      "setApprovalForAll(address,bool)": {
        "notice": "Set the approval for an operator to manage all the tokens of the sender."
      },
      "supportsInterface(bytes4)": {
        "notice": "Query if a contract implements an interface"
      },
      "symbol()": {
        "notice": "An abbreviated name for NFTs in this contract"
      },
      "tokenURI(uint256)": {
        "notice": "A distinct Uniform Resource Identifier (URI) for a given asset."
      },
      "transferFrom(address,address,uint256)": {
        "notice": "Transfer a token between 2 addresses."
      }
    },
    "version": 1
  },
  "argsData": "0x0000000000000000000000007edebd362d3138c32a9cb72634e711617c103476000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000143700000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000006de75a33cf63fea42ea8e5bafadaa1c80c246c6d0000000000000000000000000db93e3529ec578e55e0013d2518ef5ab33d5739",
  "transaction": {
    "hash": "0x71f41b9a3e22d16fe657d3fe9b1a3b22fc76aa61527a8937576a555472539dcf",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "confirmations": 0,
    "blockHash": "0x4d2ca98bedebed71adac6b27200c6dfdf2eaf9aa65cf893d3b04728d4e485f1a",
    "blockNumber": "0x73db20",
    "transactionIndex": "0x3"
  }
}