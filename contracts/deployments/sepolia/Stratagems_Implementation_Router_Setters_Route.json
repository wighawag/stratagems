{
  "address": "0x2b0c864cdc8d70d3e9684e44fbede8f725778a63",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract IERC20WithIERC2612",
              "name": "tokens",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "burnAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "commitPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revealPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "maxLife",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "numTokensPerGems",
              "type": "uint256"
            },
            {
              "internalType": "contract ITime",
              "name": "time",
              "type": "address"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CanStillReveal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CommitmentHashNotMatching",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "GameNotStarted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InCommitmentPhase",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InRevealPhase",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEpoch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFurtherMoves",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NothingToReveal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PreviousCommitmentNotRevealed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "inReserve",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expected",
          "type": "uint256"
        }
      ],
      "name": "ReserveTooLow",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        }
      ],
      "name": "CommitmentCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentMade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": true,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "enum UsingStratagemsTypes.Color",
              "name": "color",
              "type": "uint8"
            }
          ],
          "indexed": false,
          "internalType": "struct UsingStratagemsTypes.Move[]",
          "name": "moves",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newReserveAmount",
          "type": "uint256"
        }
      ],
      "name": "CommitmentRevealed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountBurnt",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentVoid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum UsingStratagemsTypes.Color",
          "name": "oldColor",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "enum UsingStratagemsTypes.Color",
          "name": "newColor",
          "type": "uint8"
        }
      ],
      "name": "MoveProcessed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint64[]",
          "name": "positions",
          "type": "uint64[]"
        }
      ],
      "name": "MultiPoke",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountDeposited",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "ReserveDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountWithdrawn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "ReserveWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        }
      ],
      "name": "SinglePoke",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "secret",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "enum UsingStratagemsTypes.Color",
              "name": "color",
              "type": "uint8"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Move[]",
          "name": "moves",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        }
      ],
      "name": "acknowledgeMissedReveal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acknowledgeMissedRevealByBurningAllReserve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokensAmountToAdd",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Permit",
          "name": "permit",
          "type": "tuple"
        }
      ],
      "name": "addToReserve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cancelCommitment",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        },
        {
          "internalType": "address payable",
          "name": "payee",
          "type": "address"
        }
      ],
      "name": "makeCommitment",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        },
        {
          "internalType": "uint256",
          "name": "tokensAmountToAdd",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadline",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Permit",
          "name": "permit",
          "type": "tuple"
        },
        {
          "internalType": "address payable",
          "name": "payee",
          "type": "address"
        }
      ],
      "name": "makeCommitmentWithExtraReserve",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        }
      ],
      "name": "poke",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64[]",
          "name": "positions",
          "type": "uint64[]"
        }
      ],
      "name": "pokeMultiple",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "secret",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "enum UsingStratagemsTypes.Color",
              "name": "color",
              "type": "uint8"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Move[]",
          "name": "moves",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        },
        {
          "internalType": "bool",
          "name": "useReserve",
          "type": "bool"
        },
        {
          "internalType": "address payable",
          "name": "payee",
          "type": "address"
        }
      ],
      "name": "reveal",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawFromReserve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "StratagemsSetters",
  "sourceName": "src/game/routes/StratagemsSetters.sol",
  "bytecode": "0x6101806040523480156200001257600080fd5b5060405162004925380380620049258339810160408190526200003591620000be565b60e0808201516001600160a01b0390811660809081528351821660a0908152602085015190921661016052604084015160c090815260608501519093528301516101005282015160ff16610120520151610140526200017e565b80516001600160a01b0381168114620000a757600080fd5b919050565b805160ff81168114620000a757600080fd5b6000610100808385031215620000d357600080fd5b604051908101906001600160401b03821181831017156200010457634e487b7160e01b600052604160045260246000fd5b8160405262000113846200008f565b815262000123602085016200008f565b60208201526040840151604082015260608401516060820152608084015160808201526200015460a08501620000ac565b60a082015260c084015160c08201526200017160e085016200008f565b60e0820152949350505050565b60805160a05160c05160e05161010051610120516101405161016051614676620002af600039600081816107ee01528181610c1101526122c9015260008181611858015281816118ad01528181611a1601528181611ae301528181612baa01528181612c0401528181612c6301528181612daf01528181612de0015261366d015260008181612b220152818161318a015281816131f80152613226015260006115cd0152600081816115ee01526116c101526000818161162201526116810152600081816103430152818161044c0152818161057c0152818161081d0152818161096801528181610c4001528181610e19015281816113df015281816115090152818161208f01528181612204015281816122f901526123c6015260008181612445015261248501526146766000f3fe6080604052600436106100b15760003560e01c80638b8fc3a111610069578063afa1e2d11161004e578063afa1e2d114610173578063d401978314610188578063d67101121461019b57600080fd5b80638b8fc3a114610140578063ae37a62d1461016057600080fd5b80631fdd8a691161009a5780631fdd8a69146100eb5780634dd3ab2314610100578063599a71c61461012057600080fd5b80630a8bcdb9146100b657806310837a39146100d8575b600080fd5b3480156100c257600080fd5b506100d66100d1366004613b71565b6101bb565b005b6100d66100e6366004613bf7565b6103f4565b3480156100f757600080fd5b506100d66106a2565b34801561010c57600080fd5b506100d661011b366004613c60565b6108d2565b34801561012c57600080fd5b506100d661013b366004613cce565b6109d7565b34801561014c57600080fd5b506100d661015b366004613d3f565b610d32565b6100d661016e366004613db4565b610e75565b34801561017f57600080fd5b506100d6610ef5565b6100d6610196366004613df9565b611004565b3480156101a757600080fd5b506100d66101b6366004613e91565b61138d565b33600090815260036020526040812090806101d46115c4565b845491935091507801000000000000000000000000000000000000000000000000900462ffffff161580159061023757508015806102375750825462ffffff83811678010000000000000000000000000000000000000000000000009092041614155b1561026e576040517f0aafb74c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b336000908152600260205260409020546001850161028f57935060006102e5565b848110156102d8576040517f78fe52a600000000000000000000000000000000000000000000000000000000815260048101829052602481018690526044015b60405180910390fd5b6102e28582613eed565b90505b3360008181526002602052604090819020839055517fa9059cbb00000000000000000000000000000000000000000000000000000000815260048101919091526024810186905273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303816000875af115801561038c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103b09190613f06565b50604080518681526020810183905233917ff7aeb382a1e87f84aa69637a22868c2e12be1261273f04cdf40a262a8b89003191015b60405180910390a25050505050565b3360009081526002602052604090205461040e8482613f23565b33600081815260026020526040902082905590915061042e90868361170f565b82351561053b5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663d505accf33308635602088013561048a60608a0160408b01613f36565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b16815273ffffffffffffffffffffffffffffffffffffffff95861660048201529490931660248501526044840191909152606483015260ff166084820152606086013560a4820152608086013560c482015260e401600060405180830381600087803b15801561052257600080fd5b505af1158015610536573d6000803e3d6000fd5b505050505b831561063b576040517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018590527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906323b872dd906064016020604051808303816000875af11580156105da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105fe9190613f06565b50604080518581526020810183905233917f9705a8ff16374359785d31b0f1862c27f983645496f40760d180a9830eeaf2e8910160405180910390a25b73ffffffffffffffffffffffffffffffffffffffff82161561069b5760405173ffffffffffffffffffffffffffffffffffffffff8316903480156108fc02916000818181858888f19350505050158015610699573d6000803e3d6000fd5b505b5050505050565b336000908152600360205260408120906106ba6115c4565b5082549091507801000000000000000000000000000000000000000000000000900462ffffff1660000361071a576040517f6599c9aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b815462ffffff80831678010000000000000000000000000000000000000000000000009092041603610778576040517f175868d700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81547fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff168255336000908152600260205260408082208054929055517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303816000875af1158015610866573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061088a9190613f06565b50604080518281526000602082015262ffffff84169133917f6337d70daadadd11f8be7f6e7b38e6c04d28710b1f2a2894bb14d8e3eaa8cdb6910160405180910390a3505050565b60006108dc6115c4565b50905060006040518060400160405280600567ffffffffffffffff81111561090657610906613f59565b60405190808252806020026020018201604052801561094b57816020015b60408051808201909152600080825260208201528152602001906001900390816109245790505b50815260200160008152509050610963818484611955565b61098d7f000000000000000000000000000000000000000000000000000000000000000082611d17565b60405167ffffffffffffffff8416815262ffffff8316907f9987a1be5559dc397dbe41aa886352a4124ac12037da7d0f28631c1c67e0ae55906020015b60405180910390a2505050565b73ffffffffffffffffffffffffffffffffffffffff8516600090815260036020526040812090610a056115c4565b5082549091507801000000000000000000000000000000000000000000000000900462ffffff161580610a5c5750815462ffffff828116780100000000000000000000000000000000000000000000000090920416145b15610a93576040517f175868d700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81546040805160208088028201810183528782528793610af4931b918a918a908690819060009085015b82821015610ae957610ada60408302860136819003810190613f97565b81526020019060010190610abd565b505050505087611e1a565b7fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000841615610b875760208114610b56576040517fcc586b4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82547fffffffffffffffff00000000000000000000000000000000000000000000000016604085901c178355610bae565b82547fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff1683555b33600090815260026020526040812080548792839291610bcf908490613eed565b90915550506040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303816000875af1158015610c89573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cad9190613f06565b50604080518281527fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008716602082015262ffffff85169173ffffffffffffffffffffffffffffffffffffffff8c16917f6337d70daadadd11f8be7f6e7b38e6c04d28710b1f2a2894bb14d8e3eaa8cdb6910160405180910390a3505050505050505050565b6000610d3c6115c4565b5060408051808201909152909150829060009080610d5b846005614019565b67ffffffffffffffff811115610d7357610d73613f59565b604051908082528060200260200182016040528015610db857816020015b6040805180820190915260008082526020820152815260200190600190039081610d915790505b5081526020016000815250905060005b82811015610e1357610e0182878784818110610de657610de6614030565b9050602002016020810190610dfb9190613c60565b86611955565b80610e0b8161405f565b915050610dc8565b50610e3e7f000000000000000000000000000000000000000000000000000000000000000082611d17565b8262ffffff167ff4b03f4527c0ed32b6739e04de71d601db894eb6c1bcd17bb34a184bb9536c6686866040516103e5929190614097565b33600081815260026020526040902054610e919190849061170f565b73ffffffffffffffffffffffffffffffffffffffff811615610ef15760405173ffffffffffffffffffffffffffffffffffffffff8216903480156108fc02916000818181858888f19350505050158015610eef573d6000803e3d6000fd5b505b5050565b3360009081526003602052604081209080610f0e6115c4565b9150915080610f49576040517fdc12c97300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825462ffffff83811678010000000000000000000000000000000000000000000000009092041614610fa7576040517f0aafb74c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82547fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff16835560405162ffffff83169033907f619ef9650648da30c9647d0b77a0de24a51da0630c3533d54cc1eb3d798e1eaa90600090a3505050565b73ffffffffffffffffffffffffffffffffffffffff8716600090815260036020526040812090806110336115c4565b91509150801561106f576040517f24f7f40f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82547801000000000000000000000000000000000000000000000000900462ffffff166000036110cb576040517f6599c9aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825462ffffff83811678010000000000000000000000000000000000000000000000009092041614611129576040517fd5b25b6300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8254604080516020808b028201810183528a825261118b9390921b918c91908c908c90819060009085015b828210156111805761117160408302860136819003810190613f97565b81526020019060010190611154565b505050505089611e1a565b60006111f78b848b8b808060200260200160405190810160405280939291908181526020016000905b828210156111e0576111d160408302860136819003810190613f97565b815260200190600101906111b4565b5050505050896111f0578e611f48565b6000611f48565b845490915060401b7fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008816156112925760208914611261576040517fcc586b4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b84547fffffffffffffffff00000000000000000000000000000000000000000000000016604089901c1785556112b9565b84547fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff1685555b8067ffffffffffffffff19168462ffffff168d73ffffffffffffffffffffffffffffffffffffffff167ffab312c5020dc7093e590463878dbfd0567314a7c155b164a60430ebcc7b38038d8d8d88604051611317949392919061414e565b60405180910390a473ffffffffffffffffffffffffffffffffffffffff86161561137f5760405173ffffffffffffffffffffffffffffffffffffffff8716903480156108fc02916000818181858888f1935050505015801561137d573d6000803e3d6000fd5b505b505050505050505050505050565b8115610ef157336000908152600260205260409020546113ad8382613f23565b33600090815260026020526040902081905590508135156114ce5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663d505accf33308535602087013561141d6060890160408a01613f36565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b16815273ffffffffffffffffffffffffffffffffffffffff95861660048201529490931660248501526044840191909152606483015260ff166084820152606085013560a4820152608085013560c482015260e401600060405180830381600087803b1580156114b557600080fd5b505af11580156114c9573d6000803e3d6000fd5b505050505b6040517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906323b872dd906064016020604051808303816000875af1158015611567573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061158b9190613f06565b50604080518481526020810183905233917f9705a8ff16374359785d31b0f1862c27f983645496f40760d180a9830eeaf2e891016109ca565b600080806116127f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000613f23565b9050600061161e612441565b90507f000000000000000000000000000000000000000000000000000000000000000081101561167a576040517f3a5f7b5700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006116a67f000000000000000000000000000000000000000000000000000000000000000083613eed565b90506116b28382614212565b6116bd906002613f23565b94507f0000000000000000000000000000000000000000000000000000000000000000836116ec600288614226565b62ffffff166116fb9190614019565b6117059083613eed565b1093505050509091565b73ffffffffffffffffffffffffffffffffffffffff83166000908152600360205260408120908061173e6115c4565b9150915080611779576040517fdc12c97300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82547801000000000000000000000000000000000000000000000000900462ffffff16158015906117cf5750825462ffffff83811678010000000000000000000000000000000000000000000000009092041614155b15611806576040517f0aafb74c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825462ffffff83167801000000000000000000000000000000000000000000000000027fffffffffff000000000000000000000000000000000000000000000000000000909116604087901c171783557f00000000000000000000000000000000000000000000000000000000000000008410156118d9576040517f78fe52a6000000000000000000000000000000000000000000000000000000008152600481018590527f000000000000000000000000000000000000000000000000000000000000000060248201526044016102cf565b6040517fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008616815262ffffff83169073ffffffffffffffffffffffffffffffffffffffff8816907fe3c45ded79e3db74b160b9a697d75f465f68d287a678532ed0a9fb691553b93d9060200160405180910390a3505050505050565b6000806119628484612517565b60c08201519193509150811561199c5761197f8360a001516126a4565b60048460a0015160ff16901b6119959190614249565b6000845290505b6000806119b4878787604001518860400151876126d6565b9094509250505061ffff821615611a5057611a508860405180604001604052806119f48b67ffffffffffffffff1660009081526001602052604090205490565b73ffffffffffffffffffffffffffffffffffffffff168152602001600c611a3f7f000000000000000000000000000000000000000000000000000000000000000061ffff8916614019565b611a499190614212565b9052612961565b60005b60048160ff161015611b305760008260ff831660048110611a7657611a76614030565b602002015173ffffffffffffffffffffffffffffffffffffffff1614611b1e57611b1e896040518060400160405280858560ff1660048110611aba57611aba614030565b602002015173ffffffffffffffffffffffffffffffffffffffff16815260200187600f1660ff167f0000000000000000000000000000000000000000000000000000000000000000611b0c9190614212565b8a60e0015160ff16611a499190614019565b80611b2881614262565b915050611a53565b50600060c0860181905267ffffffffffffffff881681526020818152604091829020875181549289015162ffffff9081166301000000027fffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000009094169116179190911780825591870151879282907fffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffff166601000000000000836006811115611bd957611bd96140e4565b021790555060608201518154608084015160a085015160c086015160e0909601517fffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffff90931667010000000000000060ff958616027fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff16176801000000000000000092851692909202919091177fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff166901000000000000000000918416919091027fffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff16176a010000000000000000000094831694909402939093177fffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff166b01000000000000000000000091909316029190911790555050505050505050565b60005b8160200151811015610eef578273ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83600001518381518110611d5857611d58614030565b60200260200101516000015184600001518481518110611d7a57611d7a614030565b6020026020010151602001516040518363ffffffff1660e01b8152600401611dc492919073ffffffffffffffffffffffffffffffffffffffff929092168252602082015260400190565b6020604051808303816000875af1158015611de3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e079190613f06565b5080611e128161405f565b915050611d1a565b7fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000811615611ec6576000838383604051602001611e59939291906142db565b6040516020818303038152906040528051906020012090508067ffffffffffffffff19168567ffffffffffffffff191614611ec0576040517fd13415b500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50611f42565b60008383604051602001611edb929190614326565b6040516020818303038152906040528051906020012090508067ffffffffffffffff19168567ffffffffffffffff19161461069b576040517fd13415b500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505050565b600080604051806040016040528085516005611f649190614019565b67ffffffffffffffff811115611f7c57611f7c613f59565b604051908082528060200260200182016040528015611fc157816020015b6040805180820190915260008082526020820152815260200190600190039081611f9a5790505b50815260200160008152509050611ff260405180606001604052806000815260200160008152602001600081525090565b60005b8551811015612089576000806000612028868c8c8c888151811061201b5761201b614030565b6020026020010151612ab3565b92509250925082856000018181516120409190613f23565b905250602085018051839190612057908390613f23565b90525060408501805182919061206e908390613f23565b905250839250612081915082905061405f565b915050611ff5565b506120b47f000000000000000000000000000000000000000000000000000000000000000083611d17565b73ffffffffffffffffffffffffffffffffffffffff87166000908152600260209081526040909120549082015182519194506120ef91613f23565b8310156121435760208101518151849161210891613f23565b6040517f78fe52a6000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044016102cf565b73ffffffffffffffffffffffffffffffffffffffff84166121a8576020810151815161216f9190613f23565b6121799084613eed565b73ffffffffffffffffffffffffffffffffffffffff88166000908152600260205260409020819055925061236a565b8051156122755780516040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff868116600483015230602483015260448201929092527f0000000000000000000000000000000000000000000000000000000000000000909116906323b872dd906064016020604051808303816000875af115801561224f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122739190613f06565b505b60208101511561236a5760208101516040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301527f00000000000000000000000000000000000000000000000000000000000000008116602483015260448201929092527f0000000000000000000000000000000000000000000000000000000000000000909116906323b872dd906064016020604051808303816000875af1158015612344573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123689190613f06565b505b6040810151156124375760408181015190517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff898116600483015260248201929092527f00000000000000000000000000000000000000000000000000000000000000009091169063a9059cbb906044016020604051808303816000875af1158015612411573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124359190613f06565b505b5050949350505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661248357504290565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156124ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612512919061433f565b905090565b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081019190915267ffffffffffffffff8316600090815260208181526040808320815161010081018352815462ffffff80821683526301000000820416948201949094529290918301906601000000000000900460ff1660068111156125b9576125b96140e4565b60068111156125ca576125ca6140e4565b8152905460ff67010000000000000082048116602084015268010000000000000000820460000b60408401526901000000000000000000820481166060808501919091526a0100000000000000000000830482166080808601919091526b01000000000000000000000090930490911660a0909301929092528251908301519183015192945091600162ffffff84161080159061266a575060008160ff16115b1561269a576000612682848760a0015185858b6130e4565b5060ff166060870181905262ffffff88168752159450505b5050509250929050565b60005b60ff8216156126d1576126bb600183614358565b90911690806126c981614262565b9150506126a7565b919050565b60008060006126e3613b53565b6000808061271c67ffffffffffffffff8d16827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613316565b905061272c818c60028d8d613366565b9093509150600083810b1215612743578560011795505b938101936001600489901c811690036127895767ffffffffffffffff811660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff1684525b509481019460006127c567ffffffffffffffff8d167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83613316565b90506127d5818c60038d8d613366565b9093509150600083810b12156127ec578560021795505b938101936002600489901c811690036128355767ffffffffffffffff811660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff1660208501525b5094810194600061285267ffffffffffffffff8d16826001613316565b9050612862818c60008d8d613366565b9093509150600083810b1215612879578560041795505b93810193600488811c811690036128c05767ffffffffffffffff811660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff1660408501525b509481019460006128dd67ffffffffffffffff8d16600183613316565b90506128ed818c60018d8d613366565b9093509150600083810b1215612904578560081795505b938101936008600489901c8116900361294d5767ffffffffffffffff811660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff1660608501525b828701965050505095509550955095915050565b60005b8260200151811015612a1357816000015173ffffffffffffffffffffffffffffffffffffffff16836000015182815181106129a1576129a1614030565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1603612a0157602082015183518051839081106129e1576129e1614030565b60200260200101516020018181516129f99190613f23565b905250505050565b80612a0b8161405f565b915050612964565b5080518251602084015181518110612a2d57612a2d614030565b60200260200101516000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505080602001518260000151836020015181518110612a8a57612a8a614030565b60200260200101516020018181525050816020018051809190612aac9061405f565b9052505050565b6000806000806000612ac9866000015188612517565b60c082015191935091508115612b0357612ae68360a001516126a4565b60048460a0015160ff16901b612afc9190614249565b6000845290505b600087602001516006811115612b1b57612b1b6140e4565b03612c30577f000000000000000000000000000000000000000000000000000000000000000060ff16836060015160ff16141580612ba05750865167ffffffffffffffff1660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff8a169073ffffffffffffffffffffffffffffffffffffffff1614155b15612bd7576000807f00000000000000000000000000000000000000000000000000000000000000009550955095505050506130da565b612c2b8a60405180604001604052808c73ffffffffffffffffffffffffffffffffffffffff1681526020017f0000000000000000000000000000000000000000000000000000000000000000815250612961565b612c90565b8762ffffff16836020015162ffffff1603612c9057606083015160ff1615612c5e5760066020880152612c90565b6000807f00000000000000000000000000000000000000000000000000000000000000009550955095505050506130da565b600080612ca98c8a8c8860400151878a60e00151613574565b915091508a73ffffffffffffffffffffffffffffffffffffffff16896000015167ffffffffffffffff167f17b85ded3fb12432ee427abc34a3026e1fbbb8bc431e3dbe51bc81215655c25c87604001518c60200151604051612d0c929190614371565b60405180910390a3886020015185604001906006811115612d2f57612d2f6140e4565b90816006811115612d4257612d426140e4565b905250600060c0860181905262ffffff8b16602087015285604001516006811115612d6f57612d6f6140e4565b03612dd55760006060860181905260e086018190528086526080860181905260a08601819052895167ffffffffffffffff168152600160205260408120557f00000000000000000000000000000000000000000000000000000000000000009550612efd565b60ff811660a08601527f00000000000000000000000000000000000000000000000000000000000000009750600685604001516006811115612e1957612e196140e4565b148015612e2c5750606085015160ff1615155b15612e555760e08501805160010160ff1690819052600003612e505760ff60e08601525b612e5d565b600160e08601525b600082900b60808601526001606086015262ffffff8a168552600685604001516006811115612e8e57612e8e6140e4565b03612ec957885167ffffffffffffffff16600090815260016020526040902073ffffffffffffffffffffffffffffffffffffffff9055612efd565b885167ffffffffffffffff16600090815260016020526040902073ffffffffffffffffffffffffffffffffffffffff8c1690555b885167ffffffffffffffff1660009081526020818152604091829020875181549289015162ffffff9081166301000000027fffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000009094169116179190911780825591870151879282907fffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffff166601000000000000836006811115612fa057612fa06140e4565b021790555060608201518154608084015160a085015160c086015160e0909601517fffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffff90931667010000000000000060ff958616027fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff16176801000000000000000092851692909202919091177fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff166901000000000000000000918416919091027fffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff16176a010000000000000000000094831694909402939093177fffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff166b010000000000000000000000919093160291909117905550505050505b9450945094915050565b600085600162ffffff821610801590613100575060008460ff16115b1561330c5760006131118885614226565b62ffffff16905080156133035760008660000b600003613151577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613153565b865b905060008160000b128015613169575060ff8816155b15613172575060005b60008160000b1315613254576000816001816131ae8a7f0000000000000000000000000000000000000000000000000000000000000000614358565b6131b89190614249565b6131c29190614358565b6131cc919061438c565b90508060ff168311156131e0578060ff1692505b6131ea82846143ae565b6131f49088614249565b96507f000000000000000000000000000000000000000000000000000000000000000060ff168760ff161115613248577f000000000000000000000000000000000000000000000000000000000000000096505b869450859350506132fd565b60008160000b12156132f657600061326b826143ca565b6001613276846143ca565b613280908a614249565b61328a9190614358565b613294919061438c565b90508060ff168311156132a8578060ff1692505b60006132b3836143ca565b6132bd90856143ae565b90508760ff168160ff1611156132d657600095506132e3565b6132e08189614358565b95505b6132ed848c614408565b945050506132fd565b8593508492505b5061330a565b8492508791505b505b9550959350505050565b60006133288363ffffffff8616614424565b925061333e8263ffffffff602087901c16614424565b915061335e63ffffffff841667ffffffff00000000602085901b16614466565b949350505050565b67ffffffffffffffff8516600090815260208181526040808320815161010081018352815462ffffff8082168352630100000082041694820194909452849384939192918301906601000000000000900460ff1660068111156133cb576133cb6140e4565b60068111156133dc576133dc6140e4565b8152905460ff670100000000000000820481166020840152680100000000000000008204600090810b60408086019190915269010000000000000000008404831660608601526a01000000000000000000008404831660808601526b01000000000000000000000090930490911660a0909301929092528251908301519293509190816006811115613470576134706140e4565b146134ca57856006811115613487576134876140e4565b816006811115613499576134996140e4565b146134c4577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6134c7565b60015b94505b60018262ffffff16101580156134f2575060008160068111156134ef576134ef6140e4565b14155b15613567576000836060015160ff1611801561351757508862ffffff168262ffffff16105b15613551576000613537838560a00151866080015187606001518e6130e4565b5090506135498b85838d8d8d8d6136c8565b945050613567565b6135648a8485606001518c8c8c8c6136c8565b93505b5050509550959350505050565b6000806000806000806135928b600001518b8b8e602001518c6126d6565b935093509350935060008261ffff1611156135da576135da8c60405180604001604052806119f48f6000015167ffffffffffffffff1660009081526001602052604090205490565b60005b60048160ff1610156136b55760008260ff83166004811061360057613600614030565b602002015173ffffffffffffffffffffffffffffffffffffffff16146136a3576136a38d6040518060400160405280858560ff166004811061364457613644614030565b602002015173ffffffffffffffffffffffffffffffffffffffff1681526020018c600f1660ff167f00000000000000000000000000000000000000000000000000000000000000006136969190614212565b611a499060ff8e16614019565b806136ad81614262565b9150506135dd565b50929b919a509098505050505050505050565b600080876060015160ff161180156136e1575060ff8616155b15613712576136f38760a001516126a4565b60048860a0015160ff16901b6137099190614249565b60ff1660c08801525b61371d8460026145a7565b6137288560026145a7565b60c089015160041c16600f16036137a4578660c00151600f168760e00151600c61375291906143ae565b61375c919061438c565b60ff1690508660c00151600f1660048560ff16600261377b91906145b6565b1960048a60c0015160ff16901c60ff161660ff16901b61379b9190614249565b60ff1660c08801525b8160068111156137b6576137b66140e4565b8360068111156137c8576137c86140e4565b146139645760008260068111156137e1576137e16140e4565b03613868578260068111156137f8576137f86140e4565b8760400151600681111561380e5761380e6140e4565b036138315760018760800181815161382691906145c2565b60000b905250613964565b6001876080018181516138449190614601565b60000b90525060a087018051600160ff8781169190911b8118909116169052613964565b82600681111561387a5761387a6140e4565b87604001516006811115613890576138906140e4565b036138c15760a087018051600160ff8781169190911b909117169052608087018051600291906138269083906145c2565b8160068111156138d3576138d36140e4565b876040015160068111156138e9576138e96140e4565b0361391a576000836006811115613902576139026140e4565b14613831576002876080018181516138449190614601565b600083600681111561392e5761392e6140e4565b036139645760018760800181815161394691906145c2565b60000b90525060a087018051600160ff8781169190911b9091171690525b62ffffff808616885260ff8716606089015267ffffffffffffffff8916600090815260208181526040918290208a518154928c015185166301000000027fffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000909316941693909317178083559089015189929182907fffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffff166601000000000000836006811115613a1457613a146140e4565b021790555060608201518154608084015160a085015160c086015160e0909601517fffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffff90931667010000000000000060ff958616027fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff16176801000000000000000092851692909202919091177fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff166901000000000000000000918416919091027fffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff16176a010000000000000000000094831694909402939093177fffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff166b0100000000000000000000009190931602919091179055979650505050505050565b60405180608001604052806004906020820280368337509192915050565b600060208284031215613b8357600080fd5b5035919050565b80357fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000811681146126d157600080fd5b600060a08284031215613bcc57600080fd5b50919050565b73ffffffffffffffffffffffffffffffffffffffff81168114613bf457600080fd5b50565b6000806000806101008587031215613c0e57600080fd5b613c1785613b8a565b935060208501359250613c2d8660408701613bba565b915060e0850135613c3d81613bd2565b939692955090935050565b803567ffffffffffffffff811681146126d157600080fd5b600060208284031215613c7257600080fd5b613c7b82613c48565b9392505050565b60008083601f840112613c9457600080fd5b50813567ffffffffffffffff811115613cac57600080fd5b6020830191508360208260061b8501011115613cc757600080fd5b9250929050565b600080600080600060808688031215613ce657600080fd5b8535613cf181613bd2565b945060208601359350604086013567ffffffffffffffff811115613d1457600080fd5b613d2088828901613c82565b9094509250613d33905060608701613b8a565b90509295509295909350565b60008060208385031215613d5257600080fd5b823567ffffffffffffffff80821115613d6a57600080fd5b818501915085601f830112613d7e57600080fd5b813581811115613d8d57600080fd5b8660208260051b8501011115613da257600080fd5b60209290920196919550909350505050565b60008060408385031215613dc757600080fd5b613dd083613b8a565b91506020830135613de081613bd2565b809150509250929050565b8015158114613bf457600080fd5b600080600080600080600060c0888a031215613e1457600080fd5b8735613e1f81613bd2565b965060208801359550604088013567ffffffffffffffff811115613e4257600080fd5b613e4e8a828b01613c82565b9096509450613e61905060608901613b8a565b92506080880135613e7181613deb565b915060a0880135613e8181613bd2565b8091505092959891949750929550565b60008060c08385031215613ea457600080fd5b82359150613eb58460208501613bba565b90509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115613f0057613f00613ebe565b92915050565b600060208284031215613f1857600080fd5b8151613c7b81613deb565b80820180821115613f0057613f00613ebe565b600060208284031215613f4857600080fd5b813560ff81168114613c7b57600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8035600781106126d157600080fd5b600060408284031215613fa957600080fd5b6040516040810181811067ffffffffffffffff82111715613ff3577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604052613fff83613c48565b815261400d60208401613f88565b60208201529392505050565b8082028115828204841417613f0057613f00613ebe565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361409057614090613ebe565b5060010190565b60208082528181018390526000908460408401835b868110156140d95767ffffffffffffffff6140c684613c48565b16825291830191908301906001016140ac565b509695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6007811061414a577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9052565b6060808252810184905260008560808301825b878110156141ac5767ffffffffffffffff61417b84613c48565b168252602061418b818501613f88565b61419782850182614113565b50506040928301929190910190600101614161565b507fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000095909516602084015250506040015292915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082614221576142216141e3565b500490565b62ffffff82811682821603908082111561424257614242613ebe565b5092915050565b60ff8181168382160190811115613f0057613f00613ebe565b600060ff821660ff810361427857614278613ebe565b60010192915050565b600081518084526020808501945080840160005b838110156142d0578151805167ffffffffffffffff1688528301516142bc84890182614113565b506040969096019590820190600101614295565b509495945050505050565b8381526060602082015260006142f46060830185614281565b90507fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000083166040830152949350505050565b82815260406020820152600061335e6040830184614281565b60006020828403121561435157600080fd5b5051919050565b60ff8281168282160390811115613f0057613f00613ebe565b6040810161437f8285614113565b613c7b6020830184614113565b600060ff83168061439f5761439f6141e3565b8060ff84160491505092915050565b60ff818116838216029081169081811461424257614242613ebe565b60008160000b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8081036143ff576143ff613ebe565b60000392915050565b62ffffff81811683821601908082111561424257614242613ebe565b600381810b9083900b01637fffffff81137fffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000000082121715613f0057613f00613ebe565b67ffffffffffffffff81811683821601908082111561424257614242613ebe565b600181815b808511156144e057817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211156144c6576144c6613ebe565b808516156144d357918102915b93841c939080029061448c565b509250929050565b6000826144f757506001613f00565b8161450457506000613f00565b816001811461451a576002811461452457614540565b6001915050613f00565b60ff84111561453557614535613ebe565b50506001821b613f00565b5060208310610133831016604e8410600b8410161715614563575081810a613f00565b61456d8383614487565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0482111561459f5761459f613ebe565b029392505050565b6000613c7b60ff8416836144e8565b6000613c7b83836144e8565b600082810b9082900b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808112607f82131715613f0057613f00613ebe565b600081810b9083900b01607f81137fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8082121715613f0057613f00613ebe56fea2646970667358221220a2fbfc839a10b41cefeaefd9d8c40e742644eed908297fa4c1f7dd7ad6458e6c64736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436106100b15760003560e01c80638b8fc3a111610069578063afa1e2d11161004e578063afa1e2d114610173578063d401978314610188578063d67101121461019b57600080fd5b80638b8fc3a114610140578063ae37a62d1461016057600080fd5b80631fdd8a691161009a5780631fdd8a69146100eb5780634dd3ab2314610100578063599a71c61461012057600080fd5b80630a8bcdb9146100b657806310837a39146100d8575b600080fd5b3480156100c257600080fd5b506100d66100d1366004613b71565b6101bb565b005b6100d66100e6366004613bf7565b6103f4565b3480156100f757600080fd5b506100d66106a2565b34801561010c57600080fd5b506100d661011b366004613c60565b6108d2565b34801561012c57600080fd5b506100d661013b366004613cce565b6109d7565b34801561014c57600080fd5b506100d661015b366004613d3f565b610d32565b6100d661016e366004613db4565b610e75565b34801561017f57600080fd5b506100d6610ef5565b6100d6610196366004613df9565b611004565b3480156101a757600080fd5b506100d66101b6366004613e91565b61138d565b33600090815260036020526040812090806101d46115c4565b845491935091507801000000000000000000000000000000000000000000000000900462ffffff161580159061023757508015806102375750825462ffffff83811678010000000000000000000000000000000000000000000000009092041614155b1561026e576040517f0aafb74c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b336000908152600260205260409020546001850161028f57935060006102e5565b848110156102d8576040517f78fe52a600000000000000000000000000000000000000000000000000000000815260048101829052602481018690526044015b60405180910390fd5b6102e28582613eed565b90505b3360008181526002602052604090819020839055517fa9059cbb00000000000000000000000000000000000000000000000000000000815260048101919091526024810186905273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303816000875af115801561038c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103b09190613f06565b50604080518681526020810183905233917ff7aeb382a1e87f84aa69637a22868c2e12be1261273f04cdf40a262a8b89003191015b60405180910390a25050505050565b3360009081526002602052604090205461040e8482613f23565b33600081815260026020526040902082905590915061042e90868361170f565b82351561053b5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663d505accf33308635602088013561048a60608a0160408b01613f36565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b16815273ffffffffffffffffffffffffffffffffffffffff95861660048201529490931660248501526044840191909152606483015260ff166084820152606086013560a4820152608086013560c482015260e401600060405180830381600087803b15801561052257600080fd5b505af1158015610536573d6000803e3d6000fd5b505050505b831561063b576040517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018590527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906323b872dd906064016020604051808303816000875af11580156105da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105fe9190613f06565b50604080518581526020810183905233917f9705a8ff16374359785d31b0f1862c27f983645496f40760d180a9830eeaf2e8910160405180910390a25b73ffffffffffffffffffffffffffffffffffffffff82161561069b5760405173ffffffffffffffffffffffffffffffffffffffff8316903480156108fc02916000818181858888f19350505050158015610699573d6000803e3d6000fd5b505b5050505050565b336000908152600360205260408120906106ba6115c4565b5082549091507801000000000000000000000000000000000000000000000000900462ffffff1660000361071a576040517f6599c9aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b815462ffffff80831678010000000000000000000000000000000000000000000000009092041603610778576040517f175868d700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81547fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff168255336000908152600260205260408082208054929055517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303816000875af1158015610866573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061088a9190613f06565b50604080518281526000602082015262ffffff84169133917f6337d70daadadd11f8be7f6e7b38e6c04d28710b1f2a2894bb14d8e3eaa8cdb6910160405180910390a3505050565b60006108dc6115c4565b50905060006040518060400160405280600567ffffffffffffffff81111561090657610906613f59565b60405190808252806020026020018201604052801561094b57816020015b60408051808201909152600080825260208201528152602001906001900390816109245790505b50815260200160008152509050610963818484611955565b61098d7f000000000000000000000000000000000000000000000000000000000000000082611d17565b60405167ffffffffffffffff8416815262ffffff8316907f9987a1be5559dc397dbe41aa886352a4124ac12037da7d0f28631c1c67e0ae55906020015b60405180910390a2505050565b73ffffffffffffffffffffffffffffffffffffffff8516600090815260036020526040812090610a056115c4565b5082549091507801000000000000000000000000000000000000000000000000900462ffffff161580610a5c5750815462ffffff828116780100000000000000000000000000000000000000000000000090920416145b15610a93576040517f175868d700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81546040805160208088028201810183528782528793610af4931b918a918a908690819060009085015b82821015610ae957610ada60408302860136819003810190613f97565b81526020019060010190610abd565b505050505087611e1a565b7fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000841615610b875760208114610b56576040517fcc586b4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82547fffffffffffffffff00000000000000000000000000000000000000000000000016604085901c178355610bae565b82547fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff1683555b33600090815260026020526040812080548792839291610bcf908490613eed565b90915550506040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303816000875af1158015610c89573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cad9190613f06565b50604080518281527fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008716602082015262ffffff85169173ffffffffffffffffffffffffffffffffffffffff8c16917f6337d70daadadd11f8be7f6e7b38e6c04d28710b1f2a2894bb14d8e3eaa8cdb6910160405180910390a3505050505050505050565b6000610d3c6115c4565b5060408051808201909152909150829060009080610d5b846005614019565b67ffffffffffffffff811115610d7357610d73613f59565b604051908082528060200260200182016040528015610db857816020015b6040805180820190915260008082526020820152815260200190600190039081610d915790505b5081526020016000815250905060005b82811015610e1357610e0182878784818110610de657610de6614030565b9050602002016020810190610dfb9190613c60565b86611955565b80610e0b8161405f565b915050610dc8565b50610e3e7f000000000000000000000000000000000000000000000000000000000000000082611d17565b8262ffffff167ff4b03f4527c0ed32b6739e04de71d601db894eb6c1bcd17bb34a184bb9536c6686866040516103e5929190614097565b33600081815260026020526040902054610e919190849061170f565b73ffffffffffffffffffffffffffffffffffffffff811615610ef15760405173ffffffffffffffffffffffffffffffffffffffff8216903480156108fc02916000818181858888f19350505050158015610eef573d6000803e3d6000fd5b505b5050565b3360009081526003602052604081209080610f0e6115c4565b9150915080610f49576040517fdc12c97300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825462ffffff83811678010000000000000000000000000000000000000000000000009092041614610fa7576040517f0aafb74c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82547fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff16835560405162ffffff83169033907f619ef9650648da30c9647d0b77a0de24a51da0630c3533d54cc1eb3d798e1eaa90600090a3505050565b73ffffffffffffffffffffffffffffffffffffffff8716600090815260036020526040812090806110336115c4565b91509150801561106f576040517f24f7f40f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82547801000000000000000000000000000000000000000000000000900462ffffff166000036110cb576040517f6599c9aa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825462ffffff83811678010000000000000000000000000000000000000000000000009092041614611129576040517fd5b25b6300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8254604080516020808b028201810183528a825261118b9390921b918c91908c908c90819060009085015b828210156111805761117160408302860136819003810190613f97565b81526020019060010190611154565b505050505089611e1a565b60006111f78b848b8b808060200260200160405190810160405280939291908181526020016000905b828210156111e0576111d160408302860136819003810190613f97565b815260200190600101906111b4565b5050505050896111f0578e611f48565b6000611f48565b845490915060401b7fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008816156112925760208914611261576040517fcc586b4500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b84547fffffffffffffffff00000000000000000000000000000000000000000000000016604089901c1785556112b9565b84547fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff1685555b8067ffffffffffffffff19168462ffffff168d73ffffffffffffffffffffffffffffffffffffffff167ffab312c5020dc7093e590463878dbfd0567314a7c155b164a60430ebcc7b38038d8d8d88604051611317949392919061414e565b60405180910390a473ffffffffffffffffffffffffffffffffffffffff86161561137f5760405173ffffffffffffffffffffffffffffffffffffffff8716903480156108fc02916000818181858888f1935050505015801561137d573d6000803e3d6000fd5b505b505050505050505050505050565b8115610ef157336000908152600260205260409020546113ad8382613f23565b33600090815260026020526040902081905590508135156114ce5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663d505accf33308535602087013561141d6060890160408a01613f36565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b16815273ffffffffffffffffffffffffffffffffffffffff95861660048201529490931660248501526044840191909152606483015260ff166084820152606085013560a4820152608085013560c482015260e401600060405180830381600087803b1580156114b557600080fd5b505af11580156114c9573d6000803e3d6000fd5b505050505b6040517f23b872dd000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906323b872dd906064016020604051808303816000875af1158015611567573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061158b9190613f06565b50604080518481526020810183905233917f9705a8ff16374359785d31b0f1862c27f983645496f40760d180a9830eeaf2e891016109ca565b600080806116127f00000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000000613f23565b9050600061161e612441565b90507f000000000000000000000000000000000000000000000000000000000000000081101561167a576040517f3a5f7b5700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006116a67f000000000000000000000000000000000000000000000000000000000000000083613eed565b90506116b28382614212565b6116bd906002613f23565b94507f0000000000000000000000000000000000000000000000000000000000000000836116ec600288614226565b62ffffff166116fb9190614019565b6117059083613eed565b1093505050509091565b73ffffffffffffffffffffffffffffffffffffffff83166000908152600360205260408120908061173e6115c4565b9150915080611779576040517fdc12c97300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82547801000000000000000000000000000000000000000000000000900462ffffff16158015906117cf5750825462ffffff83811678010000000000000000000000000000000000000000000000009092041614155b15611806576040517f0aafb74c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b825462ffffff83167801000000000000000000000000000000000000000000000000027fffffffffff000000000000000000000000000000000000000000000000000000909116604087901c171783557f00000000000000000000000000000000000000000000000000000000000000008410156118d9576040517f78fe52a6000000000000000000000000000000000000000000000000000000008152600481018590527f000000000000000000000000000000000000000000000000000000000000000060248201526044016102cf565b6040517fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008616815262ffffff83169073ffffffffffffffffffffffffffffffffffffffff8816907fe3c45ded79e3db74b160b9a697d75f465f68d287a678532ed0a9fb691553b93d9060200160405180910390a3505050505050565b6000806119628484612517565b60c08201519193509150811561199c5761197f8360a001516126a4565b60048460a0015160ff16901b6119959190614249565b6000845290505b6000806119b4878787604001518860400151876126d6565b9094509250505061ffff821615611a5057611a508860405180604001604052806119f48b67ffffffffffffffff1660009081526001602052604090205490565b73ffffffffffffffffffffffffffffffffffffffff168152602001600c611a3f7f000000000000000000000000000000000000000000000000000000000000000061ffff8916614019565b611a499190614212565b9052612961565b60005b60048160ff161015611b305760008260ff831660048110611a7657611a76614030565b602002015173ffffffffffffffffffffffffffffffffffffffff1614611b1e57611b1e896040518060400160405280858560ff1660048110611aba57611aba614030565b602002015173ffffffffffffffffffffffffffffffffffffffff16815260200187600f1660ff167f0000000000000000000000000000000000000000000000000000000000000000611b0c9190614212565b8a60e0015160ff16611a499190614019565b80611b2881614262565b915050611a53565b50600060c0860181905267ffffffffffffffff881681526020818152604091829020875181549289015162ffffff9081166301000000027fffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000009094169116179190911780825591870151879282907fffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffff166601000000000000836006811115611bd957611bd96140e4565b021790555060608201518154608084015160a085015160c086015160e0909601517fffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffff90931667010000000000000060ff958616027fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff16176801000000000000000092851692909202919091177fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff166901000000000000000000918416919091027fffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff16176a010000000000000000000094831694909402939093177fffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff166b01000000000000000000000091909316029190911790555050505050505050565b60005b8160200151811015610eef578273ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83600001518381518110611d5857611d58614030565b60200260200101516000015184600001518481518110611d7a57611d7a614030565b6020026020010151602001516040518363ffffffff1660e01b8152600401611dc492919073ffffffffffffffffffffffffffffffffffffffff929092168252602082015260400190565b6020604051808303816000875af1158015611de3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e079190613f06565b5080611e128161405f565b915050611d1a565b7fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000811615611ec6576000838383604051602001611e59939291906142db565b6040516020818303038152906040528051906020012090508067ffffffffffffffff19168567ffffffffffffffff191614611ec0576040517fd13415b500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50611f42565b60008383604051602001611edb929190614326565b6040516020818303038152906040528051906020012090508067ffffffffffffffff19168567ffffffffffffffff19161461069b576040517fd13415b500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505050565b600080604051806040016040528085516005611f649190614019565b67ffffffffffffffff811115611f7c57611f7c613f59565b604051908082528060200260200182016040528015611fc157816020015b6040805180820190915260008082526020820152815260200190600190039081611f9a5790505b50815260200160008152509050611ff260405180606001604052806000815260200160008152602001600081525090565b60005b8551811015612089576000806000612028868c8c8c888151811061201b5761201b614030565b6020026020010151612ab3565b92509250925082856000018181516120409190613f23565b905250602085018051839190612057908390613f23565b90525060408501805182919061206e908390613f23565b905250839250612081915082905061405f565b915050611ff5565b506120b47f000000000000000000000000000000000000000000000000000000000000000083611d17565b73ffffffffffffffffffffffffffffffffffffffff87166000908152600260209081526040909120549082015182519194506120ef91613f23565b8310156121435760208101518151849161210891613f23565b6040517f78fe52a6000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044016102cf565b73ffffffffffffffffffffffffffffffffffffffff84166121a8576020810151815161216f9190613f23565b6121799084613eed565b73ffffffffffffffffffffffffffffffffffffffff88166000908152600260205260409020819055925061236a565b8051156122755780516040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff868116600483015230602483015260448201929092527f0000000000000000000000000000000000000000000000000000000000000000909116906323b872dd906064016020604051808303816000875af115801561224f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122739190613f06565b505b60208101511561236a5760208101516040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301527f00000000000000000000000000000000000000000000000000000000000000008116602483015260448201929092527f0000000000000000000000000000000000000000000000000000000000000000909116906323b872dd906064016020604051808303816000875af1158015612344573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123689190613f06565b505b6040810151156124375760408181015190517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff898116600483015260248201929092527f00000000000000000000000000000000000000000000000000000000000000009091169063a9059cbb906044016020604051808303816000875af1158015612411573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124359190613f06565b505b5050949350505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661248357504290565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663b80777ea6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156124ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612512919061433f565b905090565b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e081019190915267ffffffffffffffff8316600090815260208181526040808320815161010081018352815462ffffff80821683526301000000820416948201949094529290918301906601000000000000900460ff1660068111156125b9576125b96140e4565b60068111156125ca576125ca6140e4565b8152905460ff67010000000000000082048116602084015268010000000000000000820460000b60408401526901000000000000000000820481166060808501919091526a0100000000000000000000830482166080808601919091526b01000000000000000000000090930490911660a0909301929092528251908301519183015192945091600162ffffff84161080159061266a575060008160ff16115b1561269a576000612682848760a0015185858b6130e4565b5060ff166060870181905262ffffff88168752159450505b5050509250929050565b60005b60ff8216156126d1576126bb600183614358565b90911690806126c981614262565b9150506126a7565b919050565b60008060006126e3613b53565b6000808061271c67ffffffffffffffff8d16827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613316565b905061272c818c60028d8d613366565b9093509150600083810b1215612743578560011795505b938101936001600489901c811690036127895767ffffffffffffffff811660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff1684525b509481019460006127c567ffffffffffffffff8d167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83613316565b90506127d5818c60038d8d613366565b9093509150600083810b12156127ec578560021795505b938101936002600489901c811690036128355767ffffffffffffffff811660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff1660208501525b5094810194600061285267ffffffffffffffff8d16826001613316565b9050612862818c60008d8d613366565b9093509150600083810b1215612879578560041795505b93810193600488811c811690036128c05767ffffffffffffffff811660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff1660408501525b509481019460006128dd67ffffffffffffffff8d16600183613316565b90506128ed818c60018d8d613366565b9093509150600083810b1215612904578560081795505b938101936008600489901c8116900361294d5767ffffffffffffffff811660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff1660608501525b828701965050505095509550955095915050565b60005b8260200151811015612a1357816000015173ffffffffffffffffffffffffffffffffffffffff16836000015182815181106129a1576129a1614030565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1603612a0157602082015183518051839081106129e1576129e1614030565b60200260200101516020018181516129f99190613f23565b905250505050565b80612a0b8161405f565b915050612964565b5080518251602084015181518110612a2d57612a2d614030565b60200260200101516000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505080602001518260000151836020015181518110612a8a57612a8a614030565b60200260200101516020018181525050816020018051809190612aac9061405f565b9052505050565b6000806000806000612ac9866000015188612517565b60c082015191935091508115612b0357612ae68360a001516126a4565b60048460a0015160ff16901b612afc9190614249565b6000845290505b600087602001516006811115612b1b57612b1b6140e4565b03612c30577f000000000000000000000000000000000000000000000000000000000000000060ff16836060015160ff16141580612ba05750865167ffffffffffffffff1660009081526001602052604090205473ffffffffffffffffffffffffffffffffffffffff8a169073ffffffffffffffffffffffffffffffffffffffff1614155b15612bd7576000807f00000000000000000000000000000000000000000000000000000000000000009550955095505050506130da565b612c2b8a60405180604001604052808c73ffffffffffffffffffffffffffffffffffffffff1681526020017f0000000000000000000000000000000000000000000000000000000000000000815250612961565b612c90565b8762ffffff16836020015162ffffff1603612c9057606083015160ff1615612c5e5760066020880152612c90565b6000807f00000000000000000000000000000000000000000000000000000000000000009550955095505050506130da565b600080612ca98c8a8c8860400151878a60e00151613574565b915091508a73ffffffffffffffffffffffffffffffffffffffff16896000015167ffffffffffffffff167f17b85ded3fb12432ee427abc34a3026e1fbbb8bc431e3dbe51bc81215655c25c87604001518c60200151604051612d0c929190614371565b60405180910390a3886020015185604001906006811115612d2f57612d2f6140e4565b90816006811115612d4257612d426140e4565b905250600060c0860181905262ffffff8b16602087015285604001516006811115612d6f57612d6f6140e4565b03612dd55760006060860181905260e086018190528086526080860181905260a08601819052895167ffffffffffffffff168152600160205260408120557f00000000000000000000000000000000000000000000000000000000000000009550612efd565b60ff811660a08601527f00000000000000000000000000000000000000000000000000000000000000009750600685604001516006811115612e1957612e196140e4565b148015612e2c5750606085015160ff1615155b15612e555760e08501805160010160ff1690819052600003612e505760ff60e08601525b612e5d565b600160e08601525b600082900b60808601526001606086015262ffffff8a168552600685604001516006811115612e8e57612e8e6140e4565b03612ec957885167ffffffffffffffff16600090815260016020526040902073ffffffffffffffffffffffffffffffffffffffff9055612efd565b885167ffffffffffffffff16600090815260016020526040902073ffffffffffffffffffffffffffffffffffffffff8c1690555b885167ffffffffffffffff1660009081526020818152604091829020875181549289015162ffffff9081166301000000027fffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000009094169116179190911780825591870151879282907fffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffff166601000000000000836006811115612fa057612fa06140e4565b021790555060608201518154608084015160a085015160c086015160e0909601517fffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffff90931667010000000000000060ff958616027fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff16176801000000000000000092851692909202919091177fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff166901000000000000000000918416919091027fffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff16176a010000000000000000000094831694909402939093177fffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff166b010000000000000000000000919093160291909117905550505050505b9450945094915050565b600085600162ffffff821610801590613100575060008460ff16115b1561330c5760006131118885614226565b62ffffff16905080156133035760008660000b600003613151577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613153565b865b905060008160000b128015613169575060ff8816155b15613172575060005b60008160000b1315613254576000816001816131ae8a7f0000000000000000000000000000000000000000000000000000000000000000614358565b6131b89190614249565b6131c29190614358565b6131cc919061438c565b90508060ff168311156131e0578060ff1692505b6131ea82846143ae565b6131f49088614249565b96507f000000000000000000000000000000000000000000000000000000000000000060ff168760ff161115613248577f000000000000000000000000000000000000000000000000000000000000000096505b869450859350506132fd565b60008160000b12156132f657600061326b826143ca565b6001613276846143ca565b613280908a614249565b61328a9190614358565b613294919061438c565b90508060ff168311156132a8578060ff1692505b60006132b3836143ca565b6132bd90856143ae565b90508760ff168160ff1611156132d657600095506132e3565b6132e08189614358565b95505b6132ed848c614408565b945050506132fd565b8593508492505b5061330a565b8492508791505b505b9550959350505050565b60006133288363ffffffff8616614424565b925061333e8263ffffffff602087901c16614424565b915061335e63ffffffff841667ffffffff00000000602085901b16614466565b949350505050565b67ffffffffffffffff8516600090815260208181526040808320815161010081018352815462ffffff8082168352630100000082041694820194909452849384939192918301906601000000000000900460ff1660068111156133cb576133cb6140e4565b60068111156133dc576133dc6140e4565b8152905460ff670100000000000000820481166020840152680100000000000000008204600090810b60408086019190915269010000000000000000008404831660608601526a01000000000000000000008404831660808601526b01000000000000000000000090930490911660a0909301929092528251908301519293509190816006811115613470576134706140e4565b146134ca57856006811115613487576134876140e4565b816006811115613499576134996140e4565b146134c4577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6134c7565b60015b94505b60018262ffffff16101580156134f2575060008160068111156134ef576134ef6140e4565b14155b15613567576000836060015160ff1611801561351757508862ffffff168262ffffff16105b15613551576000613537838560a00151866080015187606001518e6130e4565b5090506135498b85838d8d8d8d6136c8565b945050613567565b6135648a8485606001518c8c8c8c6136c8565b93505b5050509550959350505050565b6000806000806000806135928b600001518b8b8e602001518c6126d6565b935093509350935060008261ffff1611156135da576135da8c60405180604001604052806119f48f6000015167ffffffffffffffff1660009081526001602052604090205490565b60005b60048160ff1610156136b55760008260ff83166004811061360057613600614030565b602002015173ffffffffffffffffffffffffffffffffffffffff16146136a3576136a38d6040518060400160405280858560ff166004811061364457613644614030565b602002015173ffffffffffffffffffffffffffffffffffffffff1681526020018c600f1660ff167f00000000000000000000000000000000000000000000000000000000000000006136969190614212565b611a499060ff8e16614019565b806136ad81614262565b9150506135dd565b50929b919a509098505050505050505050565b600080876060015160ff161180156136e1575060ff8616155b15613712576136f38760a001516126a4565b60048860a0015160ff16901b6137099190614249565b60ff1660c08801525b61371d8460026145a7565b6137288560026145a7565b60c089015160041c16600f16036137a4578660c00151600f168760e00151600c61375291906143ae565b61375c919061438c565b60ff1690508660c00151600f1660048560ff16600261377b91906145b6565b1960048a60c0015160ff16901c60ff161660ff16901b61379b9190614249565b60ff1660c08801525b8160068111156137b6576137b66140e4565b8360068111156137c8576137c86140e4565b146139645760008260068111156137e1576137e16140e4565b03613868578260068111156137f8576137f86140e4565b8760400151600681111561380e5761380e6140e4565b036138315760018760800181815161382691906145c2565b60000b905250613964565b6001876080018181516138449190614601565b60000b90525060a087018051600160ff8781169190911b8118909116169052613964565b82600681111561387a5761387a6140e4565b87604001516006811115613890576138906140e4565b036138c15760a087018051600160ff8781169190911b909117169052608087018051600291906138269083906145c2565b8160068111156138d3576138d36140e4565b876040015160068111156138e9576138e96140e4565b0361391a576000836006811115613902576139026140e4565b14613831576002876080018181516138449190614601565b600083600681111561392e5761392e6140e4565b036139645760018760800181815161394691906145c2565b60000b90525060a087018051600160ff8781169190911b9091171690525b62ffffff808616885260ff8716606089015267ffffffffffffffff8916600090815260208181526040918290208a518154928c015185166301000000027fffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000909316941693909317178083559089015189929182907fffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffff166601000000000000836006811115613a1457613a146140e4565b021790555060608201518154608084015160a085015160c086015160e0909601517fffffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffff90931667010000000000000060ff958616027fffffffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffff16176801000000000000000092851692909202919091177fffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffffff166901000000000000000000918416919091027fffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff16176a010000000000000000000094831694909402939093177fffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff166b0100000000000000000000009190931602919091179055979650505050505050565b60405180608001604052806004906020820280368337509192915050565b600060208284031215613b8357600080fd5b5035919050565b80357fffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000811681146126d157600080fd5b600060a08284031215613bcc57600080fd5b50919050565b73ffffffffffffffffffffffffffffffffffffffff81168114613bf457600080fd5b50565b6000806000806101008587031215613c0e57600080fd5b613c1785613b8a565b935060208501359250613c2d8660408701613bba565b915060e0850135613c3d81613bd2565b939692955090935050565b803567ffffffffffffffff811681146126d157600080fd5b600060208284031215613c7257600080fd5b613c7b82613c48565b9392505050565b60008083601f840112613c9457600080fd5b50813567ffffffffffffffff811115613cac57600080fd5b6020830191508360208260061b8501011115613cc757600080fd5b9250929050565b600080600080600060808688031215613ce657600080fd5b8535613cf181613bd2565b945060208601359350604086013567ffffffffffffffff811115613d1457600080fd5b613d2088828901613c82565b9094509250613d33905060608701613b8a565b90509295509295909350565b60008060208385031215613d5257600080fd5b823567ffffffffffffffff80821115613d6a57600080fd5b818501915085601f830112613d7e57600080fd5b813581811115613d8d57600080fd5b8660208260051b8501011115613da257600080fd5b60209290920196919550909350505050565b60008060408385031215613dc757600080fd5b613dd083613b8a565b91506020830135613de081613bd2565b809150509250929050565b8015158114613bf457600080fd5b600080600080600080600060c0888a031215613e1457600080fd5b8735613e1f81613bd2565b965060208801359550604088013567ffffffffffffffff811115613e4257600080fd5b613e4e8a828b01613c82565b9096509450613e61905060608901613b8a565b92506080880135613e7181613deb565b915060a0880135613e8181613bd2565b8091505092959891949750929550565b60008060c08385031215613ea457600080fd5b82359150613eb58460208501613bba565b90509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115613f0057613f00613ebe565b92915050565b600060208284031215613f1857600080fd5b8151613c7b81613deb565b80820180821115613f0057613f00613ebe565b600060208284031215613f4857600080fd5b813560ff81168114613c7b57600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b8035600781106126d157600080fd5b600060408284031215613fa957600080fd5b6040516040810181811067ffffffffffffffff82111715613ff3577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604052613fff83613c48565b815261400d60208401613f88565b60208201529392505050565b8082028115828204841417613f0057613f00613ebe565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361409057614090613ebe565b5060010190565b60208082528181018390526000908460408401835b868110156140d95767ffffffffffffffff6140c684613c48565b16825291830191908301906001016140ac565b509695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6007811061414a577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9052565b6060808252810184905260008560808301825b878110156141ac5767ffffffffffffffff61417b84613c48565b168252602061418b818501613f88565b61419782850182614113565b50506040928301929190910190600101614161565b507fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000095909516602084015250506040015292915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082614221576142216141e3565b500490565b62ffffff82811682821603908082111561424257614242613ebe565b5092915050565b60ff8181168382160190811115613f0057613f00613ebe565b600060ff821660ff810361427857614278613ebe565b60010192915050565b600081518084526020808501945080840160005b838110156142d0578151805167ffffffffffffffff1688528301516142bc84890182614113565b506040969096019590820190600101614295565b509495945050505050565b8381526060602082015260006142f46060830185614281565b90507fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000083166040830152949350505050565b82815260406020820152600061335e6040830184614281565b60006020828403121561435157600080fd5b5051919050565b60ff8281168282160390811115613f0057613f00613ebe565b6040810161437f8285614113565b613c7b6020830184614113565b600060ff83168061439f5761439f6141e3565b8060ff84160491505092915050565b60ff818116838216029081169081811461424257614242613ebe565b60008160000b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8081036143ff576143ff613ebe565b60000392915050565b62ffffff81811683821601908082111561424257614242613ebe565b600381810b9083900b01637fffffff81137fffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000000082121715613f0057613f00613ebe565b67ffffffffffffffff81811683821601908082111561424257614242613ebe565b600181815b808511156144e057817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211156144c6576144c6613ebe565b808516156144d357918102915b93841c939080029061448c565b509250929050565b6000826144f757506001613f00565b8161450457506000613f00565b816001811461451a576002811461452457614540565b6001915050613f00565b60ff84111561453557614535613ebe565b50506001821b613f00565b5060208310610133831016604e8410600b8410161715614563575081810a613f00565b61456d8383614487565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0482111561459f5761459f613ebe565b029392505050565b6000613c7b60ff8416836144e8565b6000613c7b83836144e8565b600082810b9082900b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808112607f82131715613f0057613f00613ebe565b600081810b9083900b01607f81137fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8082121715613f0057613f00613ebe56fea2646970667358221220a2fbfc839a10b41cefeaefd9d8c40e742644eed908297fa4c1f7dd7ad6458e6c64736f6c63430008140033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "errors": {
      "ReserveTooLow(uint256,uint256)": [
        {
          "params": {
            "expected": "amount required to proceed",
            "inReserve": "amount in reserver as the time of the call"
          }
        }
      ]
    },
    "events": {
      "CommitmentCancelled(address,uint24)": {
        "params": {
          "epoch": "epoch number on which this commit belongs to",
          "player": "account taking the staking risk (can be a different account than the one controlling the gems)"
        }
      },
      "CommitmentMade(address,uint24,bytes24)": {
        "params": {
          "commitmentHash": "the hash of moves",
          "epoch": "epoch number on which this commit belongs to",
          "player": "account taking the staking risk (can be a different account than the one controlling the gems)"
        }
      },
      "CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)": {
        "params": {
          "commitmentHash": "the hash of the moves",
          "epoch": "epoch number on which this commit belongs to",
          "furtherMoves": "hash of further moves, unless bytes32(0) which indicate end.",
          "moves": "the moves",
          "player": "account who commited"
        }
      },
      "CommitmentVoid(address,uint24,uint256,bytes24)": {
        "params": {
          "amountBurnt": "amount of token to burn",
          "epoch": "epoch number on which this commit belongs to",
          "furtherMoves": "hash of further moves, unless bytes32(0) which indicate end.",
          "player": "the account that made the commitment"
        }
      },
      "MoveProcessed(uint64,address,uint8,uint8)": {
        "params": {
          "newColor": "color that takes over",
          "oldColor": "previous color of the cell",
          "player": "account making the move",
          "position": "cell at which the move take place"
        }
      },
      "MultiPoke(uint24,uint64[])": {
        "params": {
          "epoch": "epoch number at which the poke take place",
          "positions": "cells to poke"
        }
      },
      "ReserveDeposited(address,uint256,uint256)": {
        "params": {
          "amountDeposited": "the number of tokens deposited",
          "newAmount": "the number of tokens in reserver as a result",
          "player": "account receiving the token in the reserve"
        }
      },
      "ReserveWithdrawn(address,uint256,uint256)": {
        "params": {
          "amountWithdrawn": "the number of tokens withdrawnn",
          "newAmount": "the number of tokens in reserver as a result",
          "player": "account withdrawing the tokens"
        }
      },
      "SinglePoke(uint24,uint64)": {
        "params": {
          "epoch": "epoch number at which the poke take place",
          "position": "cell to poke"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)": {
        "params": {
          "furtherMoves": "if moves cannot be contained in one tx, further moves are represented by a hash to reveal too",
          "moves": "the actual moves",
          "player": "the account who committed the move",
          "secret": "the secret used to make the commit"
        }
      },
      "addToReserve(uint256,(uint256,uint256,uint8,bytes32,bytes32))": {
        "params": {
          "permit": "permit EIP2612, .value = zero if not needed",
          "tokensAmountToAdd": "amount of tokens to add"
        }
      },
      "makeCommitment(bytes24,address)": {
        "params": {
          "commitmentHash": "the hash of the moves",
          "payee": "address to send ETH to along the commitment. Can be used to pay for reveal"
        }
      },
      "makeCommitmentWithExtraReserve(bytes24,uint256,(uint256,uint256,uint8,bytes32,bytes32),address)": {
        "params": {
          "commitmentHash": "the has of the moves",
          "payee": "address to send ETH to along the commitment. Can be used to pay for reveal",
          "permit": "permit EIP2612, value = zero if not needed",
          "tokensAmountToAdd": "amount of tokens to add to the reserve. the resulting total must be enough to cover the moves"
        }
      },
      "poke(uint64)": {
        "params": {
          "position": "the cell position"
        }
      },
      "pokeMultiple(uint64[])": {
        "params": {
          "positions": "cell positions to collect from"
        }
      },
      "reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)": {
        "params": {
          "furtherMoves": "if moves cannot be contained in one tx, further moves are represented by a hash to reveal too  Note that you have to that have enough moves (specified by MAX_NUM_MOVES_PER_HASH = 32)",
          "moves": "the actual moves",
          "payee": "address to send ETH to along the reveal",
          "player": "the account who committed the move",
          "secret": "the secret used to make the commit",
          "useReserve": "whether the tokens are taken from the reserve or from approvals.  This allow player to keep their reserve intact and use it on their next move.  Note that this require the Stratagems contract to have enough allowance."
        }
      },
      "withdrawFromReserve(uint256)": {
        "params": {
          "amount": "number of tokens to withdraw"
        }
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "3607600",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)": "infinite",
        "acknowledgeMissedRevealByBurningAllReserve()": "infinite",
        "addToReserve(uint256,(uint256,uint256,uint8,bytes32,bytes32))": "infinite",
        "cancelCommitment()": "infinite",
        "makeCommitment(bytes24,address)": "infinite",
        "makeCommitmentWithExtraReserve(bytes24,uint256,(uint256,uint256,uint8,bytes32,bytes32),address)": "infinite",
        "poke(uint64)": "infinite",
        "pokeMultiple(uint64[])": "infinite",
        "reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)": "infinite",
        "withdrawFromReserve(uint256)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20WithIERC2612\",\"name\":\"tokens\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"burnAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"maxLife\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numTokensPerGems\",\"type\":\"uint256\"},{\"internalType\":\"contract ITime\",\"name\":\"time\",\"type\":\"address\"}],\"internalType\":\"struct UsingStratagemsTypes.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CanStillReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CommitmentHashNotMatching\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GameNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InCommitmentPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InRevealPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFurtherMoves\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PreviousCommitmentNotRevealed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"ReserveTooLow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"}],\"name\":\"CommitmentCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"}],\"name\":\"CommitmentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"color\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct UsingStratagemsTypes.Move[]\",\"name\":\"moves\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveAmount\",\"type\":\"uint256\"}],\"name\":\"CommitmentRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"}],\"name\":\"CommitmentVoid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"oldColor\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"newColor\",\"type\":\"uint8\"}],\"name\":\"MoveProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"positions\",\"type\":\"uint64[]\"}],\"name\":\"MultiPoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ReserveDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ReserveWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"}],\"name\":\"SinglePoke\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"color\",\"type\":\"uint8\"}],\"internalType\":\"struct UsingStratagemsTypes.Move[]\",\"name\":\"moves\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"}],\"name\":\"acknowledgeMissedReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acknowledgeMissedRevealByBurningAllReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmountToAdd\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct UsingStratagemsTypes.Permit\",\"name\":\"permit\",\"type\":\"tuple\"}],\"name\":\"addToReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelCommitment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"},{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"makeCommitment\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"},{\"internalType\":\"uint256\",\"name\":\"tokensAmountToAdd\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct UsingStratagemsTypes.Permit\",\"name\":\"permit\",\"type\":\"tuple\"},{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"makeCommitmentWithExtraReserve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"}],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"positions\",\"type\":\"uint64[]\"}],\"name\":\"pokeMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"color\",\"type\":\"uint8\"}],\"internalType\":\"struct UsingStratagemsTypes.Move[]\",\"name\":\"moves\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"},{\"internalType\":\"bool\",\"name\":\"useReserve\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ReserveTooLow(uint256,uint256)\":[{\"params\":{\"expected\":\"amount required to proceed\",\"inReserve\":\"amount in reserver as the time of the call\"}}]},\"events\":{\"CommitmentCancelled(address,uint24)\":{\"params\":{\"epoch\":\"epoch number on which this commit belongs to\",\"player\":\"account taking the staking risk (can be a different account than the one controlling the gems)\"}},\"CommitmentMade(address,uint24,bytes24)\":{\"params\":{\"commitmentHash\":\"the hash of moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"player\":\"account taking the staking risk (can be a different account than the one controlling the gems)\"}},\"CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)\":{\"params\":{\"commitmentHash\":\"the hash of the moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"furtherMoves\":\"hash of further moves, unless bytes32(0) which indicate end.\",\"moves\":\"the moves\",\"player\":\"account who commited\"}},\"CommitmentVoid(address,uint24,uint256,bytes24)\":{\"params\":{\"amountBurnt\":\"amount of token to burn\",\"epoch\":\"epoch number on which this commit belongs to\",\"furtherMoves\":\"hash of further moves, unless bytes32(0) which indicate end.\",\"player\":\"the account that made the commitment\"}},\"MoveProcessed(uint64,address,uint8,uint8)\":{\"params\":{\"newColor\":\"color that takes over\",\"oldColor\":\"previous color of the cell\",\"player\":\"account making the move\",\"position\":\"cell at which the move take place\"}},\"MultiPoke(uint24,uint64[])\":{\"params\":{\"epoch\":\"epoch number at which the poke take place\",\"positions\":\"cells to poke\"}},\"ReserveDeposited(address,uint256,uint256)\":{\"params\":{\"amountDeposited\":\"the number of tokens deposited\",\"newAmount\":\"the number of tokens in reserver as a result\",\"player\":\"account receiving the token in the reserve\"}},\"ReserveWithdrawn(address,uint256,uint256)\":{\"params\":{\"amountWithdrawn\":\"the number of tokens withdrawnn\",\"newAmount\":\"the number of tokens in reserver as a result\",\"player\":\"account withdrawing the tokens\"}},\"SinglePoke(uint24,uint64)\":{\"params\":{\"epoch\":\"epoch number at which the poke take place\",\"position\":\"cell to poke\"}}},\"kind\":\"dev\",\"methods\":{\"acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)\":{\"params\":{\"furtherMoves\":\"if moves cannot be contained in one tx, further moves are represented by a hash to reveal too\",\"moves\":\"the actual moves\",\"player\":\"the account who committed the move\",\"secret\":\"the secret used to make the commit\"}},\"addToReserve(uint256,(uint256,uint256,uint8,bytes32,bytes32))\":{\"params\":{\"permit\":\"permit EIP2612, .value = zero if not needed\",\"tokensAmountToAdd\":\"amount of tokens to add\"}},\"makeCommitment(bytes24,address)\":{\"params\":{\"commitmentHash\":\"the hash of the moves\",\"payee\":\"address to send ETH to along the commitment. Can be used to pay for reveal\"}},\"makeCommitmentWithExtraReserve(bytes24,uint256,(uint256,uint256,uint8,bytes32,bytes32),address)\":{\"params\":{\"commitmentHash\":\"the has of the moves\",\"payee\":\"address to send ETH to along the commitment. Can be used to pay for reveal\",\"permit\":\"permit EIP2612, value = zero if not needed\",\"tokensAmountToAdd\":\"amount of tokens to add to the reserve. the resulting total must be enough to cover the moves\"}},\"poke(uint64)\":{\"params\":{\"position\":\"the cell position\"}},\"pokeMultiple(uint64[])\":{\"params\":{\"positions\":\"cell positions to collect from\"}},\"reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)\":{\"params\":{\"furtherMoves\":\"if moves cannot be contained in one tx, further moves are represented by a hash to reveal too  Note that you have to that have enough moves (specified by MAX_NUM_MOVES_PER_HASH = 32)\",\"moves\":\"the actual moves\",\"payee\":\"address to send ETH to along the reveal\",\"player\":\"the account who committed the move\",\"secret\":\"the secret used to make the commit\",\"useReserve\":\"whether the tokens are taken from the reserve or from approvals.  This allow player to keep their reserve intact and use it on their next move.  Note that this require the Stratagems contract to have enough allowance.\"}},\"withdrawFromReserve(uint256)\":{\"params\":{\"amount\":\"number of tokens to withdraw\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"CanStillReveal()\":[{\"notice\":\"Player have to reveal if they can Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal.\"}],\"CommitmentHashNotMatching()\":[{\"notice\":\"Player have to reveal their commitment using the exact same move values  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal.\"}],\"GameNotStarted()\":[{\"notice\":\"Game has not started yet, can't perform any action\"}],\"InCommitmentPhase()\":[{\"notice\":\"When in Commit phase, player can make new commitment but they cannot reveal their move yet.\"}],\"InRevealPhase()\":[{\"notice\":\"When in Reveal phase, it is not possible to commit new moves or cancel previous commitment  During Reveal phase, players have to reveal their commitment, if not already done.\"}],\"InvalidEpoch()\":[{\"notice\":\"Player can only reveal their move in the same epoch they commited.abi  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`\"}],\"InvalidFurtherMoves()\":[{\"notice\":\"Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves  This result in a recursive series of hash that they can then submit in turn while revealing.  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block.\"}],\"NothingToReveal()\":[{\"notice\":\"Player can only reveal moves they commited.\"}],\"PreviousCommitmentNotRevealed()\":[{\"notice\":\"Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\\\  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\\\If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\\\\"}],\"ReserveTooLow(uint256,uint256)\":[{\"notice\":\"to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase.\"}]},\"events\":{\"CommitmentCancelled(address,uint24)\":{\"notice\":\"A player has cancelled its current commitment (before it reached the reveal phase)\"},\"CommitmentMade(address,uint24,bytes24)\":{\"notice\":\"A player has commited to make a move and reveal it on the reveal phase\"},\"CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)\":{\"notice\":\"Player has revealed its previous commitment\"},\"CommitmentVoid(address,uint24,uint256,bytes24)\":{\"notice\":\"A player has canceled a previous commitment by burning some tokens\"},\"MoveProcessed(uint64,address,uint8,uint8)\":{\"notice\":\"A move has been revealed.\"},\"MultiPoke(uint24,uint64[])\":{\"notice\":\"poke multiple cells and update them if needed\"},\"ReserveDeposited(address,uint256,uint256)\":{\"notice\":\"Player has deposited token in the reserve, allowing it to use that much in game\"},\"ReserveWithdrawn(address,uint256,uint256)\":{\"notice\":\"Player have withdrawn token from the reserve\"},\"SinglePoke(uint24,uint64)\":{\"notice\":\"poke cell and update it if needed\"}},\"kind\":\"user\",\"methods\":{\"acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)\":{\"notice\":\"called by player if they missed the reveal phase and want to minimze the token loss.  By providing the moves, they will be slashed only the amount of token required to make the moves\"},\"acknowledgeMissedRevealByBurningAllReserve()\":{\"notice\":\"should only be called as last resort this will burn all tokens in reserve If player has access to the secret, better call `acknowledgeMissedReveal`\"},\"addToReserve(uint256,(uint256,uint256,uint8,bytes32,bytes32))\":{\"notice\":\"called by players to add tokens to their reserve\"},\"cancelCommitment()\":{\"notice\":\"called by players to cancel their current commitment  Can only be called during the commit phase in which the commitment was made  It cannot be called afterward\"},\"makeCommitment(bytes24,address)\":{\"notice\":\"called by players to commit their moves  this can be called multiple time in the same epoch, the last call overriding the previous.  When a commitment is made, it needs to be revealed in the reveal phase of the same epoch.abi  If missed, player can still reveal its moves but none of them will be resolved.   The player would lose its associated reserved amount.\"},\"makeCommitmentWithExtraReserve(bytes24,uint256,(uint256,uint256,uint8,bytes32,bytes32),address)\":{\"notice\":\"called to make a commitment along with tokens to add to the reserve\"},\"pokeMultiple(uint64[])\":{\"notice\":\"poke and collect the tokens won across multiple cells\"},\"reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)\":{\"notice\":\"called by player to reveal their moves  this is where the core logic of the game takes place  This is where the game board evolves  The game is designed so that reveal order does not matter\"},\"withdrawFromReserve(uint256)\":{\"notice\":\"called by players to withdraw tokens from the reserve  can only be called if no commitments are pending  Note that while you can withdraw after commiting, note that if you do not have enough tokens  you'll have your commitment failing.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/game/routes/StratagemsSetters.sol\":\"StratagemsSetters\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC165/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0bbdb7cf3d2c6acf95398c0ef54cb0e6ae8a3e6ce6f18fafeb0aa55cb74fb8fd\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/ERC2612/interfaces/IERC20WithIERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC20.sol\\\";\\nimport \\\"./IERC2612.sol\\\";\\n\\ninterface IERC20WithIERC2612 is IERC20, IERC2612 {}\\n\",\"keccak256\":\"0x66100d98de50a396d46feb17a2b2b400b13f033f5e01b45e95901e61a4feef05\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/ERC2612/interfaces/IERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC20Errors.sol\\\";\\n\\ninterface IERC2612 {\\n    /// @notice The signature do not match the expected signer\\n    error InvalidSignature();\\n    /// @notice The permit has expired\\n    /// @param currentTime time at which the error happen\\n    /// @param deadline the deadline\\n    error DeadlineOver(uint256 currentTime, uint256 deadline);\\n\\n    /// @notice allow `spender` to spend `value` amount of token on behalf of `owner`\\n    /// @param owner owner of the tokens\\n    /// @param spender address allowed to spend on behalf of the owner.\\n    /// @param value amount of token allowed to be spent\\n    /// @param deadline timestamp in seconds after which the permit is not valid.\\n    /// @param v signature part v\\n    /// @param r signature part r\\n    /// @param s signature part s\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /// @notice return the current nonce of the owner\\n    /// @param owner address queried\\n    /// @return nonce nonce value\\n    function nonces(address owner) external view returns (uint256 nonce);\\n\\n    /// @notice EIP-712 Domain separator hash\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x4cfe3a61d7721761dd90ceb55c77d5d7ecaeb153d567c40d3b5ca33e266df2ea\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20Errors.sol\\\";\\n\\ninterface IERC20 {\\n    /// @notice trigger when tokens are transferred, including zero value transfers.\\n    /// @param from the account the tokens are sent from\\n    /// @param to the account the tokens are sent to\\n    /// @param value number of tokens sent\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice trigger on approval amount being set.\\n    ///   Note that Transfer events need to be considered to compute the current allowance.\\n    /// @param owner the account approving the `spender`\\n    /// @param spender the account allowed to spend\\n    /// @param value the amount granted\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the total token supply.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals the token uses.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the account balance of another account with address `owner`.\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /// @notice Transfers `amount` of tokens to address `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Allows `spender` to withdraw from your account multiple times, up to `amount`.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from address `from` to address `to`.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x15bb1e4e1340b29eefc06b8826fcf9e6455e25ba972709672da7d3788777133f\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/interfaces/IERC20Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice The msg value do not match the expected value\\n/// @param provided msg.value amount provided\\n/// @param expected value expected\\nerror InvalidMsgValue(uint256 provided, uint256 expected);\\n/// @notice The total amount provided do not match the expected value\\n/// @param provided msg.value amount provided\\n/// @param expected value expected\\nerror InvalidTotalAmount(uint256 provided, uint256 expected);\\n/// @notice An invalid address is specified (for example: zero address)\\n/// @param addr invalid address\\nerror InvalidAddress(address addr);\\n/// @notice the amount requested exceed the allowance\\n/// @param currentAllowance the current allowance\\n/// @param expected amount expected\\nerror NotAuthorizedAllowance(uint256 currentAllowance, uint256 expected);\\n/// @notice the amount requested exceed the balance\\n/// @param currentBalance the current balance\\n/// @param expected amount expected\\nerror NotEnoughTokens(uint256 currentBalance, uint256 expected);\\n\",\"keccak256\":\"0xc8ab4cfee19338da32d2fc5473e1ee740bf608c59196ebd16de74294c4813ae9\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"../../utils/GenericErrors.sol\\\";\\n\\ninterface IERC721Supply {\\n    /// @notice return the total number of token in existence\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IERC721 is IERC165 {\\n    /// @notice Triggered when a token is transferred\\n    /// @param from the account the token is sent from\\n    /// @param to the account the token is sent to\\n    /// @param tokenID id of the token being sent\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when a token is approved to be sent by another account\\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\\n    /// @param owner current owner of the token\\n    /// @param approved account who can know transfer on the owner's behalf\\n    /// @param tokenID id of the token being approved\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\\n    /// @param owner the account granting rights over all of its token\\n    /// @param operator account who can know transfer on the owner's behalf\\n    /// @param approved whether it is approved or not\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /// @notice The token does not exist\\n    /// @param tokenID id of the expected token\\n    error NonExistentToken(uint256 tokenID);\\n    /// @notice The address from which the token is sent is not the current owner\\n    /// @param provided the address expected to be the current owner\\n    /// @param currentOwner the current owner\\n    error NotOwner(address provided, address currentOwner);\\n    /// @notice An invalid address is specified (for example: zero address)\\n    /// @param addr invalid address\\n    error InvalidAddress(address addr);\\n    /// @notice The Transfer was rejected by the destination\\n    error TransferRejected();\\n    /// @notice The Nonce overflowed, make a transfer to self to allow new nonces.\\n    error NonceOverflow();\\n\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return balance The number of tokens owned by the address.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Get the owner of a token.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 tokenID) external view returns (address owner);\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID\\n    ) external;\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID\\n    ) external;\\n\\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param tokenID The id of the token.\\n    function approve(address operator, uint256 tokenID) external;\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param tokenID The id of the token.\\n    /// @return operator The address of the operator.\\n    function getApproved(uint256 tokenID) external view returns (address operator);\\n\\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xfc57636452848e89a81850fe10e3ab1d5d7f5780d55ca0722a38fd59a44fd8ef\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface IERC721Metadata is IERC721 {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory name);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory symbol);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `tokenID` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    /// @param tokenID id of the token being queried.\\n    function tokenURI(uint256 tokenID) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x8a4ff84c39ad5c6bbf3e5486d3687bc1e15b96835ede5761f1922cf7a72f3354\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/debug/time/interfaces/ITime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITime {\\n    function timestamp() external view returns (uint256);\\n}\\n\\ninterface ITimeSetter {\\n    event TimeIncreased(uint256 newTime, uint256 delta);\\n\\n    function increaseTime(uint256 delta) external;\\n}\\n\",\"keccak256\":\"0xeb0fa861febbb5f5956ea9f48a88c812671564d249ddd8c5c00740e922eb056d\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/utils/GenericErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Not authorized to perform this operation\\nerror NotAuthorized();\\n\",\"keccak256\":\"0x333aa48943e66849a9350384e7ec2553b93e8a8a12b8ad300d3341f7c98b60fd\",\"license\":\"MIT\"},\"src/game/interface/IStratagems.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721Metadata.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"./UsingStratagemsTypes.sol\\\";\\nimport \\\"./UsingStratagemsEvents.sol\\\";\\n\\ninterface IStratagemsGetters is UsingStratagemsTypes, UsingStratagemsEvents {\\n    /// @notice return updated cell (based on current epoch)\\n    /// @param id the cell id\\n    function getCell(uint256 id) external view returns (FullCell memory cell);\\n\\n    /// @notice return the list of updated cells (based on current epoch) whose ids is given\\n    /// @param ids the list of cell ids\\n    function getCells(uint256[] memory ids) external view returns (FullCell[] memory cells);\\n\\n    /// @notice the number of token in reserve per account\\n    ///  This is used to slash player who do not reveal their moves\\n    ///  The amount can be greater than the number of token required for the next move\\n    ///  This allow player to potentially hide their intention.\\n    /// @param account the address to retrived the amount in reserve of.\\n    function getTokensInReserve(address account) external view returns (uint256 amount);\\n\\n    /// @notice The commitment to be revealed. zeroed if no commitment need to be made.\\n    /// @param account the address of which to retrieve the commitment\\n    function getCommitment(address account) external view returns (Commitment memory commitment);\\n\\n    /// @notice return the config used to initialise the Game\\n    function getConfig() external view returns (Config memory config);\\n}\\n\\ninterface IStratagemsSetters is UsingStratagemsTypes, UsingStratagemsEvents {\\n    /// @notice called by players to add tokens to their reserve\\n    /// @param tokensAmountToAdd amount of tokens to add\\n    /// @param permit permit EIP2612, .value = zero if not needed\\n    function addToReserve(uint256 tokensAmountToAdd, Permit calldata permit) external;\\n\\n    /// @notice called by players to commit their moves\\n    ///  this can be called multiple time in the same epoch, the last call overriding the previous.\\n    ///  When a commitment is made, it needs to be revealed in the reveal phase of the same epoch.abi\\n    ///  If missed, player can still reveal its moves but none of them will be resolved.\\n    ///   The player would lose its associated reserved amount.\\n    /// @param commitmentHash the hash of the moves\\n    /// @param payee address to send ETH to along the commitment. Can be used to pay for reveal\\n    function makeCommitment(bytes24 commitmentHash, address payable payee) external payable;\\n\\n    /// @notice called by players to cancel their current commitment\\n    ///  Can only be called during the commit phase in which the commitment was made\\n    ///  It cannot be called afterward\\n    function cancelCommitment() external;\\n\\n    /// @notice called to make a commitment along with tokens to add to the reserve\\n    /// @param commitmentHash the has of the moves\\n    /// @param tokensAmountToAdd amount of tokens to add to the reserve. the resulting total must be enough to cover the moves\\n    /// @param permit permit EIP2612, value = zero if not needed\\n    /// @param payee address to send ETH to along the commitment. Can be used to pay for reveal\\n    function makeCommitmentWithExtraReserve(\\n        bytes24 commitmentHash,\\n        uint256 tokensAmountToAdd,\\n        Permit calldata permit,\\n        address payable payee\\n    ) external payable;\\n\\n    /// @notice called by players to withdraw tokens from the reserve\\n    ///  can only be called if no commitments are pending\\n    ///  Note that while you can withdraw after commiting, note that if you do not have enough tokens\\n    ///  you'll have your commitment failing.\\n    /// @param amount number of tokens to withdraw\\n    function withdrawFromReserve(uint256 amount) external;\\n\\n    /// @notice called by player to reveal their moves\\n    ///  this is where the core logic of the game takes place\\n    ///  This is where the game board evolves\\n    ///  The game is designed so that reveal order does not matter\\n    /// @param player the account who committed the move\\n    /// @param secret the secret used to make the commit\\n    /// @param moves the actual moves\\n    /// @param furtherMoves if moves cannot be contained in one tx, further moves are represented by a hash to reveal too\\n    ///  Note that you have to that have enough moves (specified by MAX_NUM_MOVES_PER_HASH = 32)\\n    /// @param useReserve whether the tokens are taken from the reserve or from approvals.\\n    ///  This allow player to keep their reserve intact and use it on their next move.\\n    ///  Note that this require the Stratagems contract to have enough allowance.\\n    /// @param payee address to send ETH to along the reveal\\n    function reveal(\\n        address player,\\n        bytes32 secret,\\n        Move[] calldata moves,\\n        bytes24 furtherMoves,\\n        bool useReserve,\\n        address payable payee\\n    ) external payable;\\n\\n    /// @notice called by player if they missed the reveal phase and want to minimze the token loss.\\n    ///  By providing the moves, they will be slashed only the amount of token required to make the moves\\n    /// @param player the account who committed the move\\n    /// @param secret the secret used to make the commit\\n    /// @param moves the actual moves\\n    /// @param furtherMoves if moves cannot be contained in one tx, further moves are represented by a hash to reveal too\\n    function acknowledgeMissedReveal(\\n        address player,\\n        bytes32 secret,\\n        Move[] calldata moves,\\n        bytes24 furtherMoves\\n    ) external;\\n\\n    /// @notice should only be called as last resort\\n    /// this will burn all tokens in reserve\\n    /// If player has access to the secret, better call `acknowledgeMissedReveal`\\n    function acknowledgeMissedRevealByBurningAllReserve() external;\\n\\n    /// @notice poke a position, resolving its virtual state.\\n    //  If dead as a result, it will reward neighboor enemies colors\\n    /// @param position the cell position\\n    function poke(uint64 position) external;\\n\\n    /// @notice poke and collect the tokens won across multiple cells\\n    /// @param positions cell positions to collect from\\n    function pokeMultiple(uint64[] calldata positions) external;\\n}\\n\\ninterface IStratagems is IStratagemsSetters, IStratagemsGetters, IERC721, IERC721Metadata {}\\n\",\"keccak256\":\"0xa246ac7dd2bbb040075cc496772d137fea7ba0b44d3d14eec39de0eee088725d\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsErrors.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface UsingStratagemsErrors {\\n    /// @notice Game has not started yet, can't perform any action\\n    error GameNotStarted();\\n\\n    /// @notice When in Reveal phase, it is not possible to commit new moves or cancel previous commitment\\n    ///  During Reveal phase, players have to reveal their commitment, if not already done.\\n    error InRevealPhase();\\n\\n    /// @notice When in Commit phase, player can make new commitment but they cannot reveal their move yet.\\n    error InCommitmentPhase();\\n\\n    /// @notice Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\\\\\n    ///  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\\\\\n    /// @notice If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\\\\\n    error PreviousCommitmentNotRevealed();\\n\\n    /// @notice to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve\\n    ///  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase.\\n    /// @param inReserve amount in reserver as the time of the call\\n    /// @param expected amount required to proceed\\n    error ReserveTooLow(uint256 inReserve, uint256 expected);\\n\\n    /// @notice Player have to reveal their commitment using the exact same move values\\n    ///  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal.\\n    error CommitmentHashNotMatching();\\n\\n    /// @notice Player can only reveal moves they commited.\\n    error NothingToReveal();\\n\\n    /// @notice Player can only reveal their move in the same epoch they commited.abi\\n    ///  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`\\n    error InvalidEpoch();\\n\\n    /// @notice Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves\\n    ///  This result in a recursive series of hash that they can then submit in turn while revealing.\\n    ///  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block.\\n    error InvalidFurtherMoves();\\n\\n    /// @notice Player have to reveal if they can\\n    /// Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal.\\n    error CanStillReveal();\\n}\\n\",\"keccak256\":\"0xae45d0ffffcec8627aaa60440f613bb96a4b4d53466c733591df377460c01450\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsEvents.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsTypes.sol\\\";\\n\\ninterface UsingStratagemsEvents is UsingStratagemsTypes {\\n    /// @notice A player has commited to make a move and reveal it on the reveal phase\\n    /// @param player account taking the staking risk (can be a different account than the one controlling the gems)\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param commitmentHash the hash of moves\\n    event CommitmentMade(address indexed player, uint24 indexed epoch, bytes24 commitmentHash);\\n\\n    /// @notice A player has cancelled its current commitment (before it reached the reveal phase)\\n    /// @param player account taking the staking risk (can be a different account than the one controlling the gems)\\n    /// @param epoch epoch number on which this commit belongs to\\n    event CommitmentCancelled(address indexed player, uint24 indexed epoch);\\n\\n    /// @notice A player has canceled a previous commitment by burning some tokens\\n    /// @param player the account that made the commitment\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param amountBurnt amount of token to burn\\n    /// @param furtherMoves hash of further moves, unless bytes32(0) which indicate end.\\n    event CommitmentVoid(address indexed player, uint24 indexed epoch, uint256 amountBurnt, bytes24 furtherMoves);\\n\\n    /// @notice Player has revealed its previous commitment\\n    /// @param player account who commited\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param commitmentHash the hash of the moves\\n    /// @param moves the moves\\n    /// @param furtherMoves hash of further moves, unless bytes32(0) which indicate end.\\n    event CommitmentRevealed(\\n        address indexed player,\\n        uint24 indexed epoch,\\n        bytes24 indexed commitmentHash,\\n        Move[] moves,\\n        bytes24 furtherMoves,\\n        uint256 newReserveAmount\\n    );\\n\\n    /// @notice poke cell and update it if needed\\n    /// @param position cell to poke\\n    /// @param epoch epoch number at which the poke take place\\n    event SinglePoke(uint24 indexed epoch, uint64 position);\\n\\n    /// @notice poke multiple cells and update them if needed\\n    /// @param positions cells to poke\\n    /// @param epoch epoch number at which the poke take place\\n    event MultiPoke(uint24 indexed epoch, uint64[] positions);\\n\\n    /// @notice Player have withdrawn token from the reserve\\n    /// @param player account withdrawing the tokens\\n    /// @param amountWithdrawn the number of tokens withdrawnn\\n    /// @param newAmount the number of tokens in reserver as a result\\n    event ReserveWithdrawn(address indexed player, uint256 amountWithdrawn, uint256 newAmount);\\n\\n    /// @notice Player has deposited token in the reserve, allowing it to use that much in game\\n    /// @param player account receiving the token in the reserve\\n    /// @param amountDeposited the number of tokens deposited\\n    /// @param newAmount the number of tokens in reserver as a result\\n    event ReserveDeposited(address indexed player, uint256 amountDeposited, uint256 newAmount);\\n\\n    // --------------------------------------------------------------------------------------------\\n    // Event to make it easier to check what is happening\\n    // TODO get rid ?\\n    // --------------------------------------------------------------------------------------------\\n    /// @notice A move has been revealed.\\n    /// @param position cell at which the move take place\\n    /// @param player account making the move\\n    /// @param oldColor previous color of the cell\\n    /// @param newColor color that takes over\\n    event MoveProcessed(uint64 indexed position, address indexed player, Color oldColor, Color newColor);\\n}\\n\",\"keccak256\":\"0xdc79a36c8ceccceb65d4602a8169e86b0ae4dc3ddbe0955797c0bffc1cb0ad7b\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsTypes.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC20/ERC2612/interfaces/IERC20WithIERC2612.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/debug/time/interfaces/ITime.sol\\\";\\n\\ninterface UsingStratagemsTypes {\\n    // --------------------------------------------------------------------------------------------\\n    // EXTERNAL TYPES\\n    // --------------------------------------------------------------------------------------------\\n\\n    /// @notice The set of possible color (None indicate the Cell is empty)\\n    enum Color {\\n        None,\\n        Blue,\\n        Red,\\n        Green,\\n        Yellow,\\n        Purple,\\n        Evil\\n    }\\n\\n    /// @notice Move struct that define position and color\\n    struct Move {\\n        uint64 position; // TODO make it bigger ? uint32 * uint32 is probably infinitely big enough\\n        Color color;\\n    }\\n\\n    /// @notice Permit struct to authorize EIP2612 ERC20 contracts\\n    struct Permit {\\n        uint256 value;\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Config struct to configure the game instance\\n    struct Config {\\n        IERC20WithIERC2612 tokens;\\n        address payable burnAddress;\\n        uint256 startTime;\\n        uint256 commitPhaseDuration;\\n        uint256 revealPhaseDuration;\\n        uint8 maxLife;\\n        uint256 numTokensPerGems;\\n        ITime time;\\n    }\\n\\n    /// @notice Cell struct representing the current state of a cell\\n    struct FullCell {\\n        address owner;\\n        uint24 lastEpochUpdate;\\n        uint24 epochWhenTokenIsAdded;\\n        Color color;\\n        uint8 life;\\n        int8 delta;\\n        uint8 enemyMap;\\n        uint8 distribution;\\n        uint8 stake; // for Evil, else always 1\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // STORAGE TYPES\\n    // --------------------------------------------------------------------------------------------\\n    struct Cell {\\n        uint24 lastEpochUpdate;\\n        uint24 epochWhenTokenIsAdded;\\n        Color color;\\n        uint8 life;\\n        int8 delta;\\n        uint8 enemyMap;\\n        uint8 distribution; // this encode who is left to be given reward (4 left most bits) and the reard (4 most right bits)\\n        uint8 stake; // for Evil, else always 1\\n    }\\n\\n    struct Commitment {\\n        bytes24 hash;\\n        uint24 epoch;\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // INTERNAL TYPES\\n    // --------------------------------------------------------------------------------------------\\n\\n    struct TokenTransfer {\\n        address payable to;\\n        uint256 amount;\\n    }\\n\\n    struct TokenTransferCollection {\\n        TokenTransfer[] transfers;\\n        uint256 numTransfers;\\n    }\\n\\n    struct MoveTokens {\\n        uint256 tokensPlaced;\\n        uint256 tokensBurnt;\\n        uint256 tokensReturned;\\n    }\\n}\\n\",\"keccak256\":\"0x4b0f41925dfc34ee6f2aa8a19f477cb0f32401cd354963e51853ee3218857efd\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsSetters.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsState.sol\\\";\\nimport \\\"../interface/UsingStratagemsEvents.sol\\\";\\nimport \\\"./UsingStratagemsUtils.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\n\\nabstract contract UsingStratagemsSetters is UsingStratagemsState, UsingStratagemsUtils {\\n    using PositionUtils for uint64;\\n\\n    constructor(Config memory config) UsingStratagemsState(config) {}\\n\\n    function _makeCommitment(address player, bytes24 commitmentHash, uint256 inReserve) internal {\\n        Commitment storage commitment = _commitments[player];\\n\\n        (uint24 epoch, bool commiting) = _epoch();\\n\\n        if (!commiting) {\\n            revert InRevealPhase();\\n        }\\n        if (commitment.epoch != 0 && commitment.epoch != epoch) {\\n            revert PreviousCommitmentNotRevealed();\\n        }\\n\\n        commitment.hash = commitmentHash;\\n        commitment.epoch = epoch;\\n\\n        // for withdrawal, we still require a minimal reserve so player cannot change their mind without losing at least one token\\n        // TODO we might want to increase that value to 10x as 10 moves might quite common, at least on some networks\\n        if (inReserve < NUM_TOKENS_PER_GEMS) {\\n            // TODO? special error for this case ?\\n            revert ReserveTooLow(inReserve, NUM_TOKENS_PER_GEMS);\\n        }\\n\\n        emit CommitmentMade(player, epoch, commitmentHash);\\n    }\\n\\n    function _resolveMoves(\\n        address player,\\n        uint24 epoch,\\n        Move[] memory moves,\\n        address tokenGiver\\n    ) internal returns (uint256 newReserveAmount) {\\n        // max number of transfer is (4+1) * moves.length\\n        // (for each move's cell's neighbours potentially being a different account)\\n        // limiting the number of move per commitment reveal to 32 or, even more probably, should cover this unlikely scenario\\n        TokenTransferCollection memory transferCollection = TokenTransferCollection({\\n            transfers: new TokenTransfer[](moves.length * 5),\\n            numTransfers: 0\\n        });\\n        MoveTokens memory tokens;\\n        for (uint256 i = 0; i < moves.length; i++) {\\n            (uint256 placed, uint256 burnt, uint256 returned) = _computeMove(\\n                transferCollection,\\n                player,\\n                epoch,\\n                moves[i]\\n            );\\n\\n            tokens.tokensPlaced += placed;\\n            tokens.tokensBurnt += burnt;\\n            tokens.tokensReturned += returned;\\n        }\\n\\n        // logger.logTransfers(0, \\\"resolveMoves\\\", transferCollection);\\n\\n        _multiTransfer(TOKENS, transferCollection);\\n\\n        newReserveAmount = _tokensInReserve[player];\\n\\n        // Note: even if funds can comes from outside the reserve, we still check it\\n        // This ensure player have to have a reserve and cannot escape the slash if not\\n        if (newReserveAmount < tokens.tokensPlaced + tokens.tokensBurnt) {\\n            revert ReserveTooLow(newReserveAmount, tokens.tokensPlaced + tokens.tokensBurnt);\\n        }\\n        if (tokenGiver == address(0)) {\\n            newReserveAmount -= tokens.tokensPlaced + tokens.tokensBurnt;\\n            _tokensInReserve[player] = newReserveAmount;\\n        } else {\\n            if (tokens.tokensPlaced != 0) {\\n                // TODO use TransferCollection too here\\n                TOKENS.transferFrom(tokenGiver, address(this), tokens.tokensPlaced);\\n            }\\n            if (tokens.tokensBurnt != 0) {\\n                // TODO use TransferCollection too here\\n                TOKENS.transferFrom(tokenGiver, BURN_ADDRESS, tokens.tokensBurnt);\\n            }\\n        }\\n        // option to return in reserve ?\\n        // TODO use TransferCollection too here\\n        if (tokens.tokensReturned != 0) {\\n            // console.log(\\\"tokensReturned\\\");\\n            // console.log(tokens.tokensReturned);\\n            TOKENS.transfer(player, tokens.tokensReturned);\\n        }\\n    }\\n\\n    function _countBits(uint8 n) internal pure returns (uint8 count) {\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n    }\\n\\n    // Note on COLLISION\\n    // If one color was used more than other, we could consider the cell having N owner and N times the number of tokens\\n    // such cells would be a good target for others\\n    // On the other end, on winning agains other cells, owner of such cell would have to divide the winnings\\n    // TODO revisit this\\n    // we could also refund the part\\n    // so if there is 3 green 2 blue and 1 red, then green win and the cell become green\\n    // player we put blue or red get refunded their respective gems\\n    // the players we put green get refunded 2/3 so that the cell still contains only 1\\n    // if there was 3 green and 3 blue and 1 red then the cell becomes black\\n    // every player get refunded 6/7 so that the black cell only has 1\\n    // note that the issue with green winning above is that winnings need to be distributed to all 3 players we put green\\n    // and since the number is technically unbounded, we have to use a splitter contract where player withdraw their winnings\\n    // this add UX complexity and some cost for withdrawals\\n    function _computeMove(\\n        TokenTransferCollection memory transferCollection,\\n        address player,\\n        uint24 epoch,\\n        Move memory move\\n    ) internal returns (uint256 tokensPlaced, uint256 tokensBurnt, uint256 tokensReturned) {\\n        (Cell memory currentState, bool justDied) = _getUpdatedCell(move.position, epoch);\\n\\n        // logger.logCell(0, string.concat(\\\"_computeMove at epoch \\\", Strings.toString(epoch)), move.position, currentState, address(uint160(_owners[move.position])));\\n\\n        // we might have distribution still to do\\n        uint8 distribution = currentState.distribution;\\n        if (justDied) {\\n            // if we just died\\n            // we have to distribute to all\\n            distribution = (currentState.enemyMap << 4) + _countBits(currentState.enemyMap);\\n\\n            /// we are now dead for real\\n            currentState.lastEpochUpdate = 0;\\n        }\\n\\n        // we then apply our move:\\n\\n        // first we do some validity checks\\n        if (move.color == Color.None) {\\n            if (currentState.life != MAX_LIFE || _ownerOf(move.position) != player) {\\n                // invalid move\\n                return (0, 0, NUM_TOKENS_PER_GEMS);\\n            }\\n\\n            _collectTransfer(transferCollection, TokenTransfer({to: payable(player), amount: NUM_TOKENS_PER_GEMS}));\\n        }\\n        // then we consider the case of collision and transform such move as Color Evil\\n        else if (currentState.epochWhenTokenIsAdded == epoch) {\\n            if (currentState.life != 0) {\\n                move.color = Color.Evil;\\n                // TODO Add further stake, or do we burn? or return?\\n            } else {\\n                // invalid move, on top of a MAX, that become None ?\\n                return (0, 0, NUM_TOKENS_PER_GEMS);\\n            }\\n        }\\n\\n        (int8 newDelta, uint8 newEnemyMap) = _propagate(\\n            transferCollection,\\n            move,\\n            epoch,\\n            currentState.color,\\n            distribution,\\n            currentState.stake\\n        );\\n\\n        emit MoveProcessed(move.position, player, currentState.color, move.color);\\n        currentState.color = move.color;\\n        currentState.distribution = 0;\\n        currentState.epochWhenTokenIsAdded = epoch; // used to prevent overwriting, even Color.None\\n\\n        if (currentState.color == Color.None) {\\n            currentState.life = 0;\\n            currentState.stake = 0;\\n            currentState.lastEpochUpdate = 0;\\n            currentState.delta = 0;\\n            currentState.enemyMap = 0;\\n            _owners[move.position] = 0;\\n            tokensReturned = NUM_TOKENS_PER_GEMS;\\n        } else {\\n            tokensPlaced = NUM_TOKENS_PER_GEMS;\\n\\n            currentState.enemyMap = newEnemyMap;\\n\\n            if (currentState.color == Color.Evil && currentState.life != 0) {\\n                unchecked {\\n                    currentState.stake += 1;\\n                    if (currentState.stake == 0) {\\n                        // we cap it, losing stake there\\n                        // TODO reevaluate\\n                        currentState.stake = 255;\\n                    }\\n                }\\n            } else {\\n                currentState.stake = 1;\\n            }\\n\\n            currentState.delta = newDelta;\\n            currentState.life = 1;\\n            currentState.lastEpochUpdate = epoch;\\n            if (currentState.color == Color.Evil) {\\n                _owners[move.position] = uint256(uint160(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\\n            } else {\\n                _owners[move.position] = uint256(uint160(player));\\n            }\\n        }\\n\\n        _cells[move.position] = currentState;\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER \\\", Strings.toString(epoch)),move.position,currentState,address(uint160(_owners[move.position])));\\n    }\\n\\n    function _propagate(\\n        TokenTransferCollection memory transferCollection,\\n        Move memory move,\\n        uint24 epoch,\\n        Color color,\\n        uint8 distribution,\\n        uint8 stake\\n    ) internal returns (int8 newDelta, uint8 newEnemyMap) {\\n        (\\n            int8 newComputedDelta,\\n            uint8 newComputedEnemyMap,\\n            uint16 numDue,\\n            address[4] memory ownersToPay\\n        ) = _updateNeighbours(move.position, epoch, color, move.color, distribution);\\n\\n        if (numDue > 0) {\\n            _collectTransfer(\\n                transferCollection,\\n                TokenTransfer({to: payable(_ownerOf(move.position)), amount: (numDue * NUM_TOKENS_PER_GEMS) / 12})\\n            );\\n        }\\n        for (uint8 i = 0; i < 4; i++) {\\n            if (ownersToPay[i] != address(0)) {\\n                _collectTransfer(\\n                    transferCollection,\\n                    TokenTransfer({\\n                        to: payable(ownersToPay[i]),\\n                        amount: stake * (NUM_TOKENS_PER_GEMS / (distribution & 0x0f))\\n                    })\\n                );\\n            }\\n        }\\n        newDelta = newComputedDelta;\\n        newEnemyMap = newComputedEnemyMap;\\n    }\\n\\n    function _poke(TokenTransferCollection memory transferCollection, uint64 position, uint24 epoch) internal {\\n        (Cell memory currentState, bool justDied) = _getUpdatedCell(position, epoch);\\n\\n        // logger.logCell(0,string.concat(\\\"_poke at epoch \\\", Strings.toString(epoch)),position,currentState,address(uint160(_owners[position])));\\n\\n        // we might have distribution still to do\\n        uint8 distribution = currentState.distribution;\\n        if (justDied) {\\n            // if we just died\\n            // we have to distribute to all\\n            distribution = (currentState.enemyMap << 4) + _countBits(currentState.enemyMap);\\n\\n            /// we are now dead for real\\n            currentState.lastEpochUpdate = 0;\\n        }\\n\\n        (, , uint16 numDue, address[4] memory ownersToPay) = _updateNeighbours(\\n            position,\\n            epoch,\\n            currentState.color,\\n            currentState.color,\\n            distribution\\n        );\\n\\n        if (numDue > 0) {\\n            _collectTransfer(\\n                transferCollection,\\n                TokenTransfer({to: payable(_ownerOf(position)), amount: (numDue * NUM_TOKENS_PER_GEMS) / 12})\\n            );\\n        }\\n        for (uint8 i = 0; i < 4; i++) {\\n            if (ownersToPay[i] != address(0)) {\\n                _collectTransfer(\\n                    transferCollection,\\n                    TokenTransfer({\\n                        to: payable(ownersToPay[i]),\\n                        amount: currentState.stake * (NUM_TOKENS_PER_GEMS / (distribution & 0x0f))\\n                    })\\n                );\\n            }\\n        }\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER poke (before zeroed distribution) at epoch \\\", Strings.toString(epoch)),position,currentState,address(uint160(_owners[position])));\\n\\n        currentState.distribution = 0;\\n        _cells[position] = currentState;\\n    }\\n\\n    function _updateNeighbours(\\n        uint64 position,\\n        uint24 epoch,\\n        Color oldColor,\\n        Color newColor,\\n        uint8 distribution\\n    ) internal returns (int8 newDelta, uint8 newenemyMap, uint16 numDue, address[4] memory ownersToPay) {\\n        unchecked {\\n            int8 enemyOrFriend;\\n            uint16 due;\\n            {\\n                uint64 upPosition = position.offset(0, -1);\\n                (enemyOrFriend, due) = _updateCell(upPosition, epoch, 2, oldColor, newColor);\\n                if (enemyOrFriend < 0) {\\n                    newenemyMap = newenemyMap | 1;\\n                }\\n                numDue += due;\\n\\n                if ((distribution >> 4) & 1 == 1) {\\n                    // logger.logPosition(\\\"from\\\", position);\\n                    // logger.logPosition(\\\"to up\\\", upPosition);\\n                    // console.log(\\\"distribute %i\\\", distribution & 0x0F);\\n\\n                    // TODO?: if we decide to group owner in the cell struct, we should get the cell in memory in that function\\n                    ownersToPay[0] = _ownerOf(upPosition);\\n                }\\n\\n                if (due > 0) {\\n                    // logger.logPosition(\\\"due from up\\\", upPosition);\\n                    // logger.logPosition(\\\"to\\\", position);\\n                    // console.log(\\\"amount %i \\\", due);\\n                }\\n                newDelta += enemyOrFriend;\\n            }\\n            {\\n                uint64 leftPosition = position.offset(-1, 0);\\n                (enemyOrFriend, due) = _updateCell(leftPosition, epoch, 3, oldColor, newColor);\\n                if (enemyOrFriend < 0) {\\n                    newenemyMap = newenemyMap | 2;\\n                }\\n                numDue += due;\\n                if ((distribution >> 4) & 2 == 2) {\\n                    // logger.logPosition(\\\"from\\\", position);\\n                    // logger.logPosition(\\\"to left\\\", leftPosition);\\n                    // console.log(\\\"distribute %i\\\", distribution & 0x0F);\\n                    ownersToPay[1] = _ownerOf(leftPosition);\\n                }\\n                if (due > 0) {\\n                    // logger.logPosition(\\\"due from left\\\", leftPosition);\\n                    // logger.logPosition(\\\"to\\\", position);\\n                    // console.log(\\\"amount %i \\\", due);\\n                }\\n                newDelta += enemyOrFriend;\\n            }\\n\\n            {\\n                uint64 downPosition = position.offset(0, 1);\\n                (enemyOrFriend, due) = _updateCell(downPosition, epoch, 0, oldColor, newColor);\\n                if (enemyOrFriend < 0) {\\n                    newenemyMap = newenemyMap | 4;\\n                }\\n                numDue += due;\\n                if ((distribution >> 4) & 4 == 4) {\\n                    // logger.logPosition(\\\"from\\\", position);\\n                    // logger.logPosition(\\\"to down\\\", downPosition);\\n                    // console.log(\\\"distribute %i\\\", distribution & 0x0F);\\n                    ownersToPay[2] = _ownerOf(downPosition);\\n                }\\n                if (due > 0) {\\n                    // logger.logPosition(\\\"due from down\\\", downPosition);\\n                    // logger.logPosition(\\\"to\\\", position);\\n                    // console.log(\\\"amount %i \\\", due);\\n                }\\n                newDelta += enemyOrFriend;\\n            }\\n            {\\n                uint64 rightPosition = position.offset(1, 0);\\n                (enemyOrFriend, due) = _updateCell(rightPosition, epoch, 1, oldColor, newColor);\\n                if (enemyOrFriend < 0) {\\n                    newenemyMap = newenemyMap | 8;\\n                }\\n                numDue += due;\\n                if ((distribution >> 4) & 8 == 8) {\\n                    // logger.logPosition(\\\"from\\\", position);\\n                    // logger.logPosition(\\\"to right\\\", rightPosition);\\n                    // console.log(\\\"distribute %i\\\", distribution & 0x0F);\\n                    ownersToPay[3] = _ownerOf(rightPosition);\\n                }\\n                if (due > 0) {\\n                    // logger.logPosition(\\\"due from right\\\", rightPosition);\\n                    // logger.logPosition(\\\"to\\\", position);\\n                    // console.log(\\\"amount %i \\\", due);\\n                }\\n                newDelta += enemyOrFriend;\\n            }\\n        }\\n    }\\n\\n    /// @dev This update the cell in storage\\n    function _updateCell(\\n        uint64 position, // position to update\\n        uint24 epoch,\\n        uint8 neighbourIndex, // index from point of view of cell being updated\\n        Color oldColor, // old Color of the neighbor\\n        Color newColor // new color of the neighbor\\n    ) internal returns (int8 enemyOrFriend, uint16 due) {\\n        Cell memory cell = _cells[position];\\n\\n        uint24 lastUpdate = cell.lastEpochUpdate;\\n        Color color = cell.color;\\n        if (color != Color.None) {\\n            // if the color of the cell being update is not Nome\\n            // we then check the neighbor new color\\n            // if it same as the cell color, then we report the cell as friendly to the neighbor\\n            // else it is an enemy\\n            // note that _updateCell should only be called if oldColor != newColor\\n            enemyOrFriend = color == newColor ? int8(1) : int8(-1);\\n        }\\n        if (lastUpdate >= 1 && color != Color.None) {\\n            // we only consider cell with color that are not dead\\n            if (cell.life > 0 && lastUpdate < epoch) {\\n                // of there is life to update we compute the new life\\n                (uint8 newLife, ) = _computeNewLife(lastUpdate, cell.enemyMap, cell.delta, cell.life, epoch);\\n                due = _updateCellFromNeighbor(position, cell, newLife, epoch, neighbourIndex, oldColor, newColor);\\n            } else {\\n                due = _updateCellFromNeighbor(position, cell, cell.life, epoch, neighbourIndex, oldColor, newColor);\\n            }\\n        }\\n    }\\n\\n    function _updateCellFromNeighbor(\\n        uint64 position, // position of the cell to be updated\\n        Cell memory cell, // cell to be updated\\n        uint8 newLife, // new life value for the celll\\n        uint24 epoch, // epoch at which the update occured (epochUsed TODO: confirm its use)\\n        uint8 neighbourIndex, // the neighbor triggering the update and for which we return whether it should receive its due\\n        Color oldColor, // old color of that neighbor\\n        Color newColor // new color of that neighbor\\n    ) internal returns (uint16 due) {\\n        if (cell.life > 0 && newLife == 0) {\\n            // we just died, we establish the distributionMap and counts\\n            // logger.logPosition(\\\"new distribution\\\", position);\\n            cell.distribution = (cell.enemyMap << 4) + _countBits(cell.enemyMap);\\n            // console.log(\\\"%i %i\\\", cell.distribution >> 4, cell.distribution & 0x0F);\\n        }\\n\\n        // logger.logCell(0,string.concat(\\\"_updateCellFromNeighbor  index\\\", Strings.toString(neighbourIndex)),position,cell,address(uint160(_owners[position])));\\n\\n        if ((cell.distribution >> 4) & (2 ** neighbourIndex) == 2 ** neighbourIndex) {\\n            due = (cell.stake * 12) / (cell.distribution & 0x0f);\\n            cell.distribution =\\n                (uint8(uint256(cell.distribution >> 4) & (~(2 ** uint256(neighbourIndex)))) << 4) +\\n                (cell.distribution & 0x0f);\\n        }\\n\\n        if (oldColor != newColor) {\\n            if (newColor == Color.None) {\\n                if (cell.color == oldColor) {\\n                    cell.delta -= 1;\\n                } else {\\n                    cell.delta += 1;\\n                    cell.enemyMap = cell.enemyMap & uint8((1 << neighbourIndex) ^ 0xFF);\\n                }\\n            } else if (cell.color == oldColor) {\\n                // then newColor is different (see assert above)\\n                cell.enemyMap = cell.enemyMap | uint8(1 << neighbourIndex);\\n                cell.delta -= 2;\\n            } else if (cell.color == newColor) {\\n                // then old color was different\\n                cell.delta += (oldColor == Color.None ? int8(1) : int8(2));\\n                cell.enemyMap = cell.enemyMap & uint8((1 << neighbourIndex) ^ 0xFF);\\n            } else if (oldColor == Color.None) {\\n                // if there were no oldCOlor and the newColor is not your (already checked in previous if clause)\\n                cell.delta -= 1;\\n                cell.enemyMap = cell.enemyMap | uint8(1 << neighbourIndex);\\n            }\\n        }\\n\\n        cell.lastEpochUpdate = epoch;\\n        cell.life = newLife;\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER _updateCellFromNeighbor  index\\\", Strings.toString(neighbourIndex)),position,cell,address(uint160(_owners[position])));\\n\\n        _cells[position] = cell;\\n    }\\n}\\n\",\"keccak256\":\"0x29c62a148bf908c41bff9d38888f2fe10dfb1a862b0d4d40dc2e9795130ccb3b\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsState.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsStore.sol\\\";\\nimport \\\"../interface/UsingStratagemsEvents.sol\\\";\\nimport \\\"../interface/UsingStratagemsErrors.sol\\\";\\nimport \\\"./UsingVirtualTime.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\n\\n// TODO use hardhat-preprocessor\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary logger {\\n    using PositionUtils for uint64;\\n\\n    address constant CONSOLE_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(staticcall(gas(), consoleAddress, add(payload, 32), mload(payload), 0, 0))\\n        }\\n    }\\n\\n    // _sendLogPayload(abi.encodeWithSignature('log(string,int256,int256)', 'cell %s', x, y));\\n\\n    function logPosition(string memory title, uint64 pos) internal view {\\n        (int32 x, int32 y) = pos.toXY();\\n        console.log(\\\"%s: (%s,%s)\\\", title, Strings.toString(x), Strings.toString(y));\\n    }\\n\\n    function logCell(\\n        uint8 ii,\\n        string memory title,\\n        uint64 id,\\n        UsingStratagemsTypes.Cell memory cell,\\n        address owner\\n    ) internal view {\\n        string memory indent = ii == 0\\n            ? \\\"\\\"\\n            : ii == 1\\n                ? \\\"    \\\"\\n                : ii == 2\\n                    ? \\\"        \\\"\\n                    : \\\"            \\\";\\n        // string memory indent = '';\\n        console.log(\\\"%s%s\\\", indent, title);\\n        (int32 x, int32 y) = id.toXY();\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        console.log(\\\"%scell (%s,%s)\\\", indent, Strings.toString(x), Strings.toString(y));\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        console.log(\\\"%s - lastEpochUpdate:  %s\\\", indent, cell.lastEpochUpdate);\\n        console.log(\\\"%s - epochWhenTokenIsAdded:  %s\\\", indent, cell.epochWhenTokenIsAdded);\\n        console.log(\\\"%s - color:  %s\\\", indent, uint8(cell.color));\\n        console.log(\\\"%s - life:  %s\\\", indent, cell.life);\\n        console.log(\\\"%s - distribution:  %s\\\", indent, cell.distribution);\\n        console.log(\\\"%s - owner:  %s\\\", indent, owner);\\n        console.log(\\\"%s - delta: %s\\\", indent, Strings.toString(cell.delta));\\n        console.log(\\\"%s - enemyMap:  %s\\\", indent, cell.enemyMap);\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n    }\\n\\n    function logTransfers(\\n        uint8 ii,\\n        string memory title,\\n        UsingStratagemsTypes.TokenTransferCollection memory transferCollection\\n    ) internal pure {\\n        string memory indent = ii == 0\\n            ? \\\"\\\"\\n            : ii == 1\\n                ? \\\"    \\\"\\n                : ii == 2\\n                    ? \\\"        \\\"\\n                    : \\\"            \\\";\\n        // string memory indent = '';\\n        console.log(\\\"%s%s\\\", indent, title);\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        for (uint256 i = 0; i < transferCollection.numTransfers; i++) {\\n            console.log(\\n                \\\"%stransfer (%s,%s)\\\",\\n                indent,\\n                transferCollection.transfers[i].to,\\n                Strings.toString(transferCollection.transfers[i].amount)\\n            );\\n        }\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n    }\\n}\\n\\nabstract contract UsingStratagemsState is\\n    UsingStratagemsStore,\\n    UsingStratagemsEvents,\\n    UsingStratagemsErrors,\\n    UsingVirtualTime\\n{\\n    /// @notice The token used for the game. Each gems on the board contains that token\\n    IERC20WithIERC2612 internal immutable TOKENS;\\n    /// @notice the timestamp (in seconds) at which the game start, it start in the commit phase\\n    uint256 internal immutable START_TIME;\\n    /// @notice the duration of the commit phase in seconds\\n    uint256 internal immutable COMMIT_PHASE_DURATION;\\n    /// @notice the duration of the reveal phase in seconds\\n    uint256 internal immutable REVEAL_PHASE_DURATION;\\n    /// @notice the max number of level a cell can reach in the game\\n    uint8 internal immutable MAX_LIFE;\\n    /// @notice the number of tokens underlying each gems on the board.\\n    uint256 internal immutable NUM_TOKENS_PER_GEMS;\\n    /// @notice the address to send the token to when burning\\n    address payable internal immutable BURN_ADDRESS;\\n\\n    /// @notice the number of moves a hash represent, after that players make use of furtherMoves\\n    uint8 internal constant MAX_NUM_MOVES_PER_HASH = 32;\\n\\n    /// @notice Create an instance of a Stratagems game\\n    /// @param config configuration options for the game\\n    constructor(Config memory config) UsingVirtualTime(config) {\\n        TOKENS = config.tokens;\\n        BURN_ADDRESS = config.burnAddress;\\n        START_TIME = config.startTime;\\n        COMMIT_PHASE_DURATION = config.commitPhaseDuration;\\n        REVEAL_PHASE_DURATION = config.revealPhaseDuration;\\n        MAX_LIFE = config.maxLife;\\n        NUM_TOKENS_PER_GEMS = config.numTokensPerGems;\\n    }\\n\\n    function _epoch() internal view virtual returns (uint24 epoch, bool commiting) {\\n        uint256 epochDuration = COMMIT_PHASE_DURATION + REVEAL_PHASE_DURATION;\\n        uint256 time = _timestamp();\\n        if (time < START_TIME) {\\n            revert GameNotStarted();\\n        }\\n        uint256 timePassed = time - START_TIME;\\n        epoch = uint24(timePassed / epochDuration + 2); // epoch start at 2, this make the hypothetical previous reveal phase's epoch to be 1\\n        commiting = timePassed - ((epoch - 2) * epochDuration) < COMMIT_PHASE_DURATION;\\n    }\\n\\n    function _computeNewLife(\\n        uint24 lastUpdate,\\n        uint8 enemyMap,\\n        int8 delta,\\n        uint8 life,\\n        uint24 epoch\\n    ) internal view returns (uint8 newLife, uint24 epochUsed) {\\n        epochUsed = lastUpdate;\\n        if (lastUpdate >= 1 && life > 0) {\\n            uint256 epochDelta = epoch - lastUpdate;\\n            if (epochDelta > 0) {\\n                int8 effectiveDelta = delta != 0 ? delta : -1;\\n                if (effectiveDelta < 0 && enemyMap == 0) {\\n                    effectiveDelta = 0;\\n                }\\n                if (effectiveDelta > 0) {\\n                    // if (life < MAX_LIFE) {\\n                    uint8 maxEpoch = ((MAX_LIFE - life) + uint8(effectiveDelta) - 1) / uint8(effectiveDelta);\\n                    if (epochDelta > maxEpoch) {\\n                        epochDelta = maxEpoch;\\n                    }\\n\\n                    life += uint8(epochDelta) * uint8(effectiveDelta);\\n                    if (life > MAX_LIFE) {\\n                        life = MAX_LIFE;\\n                    }\\n                    newLife = life;\\n\\n                    // we don not use the following: lastUpdate + epochDelta;\\n                    //   because no state change is foreseen with no life increase\\n                    epochUsed = epoch;\\n                    // } else {\\n                    // \\tnewLife = life;\\n                    // \\tepochUsed = lastUpdate;\\n                    // }\\n                } else if (effectiveDelta < 0) {\\n                    uint8 numEpochBeforeDying = (life + uint8(-effectiveDelta) - 1) / uint8(-effectiveDelta);\\n                    if (epochDelta > numEpochBeforeDying) {\\n                        epochDelta = numEpochBeforeDying;\\n                    }\\n                    uint8 lifeLoss = uint8(epochDelta) * uint8(-effectiveDelta);\\n                    if (lifeLoss > life) {\\n                        newLife = 0;\\n                    } else {\\n                        newLife = life - lifeLoss;\\n                    }\\n\\n                    // since we need to track when the cell died, we upate lastUpdate only to\\n                    //   the corresponding epoch where life reached 0\\n                    epochUsed = lastUpdate + uint24(epochDelta);\\n                } else {\\n                    newLife = life;\\n\\n                    // we don not use the following: lastUpdate + epochDelta;\\n                    //   because no state change is foreseen with no life change\\n                    epochUsed = epoch;\\n                }\\n            } else {\\n                newLife = life;\\n\\n                // no change, no need to update lastUpdate either ?\\n                epochUsed = lastUpdate;\\n            }\\n        }\\n    }\\n\\n    function _getUpdatedCell(uint64 position, uint24 epoch) internal view returns (Cell memory updatedCell, bool justDied) {\\n        // load from state\\n        updatedCell = _cells[position];\\n        uint24 lastUpdate = updatedCell.lastEpochUpdate;\\n        int8 delta = updatedCell.delta;\\n        uint8 life = updatedCell.life;\\n        // logger.logCell(0, 'before update', position, updatedCell, address(uint160(_owners[position])));\\n        if (lastUpdate >= 1 && life > 0) {\\n            (uint8 newLife, ) = _computeNewLife(lastUpdate, updatedCell.enemyMap, delta, life, epoch);\\n            updatedCell.life = newLife;\\n            updatedCell.lastEpochUpdate = epoch; // TODO check if this is useful to cap it to epoch where it died\\n            justDied = newLife == 0;\\n        }\\n    }\\n\\n    /// @dev Get the owner of a token.\\n    /// @param tokenID The token to query.\\n    function _ownerOf(uint256 tokenID) internal view virtual returns (address owner) {\\n        owner = address(uint160(_owners[tokenID]));\\n    }\\n}\\n\",\"keccak256\":\"0xfa21e910d250d65e382a1f38044f5036ed8ef2ccbb6644ebee417726d220b55a\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsStore.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\n\\ncontract UsingStratagemsStore is UsingStratagemsTypes {\\n    mapping(uint256 => Cell) internal _cells;\\n    mapping(uint256 => uint256) internal _owners; //owner + approval + ... erc721\\n\\n    mapping(address => uint256) internal _tokensInReserve;\\n    mapping(address => Commitment) internal _commitments;\\n\\n    // Operators (also used by ERC721)\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    // ERC721 balanceOf\\n    // mapping(address => uint256) internal _balances;\\n}\\n\",\"keccak256\":\"0x38663dfd153cbcc24ba5cfbb66410f2871eed6da17602f6886e68f051ac5be37\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\nimport \\\"../interface/UsingStratagemsErrors.sol\\\";\\n\\nabstract contract UsingStratagemsUtils is UsingStratagemsTypes, UsingStratagemsErrors {\\n    function _checkHash(\\n        bytes24 commitmentHash,\\n        bytes32 secret,\\n        Move[] memory moves,\\n        bytes24 furtherMoves\\n    ) internal pure {\\n        if (furtherMoves != bytes24(0)) {\\n            bytes24 computedHash = bytes24(keccak256(abi.encode(secret, moves, furtherMoves)));\\n            if (commitmentHash != computedHash) {\\n                revert CommitmentHashNotMatching();\\n            }\\n        } else {\\n            bytes24 computedHash = bytes24(keccak256(abi.encode(secret, moves)));\\n            if (commitmentHash != computedHash) {\\n                revert CommitmentHashNotMatching();\\n            }\\n        }\\n    }\\n\\n    function _collectTransfer(\\n        TokenTransferCollection memory transferCollection,\\n        TokenTransfer memory newTransfer\\n    ) internal pure {\\n        // we look for the newTransfer address in case it is already present\\n        for (uint256 k = 0; k < transferCollection.numTransfers; k++) {\\n            if (transferCollection.transfers[k].to == newTransfer.to) {\\n                // if we found we add the amount\\n                transferCollection.transfers[k].amount += newTransfer.amount;\\n                return;\\n            }\\n        }\\n        // if we did not find that address we add it to the end\\n        transferCollection.transfers[transferCollection.numTransfers].to = newTransfer.to;\\n        transferCollection.transfers[transferCollection.numTransfers].amount = newTransfer.amount;\\n        // and increase the size to lookup for next time\\n        transferCollection.numTransfers++;\\n    }\\n\\n    function _multiTransfer(IERC20WithIERC2612 token, TokenTransferCollection memory transferCollection) internal {\\n        for (uint256 i = 0; i < transferCollection.numTransfers; i++) {\\n            token.transfer(transferCollection.transfers[i].to, transferCollection.transfers[i].amount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62eaa33b438ebcfce77a86f2da6c6fa83853b7bf949ae5524490766d282deccb\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingVirtualTime.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\n\\nabstract contract UsingVirtualTime {\\n    // TODO use hardhat-preprocessor\\n\\n    ITime immutable _time;\\n\\n    constructor(UsingStratagemsTypes.Config memory config) {\\n        _time = config.time;\\n    }\\n\\n    function _timestamp() internal view returns (uint256) {\\n        if (address(_time) == address(0)) {\\n            return block.timestamp;\\n        }\\n        return _time.timestamp();\\n    }\\n}\\n\",\"keccak256\":\"0xc879b36cc8d50d6e3e9f086845bbd62dcaddeb99b1242400314b8c6b69a211b3\",\"license\":\"AGPL-3.0\"},\"src/game/routes/StratagemsSetters.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/IStratagems.sol\\\";\\nimport \\\"../internal/UsingStratagemsSetters.sol\\\";\\nimport \\\"../internal/UsingStratagemsUtils.sol\\\";\\n\\ncontract StratagemsSetters is IStratagemsSetters, UsingStratagemsSetters {\\n    constructor(Config memory config) UsingStratagemsSetters(config) {}\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function addToReserve(uint256 tokensAmountToAdd, Permit calldata permit) external {\\n        if (tokensAmountToAdd > 0) {\\n            uint256 newAmount = _tokensInReserve[msg.sender];\\n            newAmount += tokensAmountToAdd;\\n            _tokensInReserve[msg.sender] = newAmount;\\n\\n            if (permit.value > 0) {\\n                TOKENS.permit(msg.sender, address(this), permit.value, permit.deadline, permit.v, permit.r, permit.s);\\n            }\\n            TOKENS.transferFrom(msg.sender, address(this), tokensAmountToAdd);\\n            emit ReserveDeposited(msg.sender, tokensAmountToAdd, newAmount);\\n        }\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function makeCommitment(bytes24 commitmentHash, address payable payee) external payable {\\n        _makeCommitment(msg.sender, commitmentHash, _tokensInReserve[msg.sender]);\\n        if (payee != address(0)) {\\n            payee.transfer(msg.value);\\n        }\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function makeCommitmentWithExtraReserve(\\n        bytes24 commitmentHash,\\n        uint256 tokensAmountToAdd,\\n        Permit calldata permit,\\n        address payable payee\\n    ) external payable {\\n        uint256 inReserve = _tokensInReserve[msg.sender];\\n        inReserve += tokensAmountToAdd;\\n        _tokensInReserve[msg.sender] = inReserve;\\n\\n        _makeCommitment(msg.sender, commitmentHash, inReserve);\\n\\n        if (permit.value > 0) {\\n            TOKENS.permit(msg.sender, address(this), permit.value, permit.deadline, permit.v, permit.r, permit.s);\\n        }\\n\\n        if (tokensAmountToAdd > 0) {\\n            TOKENS.transferFrom(msg.sender, address(this), tokensAmountToAdd);\\n            emit ReserveDeposited(msg.sender, tokensAmountToAdd, inReserve);\\n        }\\n\\n        if (payee != address(0)) {\\n            payee.transfer(msg.value);\\n        }\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function cancelCommitment() external {\\n        Commitment storage commitment = _commitments[msg.sender];\\n        (uint24 epoch, bool commiting) = _epoch();\\n        if (!commiting) {\\n            revert InRevealPhase();\\n        }\\n        if (commitment.epoch != epoch) {\\n            revert PreviousCommitmentNotRevealed();\\n        }\\n\\n        // Note that we do not reset the hash\\n        // This ensure the slot do not get reset and keep the gas cost consistent across execution\\n        commitment.epoch = 0;\\n\\n        emit CommitmentCancelled(msg.sender, epoch);\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function withdrawFromReserve(uint256 amount) external {\\n        Commitment storage commitment = _commitments[msg.sender];\\n\\n        (uint24 epoch, bool commiting) = _epoch();\\n\\n        if (commitment.epoch != 0 && (!commiting || commitment.epoch != epoch)) {\\n            revert PreviousCommitmentNotRevealed();\\n        }\\n\\n        uint256 inReserve = _tokensInReserve[msg.sender];\\n        if (amount == type(uint256).max) {\\n            amount = inReserve;\\n            inReserve = 0;\\n        } else {\\n            if (inReserve < amount) {\\n                revert ReserveTooLow(inReserve, amount);\\n            }\\n            inReserve -= amount;\\n        }\\n        _tokensInReserve[msg.sender] = inReserve;\\n        TOKENS.transfer(msg.sender, amount);\\n        emit ReserveWithdrawn(msg.sender, amount, inReserve);\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function reveal(\\n        address player,\\n        bytes32 secret,\\n        Move[] calldata moves,\\n        bytes24 furtherMoves,\\n        bool useReserve,\\n        address payable payee\\n    ) external payable {\\n        Commitment storage commitment = _commitments[player];\\n        (uint24 epoch, bool commiting) = _epoch();\\n\\n        if (commiting) {\\n            revert InCommitmentPhase();\\n        }\\n        if (commitment.epoch == 0) {\\n            revert NothingToReveal();\\n        }\\n        if (commitment.epoch != epoch) {\\n            revert InvalidEpoch();\\n        }\\n\\n        _checkHash(commitment.hash, secret, moves, furtherMoves);\\n\\n        uint256 newReserveAmount = _resolveMoves(player, epoch, moves, useReserve ? address(0) : player);\\n\\n        bytes24 hashRevealed = commitment.hash;\\n        if (furtherMoves != bytes24(0)) {\\n            if (moves.length != MAX_NUM_MOVES_PER_HASH) {\\n                revert InvalidFurtherMoves();\\n            }\\n            commitment.hash = furtherMoves;\\n        } else {\\n            commitment.epoch = 0; // used\\n        }\\n\\n        emit CommitmentRevealed(player, epoch, hashRevealed, moves, furtherMoves, newReserveAmount);\\n\\n        if (payee != address(0)) {\\n            payee.transfer(msg.value);\\n        }\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function acknowledgeMissedReveal(\\n        address player,\\n        bytes32 secret,\\n        Move[] calldata moves,\\n        bytes24 furtherMoves\\n    ) external {\\n        Commitment storage commitment = _commitments[player];\\n        (uint24 epoch, ) = _epoch();\\n        if (commitment.epoch == 0 || commitment.epoch == epoch) {\\n            revert CanStillReveal();\\n        }\\n\\n        uint256 numMoves = moves.length;\\n\\n        _checkHash(commitment.hash, secret, moves, furtherMoves);\\n\\n        if (furtherMoves != bytes24(0)) {\\n            if (numMoves != MAX_NUM_MOVES_PER_HASH) {\\n                revert InvalidFurtherMoves();\\n            }\\n            commitment.hash = furtherMoves;\\n        } else {\\n            commitment.epoch = 0; // used\\n        }\\n\\n        uint256 amount = moves.length;\\n        _tokensInReserve[msg.sender] -= amount;\\n        TOKENS.transfer(BURN_ADDRESS, amount);\\n        emit CommitmentVoid(player, epoch, amount, furtherMoves);\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function acknowledgeMissedRevealByBurningAllReserve() external {\\n        Commitment storage commitment = _commitments[msg.sender];\\n        (uint24 epoch, ) = _epoch();\\n\\n        if (commitment.epoch == 0) {\\n            revert NothingToReveal();\\n        }\\n\\n        if (commitment.epoch == epoch) {\\n            revert CanStillReveal();\\n        }\\n\\n        commitment.epoch = 0;\\n        uint256 amount = _tokensInReserve[msg.sender];\\n        _tokensInReserve[msg.sender] = 0;\\n        TOKENS.transfer(BURN_ADDRESS, amount);\\n\\n        // here we cannot know whether there were further move or even any moves\\n        // we just burn all tokens in reserve\\n        emit CommitmentVoid(msg.sender, epoch, amount, bytes24(0));\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function poke(uint64 position) external {\\n        (uint24 epoch, ) = _epoch();\\n\\n        // max number of transfer is 5 (for each neighbour's potentially being a different account + own cell)\\n\\n        TokenTransferCollection memory transferCollection = TokenTransferCollection({\\n            transfers: new TokenTransfer[](5),\\n            numTransfers: 0\\n        });\\n        _poke(transferCollection, position, epoch);\\n\\n        _multiTransfer(TOKENS, transferCollection);\\n\\n        emit SinglePoke(epoch, position);\\n    }\\n\\n    /// @inheritdoc IStratagemsSetters\\n    function pokeMultiple(uint64[] calldata positions) external {\\n        (uint24 epoch, ) = _epoch();\\n\\n        uint256 numCells = positions.length;\\n        // max number of transfer is 4 * numCells (for each cell's neighbours potentially being a different account + own cell)\\n        TokenTransferCollection memory transferCollection = TokenTransferCollection({\\n            transfers: new TokenTransfer[](numCells * 5),\\n            numTransfers: 0\\n        });\\n        for (uint256 i = 0; i < numCells; i++) {\\n            _poke(transferCollection, positions[i], epoch);\\n        }\\n        _multiTransfer(TOKENS, transferCollection);\\n\\n        emit MultiPoke(epoch, positions);\\n    }\\n}\\n\",\"keccak256\":\"0xc14b0723e368b826c774ec92c92bb588c8f25323e3f647ab43aef31e9e791a61\",\"license\":\"AGPL-3.0\"},\"src/utils/PositionUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary PositionUtils {\\n    function toXY(uint64 position) internal pure returns (int32 x, int32 y) {\\n        x = int32(uint32(position) & 0xFFFFFFFF);\\n        y = int32(uint32(position >> 32));\\n    }\\n\\n    function offset(uint64 position, int32 x, int32 y) internal pure returns (uint64 newPosition) {\\n        x = int32(uint32(position) & 0xFFFFFFFF) + x;\\n        y = int32(uint32(position >> 32)) + y;\\n        newPosition = (uint64(uint32(y)) << 32) + uint64(uint32(x));\\n    }\\n}\\n\",\"keccak256\":\"0x82dcff44b73db30e108027baaa503a39f30c3e1accbf0133c52f4615e8f5d70c\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 14892,
        "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
        "label": "_cells",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Cell)12541_storage)"
      },
      {
        "astId": 14896,
        "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
        "label": "_owners",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 14900,
        "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
        "label": "_tokensInReserve",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 14905,
        "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
        "label": "_commitments",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_struct(Commitment)12546_storage)"
      },
      {
        "astId": 14911,
        "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
        "label": "_operatorsForAll",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 14915,
        "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
        "label": "_operators",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_uint256,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes24": {
        "encoding": "inplace",
        "label": "bytes24",
        "numberOfBytes": "24"
      },
      "t_enum(Color)12463": {
        "encoding": "inplace",
        "label": "enum UsingStratagemsTypes.Color",
        "numberOfBytes": "1"
      },
      "t_int8": {
        "encoding": "inplace",
        "label": "int8",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_struct(Commitment)12546_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct UsingStratagemsTypes.Commitment)",
        "numberOfBytes": "32",
        "value": "t_struct(Commitment)12546_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Cell)12541_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct UsingStratagemsTypes.Cell)",
        "numberOfBytes": "32",
        "value": "t_struct(Cell)12541_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Cell)12541_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Cell",
        "members": [
          {
            "astId": 12525,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "lastEpochUpdate",
            "offset": 0,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 12527,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "epochWhenTokenIsAdded",
            "offset": 3,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 12530,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "color",
            "offset": 6,
            "slot": "0",
            "type": "t_enum(Color)12463"
          },
          {
            "astId": 12532,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "life",
            "offset": 7,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 12534,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "delta",
            "offset": 8,
            "slot": "0",
            "type": "t_int8"
          },
          {
            "astId": 12536,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "enemyMap",
            "offset": 9,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 12538,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "distribution",
            "offset": 10,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 12540,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "stake",
            "offset": 11,
            "slot": "0",
            "type": "t_uint8"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Commitment)12546_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Commitment",
        "members": [
          {
            "astId": 12543,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "hash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes24"
          },
          {
            "astId": 12545,
            "contract": "src/game/routes/StratagemsSetters.sol:StratagemsSetters",
            "label": "epoch",
            "offset": 24,
            "slot": "0",
            "type": "t_uint24"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  },
  "userdoc": {
    "errors": {
      "CanStillReveal()": [
        {
          "notice": "Player have to reveal if they can Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal."
        }
      ],
      "CommitmentHashNotMatching()": [
        {
          "notice": "Player have to reveal their commitment using the exact same move values  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal."
        }
      ],
      "GameNotStarted()": [
        {
          "notice": "Game has not started yet, can't perform any action"
        }
      ],
      "InCommitmentPhase()": [
        {
          "notice": "When in Commit phase, player can make new commitment but they cannot reveal their move yet."
        }
      ],
      "InRevealPhase()": [
        {
          "notice": "When in Reveal phase, it is not possible to commit new moves or cancel previous commitment  During Reveal phase, players have to reveal their commitment, if not already done."
        }
      ],
      "InvalidEpoch()": [
        {
          "notice": "Player can only reveal their move in the same epoch they commited.abi  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`"
        }
      ],
      "InvalidFurtherMoves()": [
        {
          "notice": "Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves  This result in a recursive series of hash that they can then submit in turn while revealing.  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block."
        }
      ],
      "NothingToReveal()": [
        {
          "notice": "Player can only reveal moves they commited."
        }
      ],
      "PreviousCommitmentNotRevealed()": [
        {
          "notice": "Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\"
        }
      ],
      "ReserveTooLow(uint256,uint256)": [
        {
          "notice": "to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase."
        }
      ]
    },
    "events": {
      "CommitmentCancelled(address,uint24)": {
        "notice": "A player has cancelled its current commitment (before it reached the reveal phase)"
      },
      "CommitmentMade(address,uint24,bytes24)": {
        "notice": "A player has commited to make a move and reveal it on the reveal phase"
      },
      "CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)": {
        "notice": "Player has revealed its previous commitment"
      },
      "CommitmentVoid(address,uint24,uint256,bytes24)": {
        "notice": "A player has canceled a previous commitment by burning some tokens"
      },
      "MoveProcessed(uint64,address,uint8,uint8)": {
        "notice": "A move has been revealed."
      },
      "MultiPoke(uint24,uint64[])": {
        "notice": "poke multiple cells and update them if needed"
      },
      "ReserveDeposited(address,uint256,uint256)": {
        "notice": "Player has deposited token in the reserve, allowing it to use that much in game"
      },
      "ReserveWithdrawn(address,uint256,uint256)": {
        "notice": "Player have withdrawn token from the reserve"
      },
      "SinglePoke(uint24,uint64)": {
        "notice": "poke cell and update it if needed"
      }
    },
    "kind": "user",
    "methods": {
      "acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)": {
        "notice": "called by player if they missed the reveal phase and want to minimze the token loss.  By providing the moves, they will be slashed only the amount of token required to make the moves"
      },
      "acknowledgeMissedRevealByBurningAllReserve()": {
        "notice": "should only be called as last resort this will burn all tokens in reserve If player has access to the secret, better call `acknowledgeMissedReveal`"
      },
      "addToReserve(uint256,(uint256,uint256,uint8,bytes32,bytes32))": {
        "notice": "called by players to add tokens to their reserve"
      },
      "cancelCommitment()": {
        "notice": "called by players to cancel their current commitment  Can only be called during the commit phase in which the commitment was made  It cannot be called afterward"
      },
      "makeCommitment(bytes24,address)": {
        "notice": "called by players to commit their moves  this can be called multiple time in the same epoch, the last call overriding the previous.  When a commitment is made, it needs to be revealed in the reveal phase of the same epoch.abi  If missed, player can still reveal its moves but none of them will be resolved.   The player would lose its associated reserved amount."
      },
      "makeCommitmentWithExtraReserve(bytes24,uint256,(uint256,uint256,uint8,bytes32,bytes32),address)": {
        "notice": "called to make a commitment along with tokens to add to the reserve"
      },
      "pokeMultiple(uint64[])": {
        "notice": "poke and collect the tokens won across multiple cells"
      },
      "reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)": {
        "notice": "called by player to reveal their moves  this is where the core logic of the game takes place  This is where the game board evolves  The game is designed so that reveal order does not matter"
      },
      "withdrawFromReserve(uint256)": {
        "notice": "called by players to withdraw tokens from the reserve  can only be called if no commitments are pending  Note that while you can withdraw after commiting, note that if you do not have enough tokens  you'll have your commitment failing."
      }
    },
    "version": 1
  },
  "argsData": "0x00000000000000000000000063173432497d7c0d1f7e6d589991e56286bb11c3000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000143700000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000088c7467d61c8611f4dcc0d935b2c10af964750ac",
  "transaction": {
    "hash": "0x895e0ece931dd27c410bf02320efa547cb0a9f29801da4812edcbef6b54ee6da",
    "nonce": "0x19c",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "confirmations": 0,
    "blockHash": "0xa1cb743f8e364548c3dc97ca851abb101b8336131245a1256a7249fcb0b78947",
    "blockNumber": "0x509080",
    "transactionIndex": "0x50"
  }
}