{
  "address": "0x869f7a880857ab0fd903742a95c9f463e8edc35e",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract IERC20WithIERC2612",
              "name": "tokens",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "burnAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "commitPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revealPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "maxLife",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "numTokensPerGems",
              "type": "uint256"
            },
            {
              "internalType": "contract ITime",
              "name": "time",
              "type": "address"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CanStillReveal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CommitmentHashNotMatching",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "GameNotStarted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InCommitmentPhase",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InRevealPhase",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "InvalidAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEpoch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFurtherMoves",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "NonExistentToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NonceOverflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAuthorized",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provided",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "currentOwner",
          "type": "address"
        }
      ],
      "name": "NotOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NothingToReveal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PreviousCommitmentNotRevealed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "inReserve",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expected",
          "type": "uint256"
        }
      ],
      "name": "ReserveTooLow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferRejected",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        }
      ],
      "name": "CommitmentCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentMade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": true,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "enum UsingStratagemsTypes.Color",
              "name": "color",
              "type": "uint8"
            }
          ],
          "indexed": false,
          "internalType": "struct UsingStratagemsTypes.Move[]",
          "name": "moves",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newReserveAmount",
          "type": "uint256"
        }
      ],
      "name": "CommitmentRevealed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountBurnt",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentVoid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum UsingStratagemsTypes.Color",
          "name": "oldColor",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "enum UsingStratagemsTypes.Color",
          "name": "newColor",
          "type": "uint8"
        }
      ],
      "name": "MoveProcessed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint64[]",
          "name": "positions",
          "type": "uint64[]"
        }
      ],
      "name": "MultiPoke",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountDeposited",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "ReserveDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountWithdrawn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "ReserveWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        }
      ],
      "name": "SinglePoke",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "tokenIDs",
          "type": "uint256[]"
        }
      ],
      "name": "ownerAndLastTransferBlockNumberList",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "lastTransferBlockNumber",
              "type": "uint256"
            }
          ],
          "internalType": "struct IERC721WithBlocknumber.OwnerData[]",
          "name": "ownersData",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "ownerAndLastTransferBlockNumberOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "StratagemsERC721",
  "sourceName": "src/game/routes/StratagemsERC721.sol",
  "bytecode": "0x6101806040523480156200001257600080fd5b5060405162001805380380620018058339810160408190526200003591620000be565b60e0808201516001600160a01b0390811660809081528351821660a0908152602085015190921661016052604084015160c090815260608501519093528301516101005282015160ff16610120520151610140526200017e565b80516001600160a01b0381168114620000a757600080fd5b919050565b805160ff81168114620000a757600080fd5b6000610100808385031215620000d357600080fd5b604051908101906001600160401b03821181831017156200010457634e487b7160e01b600052604160045260246000fd5b8160405262000113846200008f565b815262000123602085016200008f565b60208201526040840151604082015260608401516060820152608084015160808201526200015460a08501620000ac565b60a082015260c084015160c08201526200017160e085016200008f565b60e0820152949350505050565b60805160a05160c05160e05161010051610120516101405161016051611639620001cc60003960005050600050506000505060005050600050506000505060005050600050506116396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c80636352211e11610097578063b88d4fde11610066578063b88d4fde146102b3578063c87b56dd146102c6578063e985e9c5146102da578063f39452821461032357600080fd5b80636352211e1461023357806370a082311461024657806395d89b4114610267578063a22cb465146102a057600080fd5b8063095ea7b3116100d3578063095ea7b31461019c57806323b872dd146101b157806342842e0e146101c457806348f3c51c146101d757600080fd5b806301ffc9a7146100fa57806306fdde0314610122578063081812fc14610164575b600080fd5b61010d610108366004611129565b610343565b60405190151581526020015b60405180910390f35b60408051808201909152600881527f47656d43656c6c7300000000000000000000000000000000000000000000000060208201525b60405161011991906111b1565b6101776101723660046111c4565b610428565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610119565b6101af6101aa366004611201565b6104ec565b005b6101af6101bf36600461122b565b6105fd565b6101af6101d236600461122b565b61087b565b6102076101e53660046111c4565b6000908152600160205260409020549067ffffffffffffffff60b883901c1690565b6040805173ffffffffffffffffffffffffffffffffffffffff9093168352602083019190915201610119565b6101776102413660046111c4565b61089b565b610259610254366004611267565b6108ff565b604051908152602001610119565b60408051808201909152600881527f47454d5f43454c4c0000000000000000000000000000000000000000000000006020820152610157565b6101af6102ae366004611282565b610964565b6101af6102c13660046112ed565b610973565b6101576102d43660046111c4565b50606090565b61010d6102e83660046113e7565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260046020908152604080832093909416825291909152205460ff1690565b61033661033136600461141a565b610bf3565b604051610119919061148f565b60007f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614806103d657507f80ac58cd000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b8061042257507f5b5e139f000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6000818152600160205260408120547f80000000000000000000000000000000000000000000000000000000000000008082161473ffffffffffffffffffffffffffffffffffffffff82166104b1576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018590526024015b60405180910390fd5b80156104e25750505060009081526005602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b5060009392505050565b6000818152600160205260409020546affffffffffffffffffffff60a082901c1673ffffffffffffffffffffffffffffffffffffffff821661055d576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018490526024016104a8565b3373ffffffffffffffffffffffffffffffffffffffff8316148015906105b4575073ffffffffffffffffffffffffffffffffffffffff8216600090815260046020908152604080832033845290915290205460ff16155b156105eb576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6105f782828686610d2b565b50505050565b6000818152600160205260409020546affffffffffffffffffffff60a082901c167f80000000000000000000000000000000000000000000000000000000000000008083161473ffffffffffffffffffffffffffffffffffffffff8316610693576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018590526024016104a8565b8273ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614610718576040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8088166004830152841660248201526044016104a8565b73ffffffffffffffffffffffffffffffffffffffff85161580610750575073ffffffffffffffffffffffffffffffffffffffff851630145b1561079f576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff861660048201526024016104a8565b3373ffffffffffffffffffffffffffffffffffffffff871614610861578080156107ec575060008481526005602052604090205473ffffffffffffffffffffffffffffffffffffffff1633145b15801561082a575073ffffffffffffffffffffffffffffffffffffffff8616600090815260046020908152604080832033845290915290205460ff16155b15610861576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610873868686601886901c1515610eb6565b505050505050565b61089683838360405180602001604052806000815250610973565b505050565b60008181526001602052604090205473ffffffffffffffffffffffffffffffffffffffff81166108fa576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018390526024016104a8565b919050565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4e4f545f494d504c454d454e544544000000000000000000000000000000000060448201526000906064016104a8565b61096f338383610f18565b5050565b6000828152600160205260409020546affffffffffffffffffffff60a082901c167f80000000000000000000000000000000000000000000000000000000000000008083161473ffffffffffffffffffffffffffffffffffffffff8316610a09576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018690526024016104a8565b8673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614610a8e576040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8089166004830152841660248201526044016104a8565b73ffffffffffffffffffffffffffffffffffffffff86161580610ac6575073ffffffffffffffffffffffffffffffffffffffff861630145b15610b15576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff871660048201526024016104a8565b3373ffffffffffffffffffffffffffffffffffffffff881614610bd757808015610b62575060008581526005602052604090205473ffffffffffffffffffffffffffffffffffffffff1633145b158015610ba0575073ffffffffffffffffffffffffffffffffffffffff8716600090815260046020908152604080832033845290915290205460ff16155b15610bd7576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610bea878787601886901c151588610fb0565b50505050505050565b60608167ffffffffffffffff811115610c0e57610c0e6112be565b604051908082528060200260200182016040528015610c5357816020015b6040805180820190915260008082526020820152815260200190600190039081610c2c5790505b50905060005b82811015610d2457600060016000868685818110610c7957610c796114f4565b90506020020135815260200190815260200160002054905080838381518110610ca457610ca46114f4565b60200260200101516000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060b881901c67ffffffffffffffff16838381518110610d0357610d036114f4565b60209081029190910181015101525080610d1c81611552565b915050610c59565b5092915050565b601883901c6000610d3d85600161158a565b905081601882901c14610d7c576040517fadc1557200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8416610dc957600083815260016020526040902060a082901b73ffffffffffffffffffffffffffffffffffffffff8816179055610e53565b600083815260016020908152604080832073ffffffffffffffffffffffffffffffffffffffff8a811660a087901b177f800000000000000000000000000000000000000000000000000000000000000017909155600590925290912080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169186169190911790555b828473ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a4505050505050565b6000828152600160205260408082204360b81b73ffffffffffffffffffffffffffffffffffffffff80881691821790925591518593918816917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a450505050565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526004602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b610fbc85858585610eb6565b73ffffffffffffffffffffffffffffffffffffffff84163b1561101c57610fe63386868685611023565b61101c576040517f4e472e5e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050565b6000808473ffffffffffffffffffffffffffffffffffffffff1663150b7a02888887876040518563ffffffff1660e01b8152600401611065949392919061159d565b6020604051808303816000875af1158015611084573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a891906115e6565b7fffffffff00000000000000000000000000000000000000000000000000000000167f150b7a02000000000000000000000000000000000000000000000000000000001491505095945050505050565b7fffffffff000000000000000000000000000000000000000000000000000000008116811461112657600080fd5b50565b60006020828403121561113b57600080fd5b8135611146816110f8565b9392505050565b6000815180845260005b8181101561117357602081850181015186830182015201611157565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b602081526000611146602083018461114d565b6000602082840312156111d657600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff811681146108fa57600080fd5b6000806040838503121561121457600080fd5b61121d836111dd565b946020939093013593505050565b60008060006060848603121561124057600080fd5b611249846111dd565b9250611257602085016111dd565b9150604084013590509250925092565b60006020828403121561127957600080fd5b611146826111dd565b6000806040838503121561129557600080fd5b61129e836111dd565b9150602083013580151581146112b357600080fd5b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000806000806080858703121561130357600080fd5b61130c856111dd565b935061131a602086016111dd565b925060408501359150606085013567ffffffffffffffff8082111561133e57600080fd5b818701915087601f83011261135257600080fd5b813581811115611364576113646112be565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156113aa576113aa6112be565b816040528281528a60208487010111156113c357600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b600080604083850312156113fa57600080fd5b611403836111dd565b9150611411602084016111dd565b90509250929050565b6000806020838503121561142d57600080fd5b823567ffffffffffffffff8082111561144557600080fd5b818501915085601f83011261145957600080fd5b81358181111561146857600080fd5b8660208260051b850101111561147d57600080fd5b60209290920196919550909350505050565b602080825282518282018190526000919060409081850190868401855b828110156114e7578151805173ffffffffffffffffffffffffffffffffffffffff1685528601518685015292840192908501906001016114ac565b5091979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361158357611583611523565b5060010190565b8082018082111561042257610422611523565b600073ffffffffffffffffffffffffffffffffffffffff8087168352808616602084015250836040830152608060608301526115dc608083018461114d565b9695505050505050565b6000602082840312156115f857600080fd5b8151611146816110f856fea26469706673582212204a8d42548c2b4caa9714e271d84fec639e748506af0feb4fffe02e46eb4e4e8c64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100f55760003560e01c80636352211e11610097578063b88d4fde11610066578063b88d4fde146102b3578063c87b56dd146102c6578063e985e9c5146102da578063f39452821461032357600080fd5b80636352211e1461023357806370a082311461024657806395d89b4114610267578063a22cb465146102a057600080fd5b8063095ea7b3116100d3578063095ea7b31461019c57806323b872dd146101b157806342842e0e146101c457806348f3c51c146101d757600080fd5b806301ffc9a7146100fa57806306fdde0314610122578063081812fc14610164575b600080fd5b61010d610108366004611129565b610343565b60405190151581526020015b60405180910390f35b60408051808201909152600881527f47656d43656c6c7300000000000000000000000000000000000000000000000060208201525b60405161011991906111b1565b6101776101723660046111c4565b610428565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610119565b6101af6101aa366004611201565b6104ec565b005b6101af6101bf36600461122b565b6105fd565b6101af6101d236600461122b565b61087b565b6102076101e53660046111c4565b6000908152600160205260409020549067ffffffffffffffff60b883901c1690565b6040805173ffffffffffffffffffffffffffffffffffffffff9093168352602083019190915201610119565b6101776102413660046111c4565b61089b565b610259610254366004611267565b6108ff565b604051908152602001610119565b60408051808201909152600881527f47454d5f43454c4c0000000000000000000000000000000000000000000000006020820152610157565b6101af6102ae366004611282565b610964565b6101af6102c13660046112ed565b610973565b6101576102d43660046111c4565b50606090565b61010d6102e83660046113e7565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260046020908152604080832093909416825291909152205460ff1690565b61033661033136600461141a565b610bf3565b604051610119919061148f565b60007f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614806103d657507f80ac58cd000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b8061042257507f5b5e139f000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6000818152600160205260408120547f80000000000000000000000000000000000000000000000000000000000000008082161473ffffffffffffffffffffffffffffffffffffffff82166104b1576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018590526024015b60405180910390fd5b80156104e25750505060009081526005602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b5060009392505050565b6000818152600160205260409020546affffffffffffffffffffff60a082901c1673ffffffffffffffffffffffffffffffffffffffff821661055d576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018490526024016104a8565b3373ffffffffffffffffffffffffffffffffffffffff8316148015906105b4575073ffffffffffffffffffffffffffffffffffffffff8216600090815260046020908152604080832033845290915290205460ff16155b156105eb576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6105f782828686610d2b565b50505050565b6000818152600160205260409020546affffffffffffffffffffff60a082901c167f80000000000000000000000000000000000000000000000000000000000000008083161473ffffffffffffffffffffffffffffffffffffffff8316610693576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018590526024016104a8565b8273ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff1614610718576040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8088166004830152841660248201526044016104a8565b73ffffffffffffffffffffffffffffffffffffffff85161580610750575073ffffffffffffffffffffffffffffffffffffffff851630145b1561079f576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff861660048201526024016104a8565b3373ffffffffffffffffffffffffffffffffffffffff871614610861578080156107ec575060008481526005602052604090205473ffffffffffffffffffffffffffffffffffffffff1633145b15801561082a575073ffffffffffffffffffffffffffffffffffffffff8616600090815260046020908152604080832033845290915290205460ff16155b15610861576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610873868686601886901c1515610eb6565b505050505050565b61089683838360405180602001604052806000815250610973565b505050565b60008181526001602052604090205473ffffffffffffffffffffffffffffffffffffffff81166108fa576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018390526024016104a8565b919050565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4e4f545f494d504c454d454e544544000000000000000000000000000000000060448201526000906064016104a8565b61096f338383610f18565b5050565b6000828152600160205260409020546affffffffffffffffffffff60a082901c167f80000000000000000000000000000000000000000000000000000000000000008083161473ffffffffffffffffffffffffffffffffffffffff8316610a09576040517f38077a2b000000000000000000000000000000000000000000000000000000008152600481018690526024016104a8565b8673ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614610a8e576040517f23295f0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8089166004830152841660248201526044016104a8565b73ffffffffffffffffffffffffffffffffffffffff86161580610ac6575073ffffffffffffffffffffffffffffffffffffffff861630145b15610b15576040517f8e4c8aa600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff871660048201526024016104a8565b3373ffffffffffffffffffffffffffffffffffffffff881614610bd757808015610b62575060008581526005602052604090205473ffffffffffffffffffffffffffffffffffffffff1633145b158015610ba0575073ffffffffffffffffffffffffffffffffffffffff8716600090815260046020908152604080832033845290915290205460ff16155b15610bd7576040517fea8e4eb500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610bea878787601886901c151588610fb0565b50505050505050565b60608167ffffffffffffffff811115610c0e57610c0e6112be565b604051908082528060200260200182016040528015610c5357816020015b6040805180820190915260008082526020820152815260200190600190039081610c2c5790505b50905060005b82811015610d2457600060016000868685818110610c7957610c796114f4565b90506020020135815260200190815260200160002054905080838381518110610ca457610ca46114f4565b60200260200101516000019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505060b881901c67ffffffffffffffff16838381518110610d0357610d036114f4565b60209081029190910181015101525080610d1c81611552565b915050610c59565b5092915050565b601883901c6000610d3d85600161158a565b905081601882901c14610d7c576040517fadc1557200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff8416610dc957600083815260016020526040902060a082901b73ffffffffffffffffffffffffffffffffffffffff8816179055610e53565b600083815260016020908152604080832073ffffffffffffffffffffffffffffffffffffffff8a811660a087901b177f800000000000000000000000000000000000000000000000000000000000000017909155600590925290912080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169186169190911790555b828473ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a4505050505050565b6000828152600160205260408082204360b81b73ffffffffffffffffffffffffffffffffffffffff80881691821790925591518593918816917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a450505050565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526004602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b610fbc85858585610eb6565b73ffffffffffffffffffffffffffffffffffffffff84163b1561101c57610fe63386868685611023565b61101c576040517f4e472e5e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050565b6000808473ffffffffffffffffffffffffffffffffffffffff1663150b7a02888887876040518563ffffffff1660e01b8152600401611065949392919061159d565b6020604051808303816000875af1158015611084573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a891906115e6565b7fffffffff00000000000000000000000000000000000000000000000000000000167f150b7a02000000000000000000000000000000000000000000000000000000001491505095945050505050565b7fffffffff000000000000000000000000000000000000000000000000000000008116811461112657600080fd5b50565b60006020828403121561113b57600080fd5b8135611146816110f8565b9392505050565b6000815180845260005b8181101561117357602081850181015186830182015201611157565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b602081526000611146602083018461114d565b6000602082840312156111d657600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff811681146108fa57600080fd5b6000806040838503121561121457600080fd5b61121d836111dd565b946020939093013593505050565b60008060006060848603121561124057600080fd5b611249846111dd565b9250611257602085016111dd565b9150604084013590509250925092565b60006020828403121561127957600080fd5b611146826111dd565b6000806040838503121561129557600080fd5b61129e836111dd565b9150602083013580151581146112b357600080fd5b809150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000806000806080858703121561130357600080fd5b61130c856111dd565b935061131a602086016111dd565b925060408501359150606085013567ffffffffffffffff8082111561133e57600080fd5b818701915087601f83011261135257600080fd5b813581811115611364576113646112be565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019083821181831017156113aa576113aa6112be565b816040528281528a60208487010111156113c357600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b600080604083850312156113fa57600080fd5b611403836111dd565b9150611411602084016111dd565b90509250929050565b6000806020838503121561142d57600080fd5b823567ffffffffffffffff8082111561144557600080fd5b818501915085601f83011261145957600080fd5b81358181111561146857600080fd5b8660208260051b850101111561147d57600080fd5b60209290920196919550909350505050565b602080825282518282018190526000919060409081850190868401855b828110156114e7578151805173ffffffffffffffffffffffffffffffffffffffff1685528601518685015292840192908501906001016114ac565b5091979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361158357611583611523565b5060010190565b8082018082111561042257610422611523565b600073ffffffffffffffffffffffffffffffffffffffff8087168352808616602084015250836040830152608060608301526115dc608083018461114d565b9695505050505050565b6000602082840312156115f857600080fd5b8151611146816110f856fea26469706673582212204a8d42548c2b4caa9714e271d84fec639e748506af0feb4fffe02e46eb4e4e8c64736f6c63430008140033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "errors": {
      "InvalidAddress(address)": [
        {
          "params": {
            "addr": "invalid address"
          }
        }
      ],
      "NonExistentToken(uint256)": [
        {
          "params": {
            "tokenID": "id of the expected token"
          }
        }
      ],
      "NotOwner(address,address)": [
        {
          "params": {
            "currentOwner": "the current owner",
            "provided": "the address expected to be the current owner"
          }
        }
      ],
      "ReserveTooLow(uint256,uint256)": [
        {
          "params": {
            "expected": "amount required to proceed",
            "inReserve": "amount in reserver as the time of the call"
          }
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "params": {
          "approved": "account who can know transfer on the owner's behalf",
          "owner": "current owner of the token",
          "tokenID": "id of the token being approved"
        }
      },
      "ApprovalForAll(address,address,bool)": {
        "params": {
          "approved": "whether it is approved or not",
          "operator": "account who can know transfer on the owner's behalf",
          "owner": "the account granting rights over all of its token"
        }
      },
      "CommitmentCancelled(address,uint24)": {
        "params": {
          "epoch": "epoch number on which this commit belongs to",
          "player": "account taking the staking risk (can be a different account than the one controlling the gems)"
        }
      },
      "CommitmentMade(address,uint24,bytes24)": {
        "params": {
          "commitmentHash": "the hash of moves",
          "epoch": "epoch number on which this commit belongs to",
          "player": "account taking the staking risk (can be a different account than the one controlling the gems)"
        }
      },
      "CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)": {
        "params": {
          "commitmentHash": "the hash of the moves",
          "epoch": "epoch number on which this commit belongs to",
          "furtherMoves": "hash of further moves, unless bytes32(0) which indicate end.",
          "moves": "the moves",
          "player": "account who commited"
        }
      },
      "CommitmentVoid(address,uint24,uint256,bytes24)": {
        "params": {
          "amountBurnt": "amount of token to burn",
          "epoch": "epoch number on which this commit belongs to",
          "furtherMoves": "hash of further moves, unless bytes32(0) which indicate end.",
          "player": "the account that made the commitment"
        }
      },
      "MoveProcessed(uint64,address,uint8,uint8)": {
        "params": {
          "newColor": "color that takes over",
          "oldColor": "previous color of the cell",
          "player": "account making the move",
          "position": "cell at which the move take place"
        }
      },
      "MultiPoke(uint24,uint64[])": {
        "params": {
          "epoch": "epoch number at which the poke take place",
          "positions": "cells to poke"
        }
      },
      "ReserveDeposited(address,uint256,uint256)": {
        "params": {
          "amountDeposited": "the number of tokens deposited",
          "newAmount": "the number of tokens in reserver as a result",
          "player": "account receiving the token in the reserve"
        }
      },
      "ReserveWithdrawn(address,uint256,uint256)": {
        "params": {
          "amountWithdrawn": "the number of tokens withdrawnn",
          "newAmount": "the number of tokens in reserver as a result",
          "player": "account withdrawing the tokens"
        }
      },
      "SinglePoke(uint24,uint64)": {
        "params": {
          "epoch": "epoch number at which the poke take place",
          "position": "cell to poke"
        }
      },
      "Transfer(address,address,uint256)": {
        "params": {
          "from": "the account the token is sent from",
          "to": "the account the token is sent to",
          "tokenID": "id of the token being sent"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "approve(address,uint256)": {
        "params": {
          "operator": "The address receiving the approval.",
          "tokenID": "The id of the token."
        }
      },
      "getApproved(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "operator": "The address of the operator."
        }
      },
      "isApprovedForAll(address,address)": {
        "params": {
          "operator": "The address of the operator.",
          "owner": "The address of the owner."
        },
        "returns": {
          "_0": "isOperator The status of the approval."
        }
      },
      "ownerAndLastTransferBlockNumberList(uint256[])": {
        "params": {
          "tokenIDs": "The list of token ids to check."
        },
        "returns": {
          "ownersData": "The list of (owner, lastTransferBlockNumber) for each ids given as input."
        }
      },
      "ownerAndLastTransferBlockNumberOf(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "blockNumber": "The blocknumber at which the last transfer of that id happened.",
          "owner": "The address of the token owner."
        }
      },
      "ownerOf(uint256)": {
        "params": {
          "tokenID": "The id of the token."
        },
        "returns": {
          "owner": "The address of the token owner."
        }
      },
      "safeTransferFrom(address,address,uint256)": {
        "params": {
          "from": "The send of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "params": {
          "data": "Additional data.",
          "from": "The sender of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      },
      "setApprovalForAll(address,bool)": {
        "params": {
          "approved": "The determination of the approval.",
          "operator": "The address receiving the approval."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.",
        "params": {
          "interfaceID": "The interface identifier, as specified in ERC-165"
        },
        "returns": {
          "_0": "`true` if the contract implements `interfaceID` and  `interfaceID` is not 0xffffffff, `false` otherwise"
        }
      },
      "tokenURI(uint256)": {
        "details": "Throws if `tokenID` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the \"ERC721  Metadata JSON Schema\".",
        "params": {
          "tokenID": "id of the token being queried."
        }
      },
      "transferFrom(address,address,uint256)": {
        "params": {
          "from": "The sender of the token.",
          "to": "The recipient of the token.",
          "tokenID": "The id of the token."
        }
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "1137800",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "approve(address,uint256)": "53498",
        "balanceOf(address)": "443",
        "getApproved(uint256)": "4765",
        "isApprovedForAll(address,address)": "infinite",
        "name()": "infinite",
        "ownerAndLastTransferBlockNumberList(uint256[])": "infinite",
        "ownerAndLastTransferBlockNumberOf(uint256)": "2581",
        "ownerOf(uint256)": "2510",
        "safeTransferFrom(address,address,uint256)": "infinite",
        "safeTransferFrom(address,address,uint256,bytes)": "infinite",
        "setApprovalForAll(address,bool)": "26686",
        "supportsInterface(bytes4)": "456",
        "symbol()": "infinite",
        "tokenURI(uint256)": "infinite",
        "transferFrom(address,address,uint256)": "infinite"
      },
      "internal": {
        "_approveFor(address,uint256,address,uint256)": "infinite",
        "_checkOnERC721Received(address,address,address,uint256,bytes memory)": "infinite",
        "_ownerAndNonceOf(uint256)": "infinite",
        "_ownerAndOperatorEnabledOf(uint256)": "infinite",
        "_ownerNonceAndOperatorEnabledOf(uint256)": "infinite",
        "_safeMint(address,uint256)": "infinite",
        "_safeTransferFrom(address,address,uint256,bool,bytes memory)": "infinite",
        "_setApprovalForAll(address,address,bool)": "infinite",
        "_transferFrom(address,address,uint256,bool)": "24138"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20WithIERC2612\",\"name\":\"tokens\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"burnAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"maxLife\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numTokensPerGems\",\"type\":\"uint256\"},{\"internalType\":\"contract ITime\",\"name\":\"time\",\"type\":\"address\"}],\"internalType\":\"struct UsingStratagemsTypes.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CanStillReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CommitmentHashNotMatching\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GameNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InCommitmentPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InRevealPhase\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFurtherMoves\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"NonExistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provided\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PreviousCommitmentNotRevealed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"ReserveTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferRejected\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"}],\"name\":\"CommitmentCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"}],\"name\":\"CommitmentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"color\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct UsingStratagemsTypes.Move[]\",\"name\":\"moves\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveAmount\",\"type\":\"uint256\"}],\"name\":\"CommitmentRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"}],\"name\":\"CommitmentVoid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"oldColor\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"newColor\",\"type\":\"uint8\"}],\"name\":\"MoveProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"positions\",\"type\":\"uint64[]\"}],\"name\":\"MultiPoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ReserveDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ReserveWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"}],\"name\":\"SinglePoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"ownerAndLastTransferBlockNumberList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastTransferBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct IERC721WithBlocknumber.OwnerData[]\",\"name\":\"ownersData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerAndLastTransferBlockNumberOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidAddress(address)\":[{\"params\":{\"addr\":\"invalid address\"}}],\"NonExistentToken(uint256)\":[{\"params\":{\"tokenID\":\"id of the expected token\"}}],\"NotOwner(address,address)\":[{\"params\":{\"currentOwner\":\"the current owner\",\"provided\":\"the address expected to be the current owner\"}}],\"ReserveTooLow(uint256,uint256)\":[{\"params\":{\"expected\":\"amount required to proceed\",\"inReserve\":\"amount in reserver as the time of the call\"}}]},\"events\":{\"Approval(address,address,uint256)\":{\"params\":{\"approved\":\"account who can know transfer on the owner's behalf\",\"owner\":\"current owner of the token\",\"tokenID\":\"id of the token being approved\"}},\"ApprovalForAll(address,address,bool)\":{\"params\":{\"approved\":\"whether it is approved or not\",\"operator\":\"account who can know transfer on the owner's behalf\",\"owner\":\"the account granting rights over all of its token\"}},\"CommitmentCancelled(address,uint24)\":{\"params\":{\"epoch\":\"epoch number on which this commit belongs to\",\"player\":\"account taking the staking risk (can be a different account than the one controlling the gems)\"}},\"CommitmentMade(address,uint24,bytes24)\":{\"params\":{\"commitmentHash\":\"the hash of moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"player\":\"account taking the staking risk (can be a different account than the one controlling the gems)\"}},\"CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)\":{\"params\":{\"commitmentHash\":\"the hash of the moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"furtherMoves\":\"hash of further moves, unless bytes32(0) which indicate end.\",\"moves\":\"the moves\",\"player\":\"account who commited\"}},\"CommitmentVoid(address,uint24,uint256,bytes24)\":{\"params\":{\"amountBurnt\":\"amount of token to burn\",\"epoch\":\"epoch number on which this commit belongs to\",\"furtherMoves\":\"hash of further moves, unless bytes32(0) which indicate end.\",\"player\":\"the account that made the commitment\"}},\"MoveProcessed(uint64,address,uint8,uint8)\":{\"params\":{\"newColor\":\"color that takes over\",\"oldColor\":\"previous color of the cell\",\"player\":\"account making the move\",\"position\":\"cell at which the move take place\"}},\"MultiPoke(uint24,uint64[])\":{\"params\":{\"epoch\":\"epoch number at which the poke take place\",\"positions\":\"cells to poke\"}},\"ReserveDeposited(address,uint256,uint256)\":{\"params\":{\"amountDeposited\":\"the number of tokens deposited\",\"newAmount\":\"the number of tokens in reserver as a result\",\"player\":\"account receiving the token in the reserve\"}},\"ReserveWithdrawn(address,uint256,uint256)\":{\"params\":{\"amountWithdrawn\":\"the number of tokens withdrawnn\",\"newAmount\":\"the number of tokens in reserver as a result\",\"player\":\"account withdrawing the tokens\"}},\"SinglePoke(uint24,uint64)\":{\"params\":{\"epoch\":\"epoch number at which the poke take place\",\"position\":\"cell to poke\"}},\"Transfer(address,address,uint256)\":{\"params\":{\"from\":\"the account the token is sent from\",\"to\":\"the account the token is sent to\",\"tokenID\":\"id of the token being sent\"}}},\"kind\":\"dev\",\"methods\":{\"approve(address,uint256)\":{\"params\":{\"operator\":\"The address receiving the approval.\",\"tokenID\":\"The id of the token.\"}},\"getApproved(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"operator\":\"The address of the operator.\"}},\"isApprovedForAll(address,address)\":{\"params\":{\"operator\":\"The address of the operator.\",\"owner\":\"The address of the owner.\"},\"returns\":{\"_0\":\"isOperator The status of the approval.\"}},\"ownerAndLastTransferBlockNumberList(uint256[])\":{\"params\":{\"tokenIDs\":\"The list of token ids to check.\"},\"returns\":{\"ownersData\":\"The list of (owner, lastTransferBlockNumber) for each ids given as input.\"}},\"ownerAndLastTransferBlockNumberOf(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"blockNumber\":\"The blocknumber at which the last transfer of that id happened.\",\"owner\":\"The address of the token owner.\"}},\"ownerOf(uint256)\":{\"params\":{\"tokenID\":\"The id of the token.\"},\"returns\":{\"owner\":\"The address of the token owner.\"}},\"safeTransferFrom(address,address,uint256)\":{\"params\":{\"from\":\"The send of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}},\"safeTransferFrom(address,address,uint256,bytes)\":{\"params\":{\"data\":\"Additional data.\",\"from\":\"The sender of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}},\"setApprovalForAll(address,bool)\":{\"params\":{\"approved\":\"The determination of the approval.\",\"operator\":\"The address receiving the approval.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Interface identification is specified in ERC-165. This function  uses less than 30,000 gas.\",\"params\":{\"interfaceID\":\"The interface identifier, as specified in ERC-165\"},\"returns\":{\"_0\":\"`true` if the contract implements `interfaceID` and  `interfaceID` is not 0xffffffff, `false` otherwise\"}},\"tokenURI(uint256)\":{\"details\":\"Throws if `tokenID` is not a valid NFT. URIs are defined in RFC  3986. The URI may point to a JSON file that conforms to the \\\"ERC721  Metadata JSON Schema\\\".\",\"params\":{\"tokenID\":\"id of the token being queried.\"}},\"transferFrom(address,address,uint256)\":{\"params\":{\"from\":\"The sender of the token.\",\"to\":\"The recipient of the token.\",\"tokenID\":\"The id of the token.\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"CanStillReveal()\":[{\"notice\":\"Player have to reveal if they can Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal.\"}],\"CommitmentHashNotMatching()\":[{\"notice\":\"Player have to reveal their commitment using the exact same move values  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal.\"}],\"GameNotStarted()\":[{\"notice\":\"Game has not started yet, can't perform any action\"}],\"InCommitmentPhase()\":[{\"notice\":\"When in Commit phase, player can make new commitment but they cannot reveal their move yet.\"}],\"InRevealPhase()\":[{\"notice\":\"When in Reveal phase, it is not possible to commit new moves or cancel previous commitment  During Reveal phase, players have to reveal their commitment, if not already done.\"}],\"InvalidAddress(address)\":[{\"notice\":\"An invalid address is specified (for example: zero address)\"}],\"InvalidEpoch()\":[{\"notice\":\"Player can only reveal their move in the same epoch they commited.abi  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`\"}],\"InvalidFurtherMoves()\":[{\"notice\":\"Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves  This result in a recursive series of hash that they can then submit in turn while revealing.  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block.\"}],\"NonExistentToken(uint256)\":[{\"notice\":\"The token does not exist\"}],\"NonceOverflow()\":[{\"notice\":\"The Nonce overflowed, make a transfer to self to allow new nonces.\"}],\"NotAuthorized()\":[{\"notice\":\"Not authorized to perform this operation\"}],\"NotOwner(address,address)\":[{\"notice\":\"The address from which the token is sent is not the current owner\"}],\"NothingToReveal()\":[{\"notice\":\"Player can only reveal moves they commited.\"}],\"PreviousCommitmentNotRevealed()\":[{\"notice\":\"Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\\\  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\\\If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\\\\"}],\"ReserveTooLow(uint256,uint256)\":[{\"notice\":\"to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase.\"}],\"TransferRejected()\":[{\"notice\":\"The Transfer was rejected by the destination\"}]},\"events\":{\"Approval(address,address,uint256)\":{\"notice\":\"Triggered when a token is approved to be sent by another account  Note tat the approval get reset when a Transfer event for that same token is emitted.\"},\"ApprovalForAll(address,address,bool)\":{\"notice\":\"Triggered when an account approve or disaprove another to transfer on its behalf\"},\"CommitmentCancelled(address,uint24)\":{\"notice\":\"A player has cancelled its current commitment (before it reached the reveal phase)\"},\"CommitmentMade(address,uint24,bytes24)\":{\"notice\":\"A player has commited to make a move and reveal it on the reveal phase\"},\"CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)\":{\"notice\":\"Player has revealed its previous commitment\"},\"CommitmentVoid(address,uint24,uint256,bytes24)\":{\"notice\":\"A player has canceled a previous commitment by burning some tokens\"},\"MoveProcessed(uint64,address,uint8,uint8)\":{\"notice\":\"A move has been revealed.\"},\"MultiPoke(uint24,uint64[])\":{\"notice\":\"poke multiple cells and update them if needed\"},\"ReserveDeposited(address,uint256,uint256)\":{\"notice\":\"Player has deposited token in the reserve, allowing it to use that much in game\"},\"ReserveWithdrawn(address,uint256,uint256)\":{\"notice\":\"Player have withdrawn token from the reserve\"},\"SinglePoke(uint24,uint64)\":{\"notice\":\"poke cell and update it if needed\"},\"Transfer(address,address,uint256)\":{\"notice\":\"Triggered when a token is transferred\"}},\"kind\":\"user\",\"methods\":{\"approve(address,uint256)\":{\"notice\":\"Approve an operator to transfer a specific token on the senders behalf.\"},\"balanceOf(address)\":{\"notice\":\"balanceOf is not implemented, keeping track of this add gas and we did not consider that worth it\"},\"getApproved(uint256)\":{\"notice\":\"Get the approved operator for a specific token.\"},\"isApprovedForAll(address,address)\":{\"notice\":\"Check if the sender approved the operator to transfer any of its tokens.\"},\"name()\":{\"notice\":\"A descriptive name for a collection of NFTs in this contract\"},\"ownerAndLastTransferBlockNumberList(uint256[])\":{\"notice\":\"Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\"},\"ownerAndLastTransferBlockNumberOf(uint256)\":{\"notice\":\"Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\"},\"ownerOf(uint256)\":{\"notice\":\"Get the owner of a token.\"},\"safeTransferFrom(address,address,uint256)\":{\"notice\":\"Transfer a token between 2 addresses letting the receiver know of the transfer.\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"notice\":\"Transfer a token between 2 addresses letting the receiver knows of the transfer.\"},\"setApprovalForAll(address,bool)\":{\"notice\":\"Set the approval for an operator to manage all the tokens of the sender.\"},\"supportsInterface(bytes4)\":{\"notice\":\"Query if a contract implements an interface\"},\"symbol()\":{\"notice\":\"An abbreviated name for NFTs in this contract\"},\"tokenURI(uint256)\":{\"notice\":\"A distinct Uniform Resource Identifier (URI) for a given asset.\"},\"transferFrom(address,address,uint256)\":{\"notice\":\"Transfer a token between 2 addresses.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/game/routes/StratagemsERC721.sol\":\"StratagemsERC721\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC165/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0bbdb7cf3d2c6acf95398c0ef54cb0e6ae8a3e6ce6f18fafeb0aa55cb74fb8fd\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/ERC2612/interfaces/IERC20WithIERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC20.sol\\\";\\nimport \\\"./IERC2612.sol\\\";\\n\\ninterface IERC20WithIERC2612 is IERC20, IERC2612 {}\\n\",\"keccak256\":\"0x66100d98de50a396d46feb17a2b2b400b13f033f5e01b45e95901e61a4feef05\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/ERC2612/interfaces/IERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC20Errors.sol\\\";\\n\\ninterface IERC2612 {\\n    /// @notice The signature do not match the expected signer\\n    error InvalidSignature();\\n    /// @notice The permit has expired\\n    /// @param currentTime time at which the error happen\\n    /// @param deadline the deadline\\n    error DeadlineOver(uint256 currentTime, uint256 deadline);\\n\\n    /// @notice allow `spender` to spend `value` amount of token on behalf of `owner`\\n    /// @param owner owner of the tokens\\n    /// @param spender address allowed to spend on behalf of the owner.\\n    /// @param value amount of token allowed to be spent\\n    /// @param deadline timestamp in seconds after which the permit is not valid.\\n    /// @param v signature part v\\n    /// @param r signature part r\\n    /// @param s signature part s\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /// @notice return the current nonce of the owner\\n    /// @param owner address queried\\n    /// @return nonce nonce value\\n    function nonces(address owner) external view returns (uint256 nonce);\\n\\n    /// @notice EIP-712 Domain separator hash\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x4cfe3a61d7721761dd90ceb55c77d5d7ecaeb153d567c40d3b5ca33e266df2ea\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20Errors.sol\\\";\\n\\ninterface IERC20 {\\n    /// @notice trigger when tokens are transferred, including zero value transfers.\\n    /// @param from the account the tokens are sent from\\n    /// @param to the account the tokens are sent to\\n    /// @param value number of tokens sent\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice trigger on approval amount being set.\\n    ///   Note that Transfer events need to be considered to compute the current allowance.\\n    /// @param owner the account approving the `spender`\\n    /// @param spender the account allowed to spend\\n    /// @param value the amount granted\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the total token supply.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals the token uses.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the account balance of another account with address `owner`.\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /// @notice Transfers `amount` of tokens to address `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Allows `spender` to withdraw from your account multiple times, up to `amount`.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from address `from` to address `to`.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x15bb1e4e1340b29eefc06b8826fcf9e6455e25ba972709672da7d3788777133f\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/interfaces/IERC20Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice The msg value do not match the expected value\\n/// @param provided msg.value amount provided\\n/// @param expected value expected\\nerror InvalidMsgValue(uint256 provided, uint256 expected);\\n/// @notice The total amount provided do not match the expected value\\n/// @param provided msg.value amount provided\\n/// @param expected value expected\\nerror InvalidTotalAmount(uint256 provided, uint256 expected);\\n/// @notice An invalid address is specified (for example: zero address)\\n/// @param addr invalid address\\nerror InvalidAddress(address addr);\\n/// @notice the amount requested exceed the allowance\\n/// @param currentAllowance the current allowance\\n/// @param expected amount expected\\nerror NotAuthorizedAllowance(uint256 currentAllowance, uint256 expected);\\n/// @notice the amount requested exceed the balance\\n/// @param currentBalance the current balance\\n/// @param expected amount expected\\nerror NotEnoughTokens(uint256 currentBalance, uint256 expected);\\n\",\"keccak256\":\"0xc8ab4cfee19338da32d2fc5473e1ee740bf608c59196ebd16de74294c4813ae9\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/implementations/ImplementingERC721Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ImplementingERC721Internal {\\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual returns (address owner, uint256 nonce);\\n\\n    function _approveFor(\\n        address owner,\\n        uint256 nonce,\\n        address operator,\\n        uint256 tokenID\\n    ) internal virtual;\\n\\n    function _setApprovalForAll(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0xa8a6ed1a764da2589bd932b67174805ef0c47120d27fa4defc17a2368757efbe\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"../../utils/GenericErrors.sol\\\";\\n\\ninterface IERC721Supply {\\n    /// @notice return the total number of token in existence\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IERC721 is IERC165 {\\n    /// @notice Triggered when a token is transferred\\n    /// @param from the account the token is sent from\\n    /// @param to the account the token is sent to\\n    /// @param tokenID id of the token being sent\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when a token is approved to be sent by another account\\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\\n    /// @param owner current owner of the token\\n    /// @param approved account who can know transfer on the owner's behalf\\n    /// @param tokenID id of the token being approved\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\\n    /// @param owner the account granting rights over all of its token\\n    /// @param operator account who can know transfer on the owner's behalf\\n    /// @param approved whether it is approved or not\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /// @notice The token does not exist\\n    /// @param tokenID id of the expected token\\n    error NonExistentToken(uint256 tokenID);\\n    /// @notice The address from which the token is sent is not the current owner\\n    /// @param provided the address expected to be the current owner\\n    /// @param currentOwner the current owner\\n    error NotOwner(address provided, address currentOwner);\\n    /// @notice An invalid address is specified (for example: zero address)\\n    /// @param addr invalid address\\n    error InvalidAddress(address addr);\\n    /// @notice The Transfer was rejected by the destination\\n    error TransferRejected();\\n    /// @notice The Nonce overflowed, make a transfer to self to allow new nonces.\\n    error NonceOverflow();\\n\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return balance The number of tokens owned by the address.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Get the owner of a token.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 tokenID) external view returns (address owner);\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID\\n    ) external;\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenID\\n    ) external;\\n\\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param tokenID The id of the token.\\n    function approve(address operator, uint256 tokenID) external;\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param tokenID The id of the token.\\n    /// @return operator The address of the operator.\\n    function getApproved(uint256 tokenID) external view returns (address operator);\\n\\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xfc57636452848e89a81850fe10e3ab1d5d7f5780d55ca0722a38fd59a44fd8ef\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface IERC721Metadata is IERC721 {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory name);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory symbol);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `tokenID` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    /// @param tokenID id of the token being queried.\\n    function tokenURI(uint256 tokenID) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x8a4ff84c39ad5c6bbf3e5486d3687bc1e15b96835ede5761f1922cf7a72f3354\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Receiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param operator The address which called `safeTransferFrom` function\\n    /// @param from The address which previously owned the token\\n    /// @param tokenID The NFT identifier which is being transferred\\n    /// @param data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenID,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x47e1a42d5906cbc70c15f0352836dc7922d857632075c858f64e6286669a5e2e\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721WithBlocknumber.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721WithBlocknumber {\\n    /// @notice Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    /// @return blockNumber The blocknumber at which the last transfer of that id happened.\\n    function ownerAndLastTransferBlockNumberOf(uint256 tokenID)\\n        external\\n        view\\n        returns (address owner, uint256 blockNumber);\\n\\n    struct OwnerData {\\n        address owner;\\n        uint256 lastTransferBlockNumber;\\n    }\\n\\n    /// @notice Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\\n    /// @param tokenIDs The list of token ids to check.\\n    /// @return ownersData The list of (owner, lastTransferBlockNumber) for each ids given as input.\\n    function ownerAndLastTransferBlockNumberList(uint256[] calldata tokenIDs)\\n        external\\n        view\\n        returns (OwnerData[] memory ownersData);\\n}\\n\",\"keccak256\":\"0x2461ec24c55a1b6c13d451e52ad7600bc2da469996041700a3775efbcde7042b\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/debug/time/interfaces/ITime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITime {\\n    function timestamp() external view returns (uint256);\\n}\\n\\ninterface ITimeSetter {\\n    event TimeIncreased(uint256 newTime, uint256 delta);\\n\\n    function increaseTime(uint256 delta) external;\\n}\\n\",\"keccak256\":\"0xeb0fa861febbb5f5956ea9f48a88c812671564d249ddd8c5c00740e922eb056d\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Openzeppelin_Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x54a1b5eb6fdeb706049c5f570c398a49ea05f3da2d8e35f3ae344059d622350a\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/utils/GenericErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Not authorized to perform this operation\\nerror NotAuthorized();\\n\",\"keccak256\":\"0x333aa48943e66849a9350384e7ec2553b93e8a8a12b8ad300d3341f7c98b60fd\",\"license\":\"MIT\"},\"src/game/interface/UsingStratagemsErrors.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface UsingStratagemsErrors {\\n\\t/// @notice Game has not started yet, can't perform any action\\n\\terror GameNotStarted();\\n\\n\\t/// @notice When in Reveal phase, it is not possible to commit new moves or cancel previous commitment\\n\\t///  During Reveal phase, players have to reveal their commitment, if not already done.\\n\\terror InRevealPhase();\\n\\n\\t/// @notice When in Commit phase, player can make new commitment but they cannot reveal their move yet.\\n\\terror InCommitmentPhase();\\n\\n\\t/// @notice Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\\\\\n\\t///  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\\\\\n\\t/// @notice If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\\\\\n\\terror PreviousCommitmentNotRevealed();\\n\\n\\t/// @notice to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve\\n\\t///  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase.\\n\\t/// @param inReserve amount in reserver as the time of the call\\n\\t/// @param expected amount required to proceed\\n\\terror ReserveTooLow(uint256 inReserve, uint256 expected);\\n\\n\\t/// @notice Player have to reveal their commitment using the exact same move values\\n\\t///  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal.\\n\\terror CommitmentHashNotMatching();\\n\\n\\t/// @notice Player can only reveal moves they commited.\\n\\terror NothingToReveal();\\n\\n\\t/// @notice Player can only reveal their move in the same epoch they commited.abi\\n\\t///  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`\\n\\terror InvalidEpoch();\\n\\n\\t/// @notice Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves\\n\\t///  This result in a recursive series of hash that they can then submit in turn while revealing.\\n\\t///  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block.\\n\\terror InvalidFurtherMoves();\\n\\n\\t/// @notice Player have to reveal if they can\\n\\t/// Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal.\\n\\terror CanStillReveal();\\n}\\n\",\"keccak256\":\"0xe6fd556d5df60bba43c3ade39792f1a3fbba2fcc6b25a14cb5da193763c8f68d\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsEvents.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsTypes.sol\\\";\\n\\ninterface UsingStratagemsEvents is UsingStratagemsTypes {\\n\\t/// @notice A player has commited to make a move and reveal it on the reveal phase\\n\\t/// @param player account taking the staking risk (can be a different account than the one controlling the gems)\\n\\t/// @param epoch epoch number on which this commit belongs to\\n\\t/// @param commitmentHash the hash of moves\\n\\tevent CommitmentMade(address indexed player, uint24 indexed epoch, bytes24 commitmentHash);\\n\\n\\t/// @notice A player has cancelled its current commitment (before it reached the reveal phase)\\n\\t/// @param player account taking the staking risk (can be a different account than the one controlling the gems)\\n\\t/// @param epoch epoch number on which this commit belongs to\\n\\tevent CommitmentCancelled(address indexed player, uint24 indexed epoch);\\n\\n\\t/// @notice A player has canceled a previous commitment by burning some tokens\\n\\t/// @param player the account that made the commitment\\n\\t/// @param epoch epoch number on which this commit belongs to\\n\\t/// @param amountBurnt amount of token to burn\\n\\t/// @param furtherMoves hash of further moves, unless bytes32(0) which indicate end.\\n\\tevent CommitmentVoid(address indexed player, uint24 indexed epoch, uint256 amountBurnt, bytes24 furtherMoves);\\n\\n\\t/// @notice Player has revealed its previous commitment\\n\\t/// @param player account who commited\\n\\t/// @param epoch epoch number on which this commit belongs to\\n\\t/// @param commitmentHash the hash of the moves\\n\\t/// @param moves the moves\\n\\t/// @param furtherMoves hash of further moves, unless bytes32(0) which indicate end.\\n\\tevent CommitmentRevealed(\\n\\t\\taddress indexed player,\\n\\t\\tuint24 indexed epoch,\\n\\t\\tbytes24 indexed commitmentHash,\\n\\t\\tMove[] moves,\\n\\t\\tbytes24 furtherMoves,\\n\\t\\tuint256 newReserveAmount\\n\\t);\\n\\n\\t/// @notice poke cell and update it if needed\\n\\t/// @param position cell to poke\\n\\t/// @param epoch epoch number at which the poke take place\\n\\tevent SinglePoke(uint24 indexed epoch, uint64 position);\\n\\n\\t/// @notice poke multiple cells and update them if needed\\n\\t/// @param positions cells to poke\\n\\t/// @param epoch epoch number at which the poke take place\\n\\tevent MultiPoke(uint24 indexed epoch, uint64[] positions);\\n\\n\\t/// @notice Player have withdrawn token from the reserve\\n\\t/// @param player account withdrawing the tokens\\n\\t/// @param amountWithdrawn the number of tokens withdrawnn\\n\\t/// @param newAmount the number of tokens in reserver as a result\\n\\tevent ReserveWithdrawn(address indexed player, uint256 amountWithdrawn, uint256 newAmount);\\n\\n\\t/// @notice Player has deposited token in the reserve, allowing it to use that much in game\\n\\t/// @param player account receiving the token in the reserve\\n\\t/// @param amountDeposited the number of tokens deposited\\n\\t/// @param newAmount the number of tokens in reserver as a result\\n\\tevent ReserveDeposited(address indexed player, uint256 amountDeposited, uint256 newAmount);\\n\\n\\t// --------------------------------------------------------------------------------------------\\n\\t// Event to make it easier to check what is happening\\n\\t// TODO get rid ?\\n\\t// --------------------------------------------------------------------------------------------\\n\\t/// @notice A move has been revealed.\\n\\t/// @param position cell at which the move take place\\n\\t/// @param player account making the move\\n\\t/// @param oldColor previous color of the cell\\n\\t/// @param newColor color that takes over\\n\\tevent MoveProcessed(uint64 indexed position, address indexed player, Color oldColor, Color newColor);\\n}\\n\",\"keccak256\":\"0xa31c68808c3904baba4e312f979e29c6c835f43ff5f25d8321439b51051d610d\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsTypes.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC20/ERC2612/interfaces/IERC20WithIERC2612.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/debug/time/interfaces/ITime.sol\\\";\\n\\ninterface UsingStratagemsTypes {\\n\\t// --------------------------------------------------------------------------------------------\\n\\t// EXTERNAL TYPES\\n\\t// --------------------------------------------------------------------------------------------\\n\\n\\t/// @notice The set of possible color (None indicate the Cell is empty)\\n\\tenum Color {\\n\\t\\tNone,\\n\\t\\tBlue,\\n\\t\\tRed,\\n\\t\\tGreen,\\n\\t\\tYellow,\\n\\t\\tPurple,\\n\\t\\tEvil\\n\\t}\\n\\n\\t/// @notice Move struct that define position and color\\n\\tstruct Move {\\n\\t\\tuint64 position; // TODO make it bigger ? uint32 * uint32 is probably infinitely big enough\\n\\t\\tColor color;\\n\\t}\\n\\n\\t/// @notice Permit struct to authorize EIP2612 ERC20 contracts\\n\\tstruct Permit {\\n\\t\\tuint256 value;\\n\\t\\tuint256 deadline;\\n\\t\\tuint8 v;\\n\\t\\tbytes32 r;\\n\\t\\tbytes32 s;\\n\\t}\\n\\n\\t/// @notice Config struct to configure the game instance\\n\\tstruct Config {\\n\\t\\tIERC20WithIERC2612 tokens;\\n\\t\\taddress payable burnAddress;\\n\\t\\tuint256 startTime;\\n\\t\\tuint256 commitPhaseDuration;\\n\\t\\tuint256 revealPhaseDuration;\\n\\t\\tuint8 maxLife;\\n\\t\\tuint256 numTokensPerGems;\\n\\t\\tITime time;\\n\\t}\\n\\n\\t/// @notice Cell struct representing the current state of a cell\\n\\tstruct FullCell {\\n\\t\\taddress owner;\\n\\t\\tuint24 lastEpochUpdate;\\n\\t\\tuint24 epochWhenTokenIsAdded;\\n\\t\\tColor color;\\n\\t\\tuint8 life;\\n\\t\\tint8 delta;\\n\\t\\tuint8 enemyMap;\\n\\t\\tuint8 distribution;\\n\\t\\tuint8 stake; // for Evil, else always 1\\n\\t}\\n\\n\\t// --------------------------------------------------------------------------------------------\\n\\t// STORAGE TYPES\\n\\t// --------------------------------------------------------------------------------------------\\n\\tstruct Cell {\\n\\t\\tuint24 lastEpochUpdate;\\n\\t\\tuint24 epochWhenTokenIsAdded;\\n\\t\\tColor color;\\n\\t\\tuint8 life;\\n\\t\\tint8 delta;\\n\\t\\tuint8 enemyMap;\\n\\t\\tuint8 distribution; // this encode who is left to be given reward (4 left most bits) and the reard (4 most right bits)\\n\\t\\tuint8 stake; // for Evil, else always 1\\n\\t}\\n\\n\\tstruct Commitment {\\n\\t\\tbytes24 hash;\\n\\t\\tuint24 epoch;\\n\\t}\\n\\n\\t// --------------------------------------------------------------------------------------------\\n\\t// INTERNAL TYPES\\n\\t// --------------------------------------------------------------------------------------------\\n\\n\\tstruct TokenTransfer {\\n\\t\\taddress payable to;\\n\\t\\tuint256 amount;\\n\\t}\\n\\n\\tstruct TokenTransferCollection {\\n\\t\\tTokenTransfer[] transfers;\\n\\t\\tuint256 numTransfers;\\n\\t}\\n\\n\\tstruct MoveTokens {\\n\\t\\tuint256 tokensPlaced;\\n\\t\\tuint256 tokensBurnt;\\n\\t\\tuint256 tokensReturned;\\n\\t}\\n}\\n\",\"keccak256\":\"0x74dccbc74f8784b15cd308e38359e56cdc6fbd7a1b3600678010c387e1410137\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsSetters.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsState.sol\\\";\\nimport \\\"../interface/UsingStratagemsEvents.sol\\\";\\nimport \\\"./UsingStratagemsUtils.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\n\\nabstract contract UsingStratagemsSetters is UsingStratagemsState, UsingStratagemsUtils {\\n\\tusing PositionUtils for uint64;\\n\\n\\tconstructor(Config memory config) UsingStratagemsState(config) {}\\n\\n\\tfunction _makeCommitment(address player, bytes24 commitmentHash, uint256 inReserve) internal {\\n\\t\\tCommitment storage commitment = _commitments[player];\\n\\n\\t\\t(uint24 epoch, bool commiting) = _epoch();\\n\\n\\t\\tif (!commiting) {\\n\\t\\t\\trevert InRevealPhase();\\n\\t\\t}\\n\\t\\tif (commitment.epoch != 0 && commitment.epoch != epoch) {\\n\\t\\t\\trevert PreviousCommitmentNotRevealed();\\n\\t\\t}\\n\\n\\t\\tcommitment.hash = commitmentHash;\\n\\t\\tcommitment.epoch = epoch;\\n\\n\\t\\t// for withdrawal, we still require a minimal reserve so player cannot change their mind without losing at least one token\\n\\t\\t// TODO we might want to increase that value to 10x as 10 moves might quite common, at least on some networks\\n\\t\\tif (inReserve < NUM_TOKENS_PER_GEMS) {\\n\\t\\t\\t// TODO? special error for this case ?\\n\\t\\t\\trevert ReserveTooLow(inReserve, NUM_TOKENS_PER_GEMS);\\n\\t\\t}\\n\\n\\t\\temit CommitmentMade(player, epoch, commitmentHash);\\n\\t}\\n\\n\\tfunction _resolveMoves(\\n\\t\\taddress player,\\n\\t\\tuint24 epoch,\\n\\t\\tMove[] memory moves,\\n\\t\\taddress tokenGiver\\n\\t) internal returns (uint256 newReserveAmount) {\\n\\t\\t// max number of transfer is (4+1) * moves.length\\n\\t\\t// (for each move's cell's neighbours potentially being a different account)\\n\\t\\t// limiting the number of move per commitment reveal to 32 or, even more probably, should cover this unlikely scenario\\n\\t\\tTokenTransferCollection memory transferCollection = TokenTransferCollection({\\n\\t\\t\\ttransfers: new TokenTransfer[](moves.length * 5),\\n\\t\\t\\tnumTransfers: 0\\n\\t\\t});\\n\\t\\tMoveTokens memory tokens;\\n\\t\\tfor (uint256 i = 0; i < moves.length; i++) {\\n\\t\\t\\t(uint256 placed, uint256 burnt, uint256 returned) = _computeMove(\\n\\t\\t\\t\\ttransferCollection,\\n\\t\\t\\t\\tplayer,\\n\\t\\t\\t\\tepoch,\\n\\t\\t\\t\\tmoves[i]\\n\\t\\t\\t);\\n\\n\\t\\t\\ttokens.tokensPlaced += placed;\\n\\t\\t\\ttokens.tokensBurnt += burnt;\\n\\t\\t\\ttokens.tokensReturned += returned;\\n\\t\\t}\\n\\n\\t\\tlogger.logTransfers(0, \\\"resolveMoves\\\", transferCollection);\\n\\n\\t\\t_multiTransfer(TOKENS, transferCollection);\\n\\n\\t\\tnewReserveAmount = _tokensInReserve[player];\\n\\n\\t\\t// Note: even if funds can comes from outside the reserve, we still check it\\n\\t\\t// This ensure player have to have a reserve and cannot escape the slash if not\\n\\t\\tif (newReserveAmount < tokens.tokensPlaced + tokens.tokensBurnt) {\\n\\t\\t\\trevert ReserveTooLow(newReserveAmount, tokens.tokensPlaced + tokens.tokensBurnt);\\n\\t\\t}\\n\\t\\tif (tokenGiver == address(0)) {\\n\\t\\t\\tnewReserveAmount -= tokens.tokensPlaced + tokens.tokensBurnt;\\n\\t\\t\\t_tokensInReserve[player] = newReserveAmount;\\n\\t\\t} else {\\n\\t\\t\\tif (tokens.tokensPlaced != 0) {\\n\\t\\t\\t\\t// TODO use TransferCollection too here\\n\\t\\t\\t\\tTOKENS.transferFrom(tokenGiver, address(this), tokens.tokensPlaced);\\n\\t\\t\\t}\\n\\t\\t\\tif (tokens.tokensBurnt != 0) {\\n\\t\\t\\t\\t// TODO use TransferCollection too here\\n\\t\\t\\t\\tTOKENS.transferFrom(tokenGiver, BURN_ADDRESS, tokens.tokensBurnt);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// option to return in reserve ?\\n\\t\\t// TODO use TransferCollection too here\\n\\t\\tif (tokens.tokensReturned != 0) {\\n\\t\\t\\t// console.log(\\\"tokensReturned\\\");\\n\\t\\t\\t// console.log(tokens.tokensReturned);\\n\\t\\t\\tTOKENS.transfer(player, tokens.tokensReturned);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _countBits(uint8 n) internal pure returns (uint8 count) {\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tn = n & (n - 1);\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\n\\t// Note on COLLISION\\n\\t// If one color was used more than other, we could consider the cell having N owner and N times the number of tokens\\n\\t// such cells would be a good target for others\\n\\t// On the other end, on winning agains other cells, owner of such cell would have to divide the winnings\\n\\t// TODO revisit this\\n\\t// we could also refund the part\\n\\t// so if there is 3 green 2 blue and 1 red, then green win and the cell become green\\n\\t// player we put blue or red get refunded their respective gems\\n\\t// the players we put green get refunded 2/3 so that the cell still contains only 1\\n\\t// if there was 3 green and 3 blue and 1 red then the cell becomes black\\n\\t// every player get refunded 6/7 so that the black cell only has 1\\n\\t// note that the issue with green winning above is that winnings need to be distributed to all 3 players we put green\\n\\t// and since the number is technically unbounded, we have to use a splitter contract where player withdraw their winnings\\n\\t// this add UX complexity and some cost for withdrawals\\n\\tfunction _computeMove(\\n\\t\\tTokenTransferCollection memory transferCollection,\\n\\t\\taddress player,\\n\\t\\tuint24 epoch,\\n\\t\\tMove memory move\\n\\t) internal returns (uint256 tokensPlaced, uint256 tokensBurnt, uint256 tokensReturned) {\\n\\t\\tCell memory currentState = _getUpdatedCell(move.position, epoch);\\n\\n\\t\\tlogger.logCell(\\n\\t\\t\\t0,\\n\\t\\t\\tstring.concat(\\\"_computeMove at epoch \\\", Strings.toString(epoch)),\\n\\t\\t\\tmove.position,\\n\\t\\t\\tcurrentState,\\n\\t\\t\\taddress(uint160(_owners[move.position]))\\n\\t\\t);\\n\\n\\t\\t// we might have distribution still to do\\n\\t\\tuint8 distribution = currentState.distribution;\\n\\t\\tif (currentState.life == 0 && currentState.lastEpochUpdate != 0) {\\n\\t\\t\\t// if we just died, currentState.lastEpochUpdate > 0\\n\\t\\t\\t// we have to distribute to all\\n\\t\\t\\tdistribution = (currentState.enemyMap << 4) + _countBits(currentState.enemyMap);\\n\\n\\t\\t\\t/// we are now dead for real\\n\\t\\t\\tcurrentState.lastEpochUpdate = 0;\\n\\t\\t}\\n\\n\\t\\t// we then apply our move:\\n\\n\\t\\t// first we do some validity checks\\n\\t\\tif (move.color == Color.None) {\\n\\t\\t\\tif (currentState.life != MAX_LIFE || _ownerOf(move.position) != player) {\\n\\t\\t\\t\\t// invalid move\\n\\t\\t\\t\\treturn (0, 0, NUM_TOKENS_PER_GEMS);\\n\\t\\t\\t}\\n\\n\\t\\t\\t_collectTransfer(transferCollection, TokenTransfer({to: payable(player), amount: NUM_TOKENS_PER_GEMS}));\\n\\t\\t}\\n\\t\\t// then we consider the case of collision and transform such move as Color Evil\\n\\t\\telse if (currentState.epochWhenTokenIsAdded == epoch) {\\n\\t\\t\\tif (currentState.life != 0) {\\n\\t\\t\\t\\tmove.color = Color.Evil;\\n\\t\\t\\t\\t// TODO Add further stake, or do we burn? or return?\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// invalid move, on top of a MAX, that become None ?\\n\\t\\t\\t\\treturn (0, 0, NUM_TOKENS_PER_GEMS);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t(int8 newDelta, uint8 newEnemyMap) = _propagate(\\n\\t\\t\\ttransferCollection,\\n\\t\\t\\tmove,\\n\\t\\t\\tepoch,\\n\\t\\t\\tcurrentState.color,\\n\\t\\t\\tdistribution,\\n\\t\\t\\tcurrentState.stake\\n\\t\\t);\\n\\n\\t\\temit MoveProcessed(move.position, player, currentState.color, move.color);\\n\\t\\tcurrentState.color = move.color;\\n\\t\\tcurrentState.distribution = 0;\\n\\t\\tcurrentState.epochWhenTokenIsAdded = epoch; // used to prevent overwriting, even Color.None\\n\\n\\t\\tif (currentState.color == Color.None) {\\n\\t\\t\\tcurrentState.life = 0;\\n\\t\\t\\tcurrentState.stake = 0;\\n\\t\\t\\tcurrentState.lastEpochUpdate = 0;\\n\\t\\t\\tcurrentState.delta = 0;\\n\\t\\t\\tcurrentState.enemyMap = 0;\\n\\t\\t\\t_owners[move.position] = 0;\\n\\t\\t\\ttokensReturned = NUM_TOKENS_PER_GEMS;\\n\\t\\t} else {\\n\\t\\t\\ttokensPlaced = NUM_TOKENS_PER_GEMS;\\n\\n\\t\\t\\tcurrentState.enemyMap = newEnemyMap;\\n\\n\\t\\t\\tif (currentState.color == Color.Evil && currentState.life != 0) {\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\tcurrentState.stake += 1;\\n\\t\\t\\t\\t\\tif (currentState.stake == 0) {\\n\\t\\t\\t\\t\\t\\t// we cap it, losing stake there\\n\\t\\t\\t\\t\\t\\t// TODO reevaluate\\n\\t\\t\\t\\t\\t\\tcurrentState.stake = 255;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurrentState.stake = 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentState.delta = newDelta;\\n\\t\\t\\tcurrentState.life = 1;\\n\\t\\t\\tcurrentState.lastEpochUpdate = epoch;\\n\\t\\t\\tif (currentState.color == Color.Evil) {\\n\\t\\t\\t\\t_owners[move.position] = uint256(uint160(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_owners[move.position] = uint256(uint160(player));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t_cells[move.position] = currentState;\\n\\n\\t\\tlogger.logCell(\\n\\t\\t\\t0,\\n\\t\\t\\tstring.concat(\\\"AFTER \\\", Strings.toString(epoch)),\\n\\t\\t\\tmove.position,\\n\\t\\t\\tcurrentState,\\n\\t\\t\\taddress(uint160(_owners[move.position]))\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _propagate(\\n\\t\\tTokenTransferCollection memory transferCollection,\\n\\t\\tMove memory move,\\n\\t\\tuint24 epoch,\\n\\t\\tColor color,\\n\\t\\tuint8 distribution,\\n\\t\\tuint8 stake\\n\\t) internal returns (int8 newDelta, uint8 newEnemyMap) {\\n\\t\\t(\\n\\t\\t\\tint8 newComputedDelta,\\n\\t\\t\\tuint8 newComputedEnemyMap,\\n\\t\\t\\tuint16 numDue,\\n\\t\\t\\taddress[4] memory ownersToPay\\n\\t\\t) = _updateNeighbours(move.position, epoch, color, move.color, distribution);\\n\\n\\t\\tif (numDue > 0) {\\n\\t\\t\\t_collectTransfer(\\n\\t\\t\\t\\ttransferCollection,\\n\\t\\t\\t\\tTokenTransfer({to: payable(_ownerOf(move.position)), amount: (numDue * NUM_TOKENS_PER_GEMS) / 12})\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tfor (uint8 i = 0; i < 4; i++) {\\n\\t\\t\\tif (ownersToPay[i] != address(0)) {\\n\\t\\t\\t\\t_collectTransfer(\\n\\t\\t\\t\\t\\ttransferCollection,\\n\\t\\t\\t\\t\\tTokenTransfer({\\n\\t\\t\\t\\t\\t\\tto: payable(ownersToPay[i]),\\n\\t\\t\\t\\t\\t\\tamount: stake * (NUM_TOKENS_PER_GEMS / (distribution & 0x0f))\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnewDelta = newComputedDelta;\\n\\t\\tnewEnemyMap = newComputedEnemyMap;\\n\\t}\\n\\n\\tfunction _poke(TokenTransferCollection memory transferCollection, uint64 position, uint24 epoch) internal {\\n\\t\\tCell memory currentState = _getUpdatedCell(position, epoch);\\n\\n\\t\\tlogger.logCell(\\n\\t\\t\\t0,\\n\\t\\t\\tstring.concat(\\\"_poke at epoch \\\", Strings.toString(epoch)),\\n\\t\\t\\tposition,\\n\\t\\t\\tcurrentState,\\n\\t\\t\\taddress(uint160(_owners[position]))\\n\\t\\t);\\n\\n\\t\\t// we might have distribution still to do\\n\\t\\tuint8 distribution = currentState.distribution;\\n\\t\\tif (currentState.life == 0 && currentState.lastEpochUpdate != 0) {\\n\\t\\t\\t// if we just died, currentState.lastEpochUpdate > 0\\n\\t\\t\\t// we have to distribute to all\\n\\t\\t\\tdistribution = (currentState.enemyMap << 4) + _countBits(currentState.enemyMap);\\n\\n\\t\\t\\t/// we are now dead for real\\n\\t\\t\\tcurrentState.lastEpochUpdate = 0;\\n\\t\\t}\\n\\n\\t\\t(, , uint16 numDue, address[4] memory ownersToPay) = _updateNeighbours(\\n\\t\\t\\tposition,\\n\\t\\t\\tepoch,\\n\\t\\t\\tcurrentState.color,\\n\\t\\t\\tcurrentState.color,\\n\\t\\t\\tdistribution\\n\\t\\t);\\n\\n\\t\\tif (numDue > 0) {\\n\\t\\t\\t_collectTransfer(\\n\\t\\t\\t\\ttransferCollection,\\n\\t\\t\\t\\tTokenTransfer({to: payable(_ownerOf(position)), amount: (numDue * NUM_TOKENS_PER_GEMS) / 12})\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tfor (uint8 i = 0; i < 4; i++) {\\n\\t\\t\\tif (ownersToPay[i] != address(0)) {\\n\\t\\t\\t\\t_collectTransfer(\\n\\t\\t\\t\\t\\ttransferCollection,\\n\\t\\t\\t\\t\\tTokenTransfer({\\n\\t\\t\\t\\t\\t\\tto: payable(ownersToPay[i]),\\n\\t\\t\\t\\t\\t\\tamount: currentState.stake * (NUM_TOKENS_PER_GEMS / (distribution & 0x0f))\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlogger.logCell(\\n\\t\\t\\t0,\\n\\t\\t\\tstring.concat(\\\"AFTER poke (before zeroed distribution) at epoch \\\", Strings.toString(epoch)),\\n\\t\\t\\tposition,\\n\\t\\t\\tcurrentState,\\n\\t\\t\\taddress(uint160(_owners[position]))\\n\\t\\t);\\n\\n\\t\\tcurrentState.distribution = 0;\\n\\t\\t_cells[position] = currentState;\\n\\t}\\n\\n\\tfunction _updateNeighbours(\\n\\t\\tuint64 position,\\n\\t\\tuint24 epoch,\\n\\t\\tColor oldColor,\\n\\t\\tColor newColor,\\n\\t\\tuint8 distribution\\n\\t) internal returns (int8 newDelta, uint8 newenemyMap, uint16 numDue, address[4] memory ownersToPay) {\\n\\t\\tunchecked {\\n\\t\\t\\tlogger.logPosition(\\\"from\\\", position);\\n\\t\\t\\tconsole.log(\\\"distribution %i %i\\\", distribution >> 4, distribution & 0x0F);\\n\\n\\t\\t\\tint8 enemyOrFriend;\\n\\t\\t\\tuint16 due;\\n\\t\\t\\t{\\n\\t\\t\\t\\tuint64 upPosition = position.offset(0, -1);\\n\\t\\t\\t\\tlogger.logPosition(\\\"upPosition\\\", upPosition);\\n\\t\\t\\t\\t(enemyOrFriend, due) = _updateCell(upPosition, epoch, 2, oldColor, newColor);\\n\\t\\t\\t\\tif (enemyOrFriend < 0) {\\n\\t\\t\\t\\t\\tnewenemyMap = newenemyMap | 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnumDue += due;\\n\\t\\t\\t\\tif ((distribution >> 4) & 1 == 1) {\\n\\t\\t\\t\\t\\tconsole.log(\\\"upPosition %i\\\", distribution);\\n\\t\\t\\t\\t\\t// TODO?: if we decide to group owner in the cell struct, we should get the cell in memory in that function\\n\\t\\t\\t\\t\\townersToPay[0] = _ownerOf(upPosition);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewDelta += enemyOrFriend;\\n\\t\\t\\t}\\n\\t\\t\\t{\\n\\t\\t\\t\\tuint64 leftPosition = position.offset(-1, 0);\\n\\t\\t\\t\\tlogger.logPosition(\\\"leftPosition\\\", leftPosition);\\n\\t\\t\\t\\t(enemyOrFriend, due) = _updateCell(leftPosition, epoch, 3, oldColor, newColor);\\n\\t\\t\\t\\tif (enemyOrFriend < 0) {\\n\\t\\t\\t\\t\\tnewenemyMap = newenemyMap | 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnumDue += due;\\n\\t\\t\\t\\tif ((distribution >> 4) & 2 == 2) {\\n\\t\\t\\t\\t\\tconsole.log(\\\"leftPosition %i\\\", distribution);\\n\\t\\t\\t\\t\\townersToPay[1] = _ownerOf(leftPosition);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewDelta += enemyOrFriend;\\n\\t\\t\\t}\\n\\n\\t\\t\\t{\\n\\t\\t\\t\\tuint64 downPosition = position.offset(0, 1);\\n\\t\\t\\t\\tlogger.logPosition(\\\"downPosition\\\", downPosition);\\n\\t\\t\\t\\t(enemyOrFriend, due) = _updateCell(downPosition, epoch, 0, oldColor, newColor);\\n\\t\\t\\t\\tif (enemyOrFriend < 0) {\\n\\t\\t\\t\\t\\tnewenemyMap = newenemyMap | 4;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnumDue += due;\\n\\t\\t\\t\\tif ((distribution >> 4) & 4 == 4) {\\n\\t\\t\\t\\t\\tconsole.log(\\\"downPosition %i\\\", distribution);\\n\\t\\t\\t\\t\\townersToPay[2] = _ownerOf(downPosition);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewDelta += enemyOrFriend;\\n\\t\\t\\t}\\n\\t\\t\\t{\\n\\t\\t\\t\\tuint64 rightPosition = position.offset(1, 0);\\n\\t\\t\\t\\tlogger.logPosition(\\\"rightPosition\\\", rightPosition);\\n\\t\\t\\t\\t(enemyOrFriend, due) = _updateCell(rightPosition, epoch, 1, oldColor, newColor);\\n\\t\\t\\t\\tif (enemyOrFriend < 0) {\\n\\t\\t\\t\\t\\tnewenemyMap = newenemyMap | 8;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnumDue += due;\\n\\t\\t\\t\\tif ((distribution >> 4) & 8 == 8) {\\n\\t\\t\\t\\t\\tconsole.log(\\\"rightPosition %i\\\", distribution);\\n\\t\\t\\t\\t\\townersToPay[3] = _ownerOf(rightPosition);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnewDelta += enemyOrFriend;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev This update the cell in storage\\n\\tfunction _updateCell(\\n\\t\\tuint64 position, // position to update\\n\\t\\tuint24 epoch,\\n\\t\\tuint8 neighbourIndex, // index from point of view of cell being updated\\n\\t\\tColor oldColor, // old Color of the neighbor\\n\\t\\tColor newColor // new color of the neighbor\\n\\t) internal returns (int8 enemyOrFriend, uint16 due) {\\n\\t\\tCell memory cell = _cells[position];\\n\\n\\t\\tuint24 lastUpdate = cell.lastEpochUpdate;\\n\\t\\tColor color = cell.color;\\n\\t\\tif (color != Color.None) {\\n\\t\\t\\t// if the color of the cell being update is not Nome\\n\\t\\t\\t// we then check the neighbor new color\\n\\t\\t\\t// if it same as the cell color, then we report the cell as friendly to the neighbor\\n\\t\\t\\t// else it is an enemy\\n\\t\\t\\t// note that _updateCell should only be called if oldColor != newColor\\n\\t\\t\\tenemyOrFriend = color == newColor ? int8(1) : int8(-1);\\n\\t\\t}\\n\\t\\tif (lastUpdate >= 1 && color != Color.None) {\\n\\t\\t\\t// we only consider cell with color that are not dead\\n\\t\\t\\tif (cell.life > 0 && lastUpdate < epoch) {\\n\\t\\t\\t\\t// of there is life to update we compute the new life\\n\\t\\t\\t\\t(uint8 newLife, uint24 epochUsed) = _computeNewLife(\\n\\t\\t\\t\\t\\tlastUpdate,\\n\\t\\t\\t\\t\\tcell.enemyMap,\\n\\t\\t\\t\\t\\tcell.delta,\\n\\t\\t\\t\\t\\tcell.life,\\n\\t\\t\\t\\t\\tepoch\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tdue = _updateCellFromNeighbor(position, cell, newLife, epochUsed, neighbourIndex, oldColor, newColor);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdue = _updateCellFromNeighbor(position, cell, cell.life, epoch, neighbourIndex, oldColor, newColor);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _updateCellFromNeighbor(\\n\\t\\tuint64 position, // position of the cell to be updated\\n\\t\\tCell memory cell, // cell to be updated\\n\\t\\tuint8 newLife, // new life value for the celll\\n\\t\\tuint24 epoch, // epoch at which the update occured (epochUsed TODO: confirm its use)\\n\\t\\tuint8 neighbourIndex, // the neighbor triggering the update and for which we return whether it should receive its due\\n\\t\\tColor oldColor, // old color of that neighbor\\n\\t\\tColor newColor // new color of that neighbor\\n\\t) internal returns (uint16 due) {\\n\\t\\tif (cell.life > 0 && newLife == 0) {\\n\\t\\t\\t// we just died, we establish the distributionMap and counts\\n\\t\\t\\tcell.distribution = (cell.enemyMap << 4) + _countBits(cell.enemyMap);\\n\\t\\t}\\n\\n\\t\\tlogger.logCell(\\n\\t\\t\\t0,\\n\\t\\t\\tstring.concat(\\\"_updateCellFromNeighbor  index\\\", Strings.toString(neighbourIndex)),\\n\\t\\t\\tposition,\\n\\t\\t\\tcell,\\n\\t\\t\\taddress(uint160(_owners[position]))\\n\\t\\t);\\n\\n\\t\\tif ((cell.distribution >> 4) & (2 ** neighbourIndex) == 2 ** neighbourIndex) {\\n\\t\\t\\tdue = (cell.stake * 12) / (cell.distribution & 0x0f);\\n\\t\\t\\tcell.distribution =\\n\\t\\t\\t\\t(uint8(uint256(cell.distribution >> 4) & (~(2 ** uint256(neighbourIndex)))) << 4) +\\n\\t\\t\\t\\t(cell.distribution & 0x0f);\\n\\t\\t}\\n\\n\\t\\tif (oldColor != newColor) {\\n\\t\\t\\tif (newColor == Color.None) {\\n\\t\\t\\t\\tif (cell.color == oldColor) {\\n\\t\\t\\t\\t\\tcell.delta -= 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcell.delta += 1;\\n\\t\\t\\t\\t\\tcell.enemyMap = cell.enemyMap & uint8((1 << neighbourIndex) ^ 0xFF);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (cell.color == oldColor) {\\n\\t\\t\\t\\t// then newColor is different (see assert above)\\n\\t\\t\\t\\tcell.enemyMap = cell.enemyMap | uint8(1 << neighbourIndex);\\n\\t\\t\\t\\tcell.delta -= 2;\\n\\t\\t\\t} else if (cell.color == newColor) {\\n\\t\\t\\t\\t// then old color was different\\n\\t\\t\\t\\tcell.delta += (oldColor == Color.None ? int8(1) : int8(2));\\n\\t\\t\\t\\tcell.enemyMap = cell.enemyMap & uint8((1 << neighbourIndex) ^ 0xFF);\\n\\t\\t\\t} else if (oldColor == Color.None) {\\n\\t\\t\\t\\t// if there were no oldCOlor and the newColor is not your (already checked in previous if clause)\\n\\t\\t\\t\\tcell.delta -= 1;\\n\\t\\t\\t\\tcell.enemyMap = cell.enemyMap | uint8(1 << neighbourIndex);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tcell.lastEpochUpdate = epoch;\\n\\t\\tcell.life = newLife;\\n\\n\\t\\tlogger.logCell(\\n\\t\\t\\t0,\\n\\t\\t\\tstring.concat(\\\"AFTER _updateCellFromNeighbor  index\\\", Strings.toString(neighbourIndex)),\\n\\t\\t\\tposition,\\n\\t\\t\\tcell,\\n\\t\\t\\taddress(uint160(_owners[position]))\\n\\t\\t);\\n\\n\\t\\t_cells[position] = cell;\\n\\t}\\n}\\n\",\"keccak256\":\"0xd8a9b280bdb0aeaa100d95d9b86f3422c3bd3685b54da42b6c9f353e67a19383\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsState.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsStore.sol\\\";\\nimport \\\"../interface/UsingStratagemsEvents.sol\\\";\\nimport \\\"../interface/UsingStratagemsErrors.sol\\\";\\nimport \\\"./UsingVirtualTime.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\n\\n// TODO use hardhat-preprocessor\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary logger {\\n    using PositionUtils for uint64;\\n\\n    address constant CONSOLE_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(staticcall(gas(), consoleAddress, add(payload, 32), mload(payload), 0, 0))\\n        }\\n    }\\n\\n    // _sendLogPayload(abi.encodeWithSignature('log(string,int256,int256)', 'cell %s', x, y));\\n\\n    function logPosition(string memory title, uint64 pos) internal view {\\n        (int32 x, int32 y) = pos.toXY();\\n        console.log(\\\"%s: (%s,%s)\\\", title, Strings.toString(x), Strings.toString(y));\\n    }\\n\\n    function logCell(\\n        uint8 ii,\\n        string memory title,\\n        uint64 id,\\n        UsingStratagemsTypes.Cell memory cell,\\n        address owner\\n    ) internal view {\\n        string memory indent = ii == 0\\n            ? \\\"\\\"\\n            : ii == 1\\n                ? \\\"    \\\"\\n                : ii == 2\\n                    ? \\\"        \\\"\\n                    : \\\"            \\\";\\n        // string memory indent = '';\\n        console.log(\\\"%s%s\\\", indent, title);\\n        (int32 x, int32 y) = id.toXY();\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        console.log(\\\"%scell (%s,%s)\\\", indent, Strings.toString(x), Strings.toString(y));\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        console.log(\\\"%s - lastEpochUpdate:  %s\\\", indent, cell.lastEpochUpdate);\\n        console.log(\\\"%s - epochWhenTokenIsAdded:  %s\\\", indent, cell.epochWhenTokenIsAdded);\\n        console.log(\\\"%s - color:  %s\\\", indent, uint8(cell.color));\\n        console.log(\\\"%s - life:  %s\\\", indent, cell.life);\\n        console.log(\\\"%s - distribution:  %s\\\", indent, cell.distribution);\\n        console.log(\\\"%s - owner:  %s\\\", indent, owner);\\n        console.log(\\\"%s - delta: %s\\\", indent, Strings.toString(cell.delta));\\n        console.log(\\\"%s - enemyMap:  %s\\\", indent, cell.enemyMap);\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n    }\\n\\n    function logTransfers(\\n        uint8 ii,\\n        string memory title,\\n        UsingStratagemsTypes.TokenTransferCollection memory transferCollection\\n    ) internal pure {\\n        string memory indent = ii == 0\\n            ? \\\"\\\"\\n            : ii == 1\\n                ? \\\"    \\\"\\n                : ii == 2\\n                    ? \\\"        \\\"\\n                    : \\\"            \\\";\\n        // string memory indent = '';\\n        console.log(\\\"%s%s\\\", indent, title);\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        for (uint256 i = 0; i < transferCollection.numTransfers; i++) {\\n            console.log(\\n                \\\"%stransfer (%s,%s)\\\",\\n                indent,\\n                transferCollection.transfers[i].to,\\n                Strings.toString(transferCollection.transfers[i].amount)\\n            );\\n        }\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n    }\\n}\\n\\nabstract contract UsingStratagemsState is\\n    UsingStratagemsStore,\\n    UsingStratagemsEvents,\\n    UsingStratagemsErrors,\\n    UsingVirtualTime\\n{\\n    /// @notice The token used for the game. Each gems on the board contains that token\\n    IERC20WithIERC2612 internal immutable TOKENS;\\n    /// @notice the timestamp (in seconds) at which the game start, it start in the commit phase\\n    uint256 internal immutable START_TIME;\\n    /// @notice the duration of the commit phase in seconds\\n    uint256 internal immutable COMMIT_PHASE_DURATION;\\n    /// @notice the duration of the reveal phase in seconds\\n    uint256 internal immutable REVEAL_PHASE_DURATION;\\n    /// @notice the max number of level a cell can reach in the game\\n    uint8 internal immutable MAX_LIFE;\\n    /// @notice the number of tokens underlying each gems on the board.\\n    uint256 internal immutable NUM_TOKENS_PER_GEMS;\\n    /// @notice the address to send the token to when burning\\n    address payable internal immutable BURN_ADDRESS;\\n\\n    /// @notice the number of moves a hash represent, after that players make use of furtherMoves\\n    uint8 internal constant MAX_NUM_MOVES_PER_HASH = 32;\\n\\n    /// @notice Create an instance of a Stratagems game\\n    /// @param config configuration options for the game\\n    constructor(Config memory config) UsingVirtualTime(config) {\\n        TOKENS = config.tokens;\\n        BURN_ADDRESS = config.burnAddress;\\n        START_TIME = config.startTime;\\n        COMMIT_PHASE_DURATION = config.commitPhaseDuration;\\n        REVEAL_PHASE_DURATION = config.revealPhaseDuration;\\n        MAX_LIFE = config.maxLife;\\n        NUM_TOKENS_PER_GEMS = config.numTokensPerGems;\\n    }\\n\\n    function _epoch() internal view virtual returns (uint24 epoch, bool commiting) {\\n        uint256 epochDuration = COMMIT_PHASE_DURATION + REVEAL_PHASE_DURATION;\\n        uint256 time = _timestamp();\\n        if (time < START_TIME) {\\n            revert GameNotStarted();\\n        }\\n        uint256 timePassed = time - START_TIME;\\n        epoch = uint24(timePassed / epochDuration + 2); // epoch start at 2, this make the hypothetical previous reveal phase's epoch to be 1\\n        commiting = timePassed - ((epoch - 2) * epochDuration) < COMMIT_PHASE_DURATION;\\n    }\\n\\n    function _computeNewLife(\\n        uint24 lastUpdate,\\n        uint8 enemyMap,\\n        int8 delta,\\n        uint8 life,\\n        uint24 epoch\\n    ) internal view returns (uint8 newLife, uint24 epochUsed) {\\n        epochUsed = lastUpdate;\\n        if (lastUpdate >= 1 && life > 0) {\\n            uint256 epochDelta = epoch - lastUpdate;\\n            if (epochDelta > 0) {\\n                int8 effectiveDelta = delta != 0 ? delta : -1;\\n                if (effectiveDelta < 0 && enemyMap == 0) {\\n                    effectiveDelta = 0;\\n                }\\n                if (effectiveDelta > 0) {\\n                    // if (life < MAX_LIFE) {\\n                    uint8 maxEpoch = ((MAX_LIFE - life) + uint8(effectiveDelta) - 1) / uint8(effectiveDelta);\\n                    if (epochDelta > maxEpoch) {\\n                        epochDelta = maxEpoch;\\n                    }\\n\\n                    life += uint8(epochDelta) * uint8(effectiveDelta);\\n                    if (life > MAX_LIFE) {\\n                        life = MAX_LIFE;\\n                    }\\n                    newLife = life;\\n                    epochUsed = epoch;\\n                    // } else {\\n                    // \\tnewLife = life;\\n                    // \\tepochUsed = lastUpdate;\\n                    // }\\n                } else if (effectiveDelta < 0) {\\n                    uint8 numEpochBeforeDying = (life + uint8(-effectiveDelta) - 1) / uint8(-effectiveDelta);\\n                    if (epochDelta > numEpochBeforeDying) {\\n                        epochDelta = numEpochBeforeDying;\\n                    }\\n                    uint8 lifeLoss = uint8(epochDelta) * uint8(-effectiveDelta);\\n                    if (lifeLoss > life) {\\n                        newLife = 0;\\n                    } else {\\n                        newLife = life - lifeLoss;\\n                    }\\n                    epochUsed = lastUpdate + uint24(epochDelta);\\n                } else {\\n                    newLife = life;\\n                    epochUsed = epoch;\\n                }\\n            } else {\\n                newLife = life;\\n                epochUsed = lastUpdate;\\n            }\\n        }\\n    }\\n\\n    function _getUpdatedCell(uint64 position, uint24 epoch) internal view returns (Cell memory updatedCell) {\\n        // load from state\\n        updatedCell = _cells[position];\\n        uint24 lastUpdate = updatedCell.lastEpochUpdate;\\n        int8 delta = updatedCell.delta;\\n        uint8 life = updatedCell.life;\\n        // logger.logCell(0, 'before update', position, updatedCell, address(uint160(_owners[position])));\\n        if (lastUpdate >= 1 && life > 0) {\\n            (uint8 newLife, uint24 epochUsed) = _computeNewLife(lastUpdate, updatedCell.enemyMap, delta, life, epoch);\\n            updatedCell.life = newLife;\\n            updatedCell.lastEpochUpdate = epochUsed; // TODO check if this is useful to cap it to epoch where it died\\n        }\\n    }\\n\\n    /// @dev Get the owner of a token.\\n    /// @param tokenID The token to query.\\n    function _ownerOf(uint256 tokenID) internal view virtual returns (address owner) {\\n        owner = address(uint160(_owners[tokenID]));\\n    }\\n}\\n\",\"keccak256\":\"0xdbd284f70ce08e8de50c55d33d76e4873693f0b23996d8ac43e50f416b2ff570\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsStore.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport '../interface/UsingStratagemsTypes.sol';\\n\\ncontract UsingStratagemsStore is UsingStratagemsTypes {\\n\\tmapping(uint256 => Cell) internal _cells;\\n\\tmapping(uint256 => uint256) internal _owners; //owner + approval + ... erc721\\n\\n\\tmapping(address => uint256) internal _tokensInReserve;\\n\\tmapping(address => Commitment) internal _commitments;\\n\\n\\t// Operators (also used by ERC721)\\n\\tmapping(address => mapping(address => bool)) internal _operatorsForAll;\\n\\tmapping(uint256 => address) internal _operators;\\n\\n\\t// ERC721 balanceOf\\n\\t// mapping(address => uint256) internal _balances;\\n}\\n\",\"keccak256\":\"0x67d22bbc7eb4513799c8038a35e581d90ee2cb213051850ebd59f4e78cc44a2d\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport '../interface/UsingStratagemsTypes.sol';\\nimport '../interface/UsingStratagemsErrors.sol';\\n\\nabstract contract UsingStratagemsUtils is UsingStratagemsTypes, UsingStratagemsErrors {\\n\\tfunction _checkHash(\\n\\t\\tbytes24 commitmentHash,\\n\\t\\tbytes32 secret,\\n\\t\\tMove[] memory moves,\\n\\t\\tbytes24 furtherMoves\\n\\t) internal pure {\\n\\t\\tif (furtherMoves != bytes24(0)) {\\n\\t\\t\\tbytes24 computedHash = bytes24(keccak256(abi.encode(secret, moves, furtherMoves)));\\n\\t\\t\\tif (commitmentHash != computedHash) {\\n\\t\\t\\t\\trevert CommitmentHashNotMatching();\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tbytes24 computedHash = bytes24(keccak256(abi.encode(secret, moves)));\\n\\t\\t\\tif (commitmentHash != computedHash) {\\n\\t\\t\\t\\trevert CommitmentHashNotMatching();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _collectTransfer(\\n\\t\\tTokenTransferCollection memory transferCollection,\\n\\t\\tTokenTransfer memory newTransfer\\n\\t) internal pure {\\n\\t\\t// we look for the newTransfer address in case it is already present\\n\\t\\tfor (uint256 k = 0; k < transferCollection.numTransfers; k++) {\\n\\t\\t\\tif (transferCollection.transfers[k].to == newTransfer.to) {\\n\\t\\t\\t\\t// if we found we add the amount\\n\\t\\t\\t\\ttransferCollection.transfers[k].amount += newTransfer.amount;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// if we did not find that address we add it to the end\\n\\t\\ttransferCollection.transfers[transferCollection.numTransfers].to = newTransfer.to;\\n\\t\\ttransferCollection.transfers[transferCollection.numTransfers].amount = newTransfer.amount;\\n\\t\\t// and increase the size to lookup for next time\\n\\t\\ttransferCollection.numTransfers++;\\n\\t}\\n\\n\\tfunction _multiTransfer(IERC20WithIERC2612 token, TokenTransferCollection memory transferCollection) internal {\\n\\t\\tfor (uint256 i = 0; i < transferCollection.numTransfers; i++) {\\n\\t\\t\\ttoken.transfer(transferCollection.transfers[i].to, transferCollection.transfers[i].amount);\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x20ffcba1168cd6bf7b408c0265c79c8b56f022d36068e8188833ec3d1a06831d\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingVirtualTime.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport '../interface/UsingStratagemsTypes.sol';\\n\\nabstract contract UsingVirtualTime {\\n\\t// TODO use hardhat-preprocessor\\n\\n\\tITime immutable _time;\\n\\n\\tconstructor(UsingStratagemsTypes.Config memory config) {\\n\\t\\t_time = config.time;\\n\\t}\\n\\n\\tfunction _timestamp() internal view returns (uint256) {\\n\\t\\tif (address(_time) == address(0)) {\\n\\t\\t\\treturn block.timestamp;\\n\\t\\t}\\n\\t\\treturn _time.timestamp();\\n\\t}\\n}\\n\",\"keccak256\":\"0x6c1bba64cb0dfac4895bd5f17aa979c1b7b6b386bac34dc1f3474b7d803c432c\",\"license\":\"AGPL-3.0\"},\"src/game/routes/StratagemsERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport '../internal/UsingStratagemsSetters.sol';\\nimport 'solidity-kit/solc_0.8/ERC721/interfaces/IERC721.sol';\\nimport 'solidity-kit/solc_0.8/ERC721/interfaces/IERC721Metadata.sol';\\nimport 'solidity-kit/solc_0.8/ERC721/interfaces/IERC721WithBlocknumber.sol';\\nimport 'solidity-kit/solc_0.8/ERC721/interfaces/IERC721Receiver.sol';\\nimport 'solidity-kit/solc_0.8/ERC721/implementations/ImplementingERC721Internal.sol';\\nimport 'solidity-kit/solc_0.8/openzeppelin/contracts/utils/Address.sol';\\n\\ncontract StratagemsERC721 is\\n\\tIERC721,\\n\\tIERC721Metadata,\\n\\tIERC721WithBlocknumber,\\n\\tUsingStratagemsSetters,\\n\\tImplementingERC721Internal\\n{\\n\\tusing Openzeppelin_Address for address;\\n\\n\\tconstructor(Config memory config) UsingStratagemsSetters(config) {}\\n\\n\\tbytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\\n\\tuint256 internal constant OPERATOR_FLAG = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t// --------------------------------------------------------------------------------------------\\n\\t// Getters\\n\\t// --------------------------------------------------------------------------------------------\\n\\n\\t// /// @inheritdoc IERC721\\n\\t/// @notice balanceOf is not implemented, keeping track of this add gas and we did not consider that worth it\\n\\tfunction balanceOf(address) external pure override returns (uint256) {\\n\\t\\trevert('NOT_IMPLEMENTED');\\n\\t\\t// if (owner == address(0)) {\\n\\t\\t// \\trevert InvalidAddress(owner);\\n\\t\\t// }\\n\\t\\t// balance = _balances[owner];\\n\\t}\\n\\n\\t/// @inheritdoc IERC721\\n\\tfunction ownerOf(uint256 tokenID) external view override returns (address owner) {\\n\\t\\towner = _ownerOf(tokenID);\\n\\t\\tif (owner == address(0)) {\\n\\t\\t\\trevert NonExistentToken(tokenID);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @inheritdoc IERC721\\n\\tfunction getApproved(uint256 tokenID) external view override returns (address operator) {\\n\\t\\t(address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenID);\\n\\t\\tif (owner == address(0)) {\\n\\t\\t\\trevert NonExistentToken(tokenID);\\n\\t\\t}\\n\\t\\tif (operatorEnabled) {\\n\\t\\t\\treturn _operators[tokenID];\\n\\t\\t} else {\\n\\t\\t\\treturn address(0);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @inheritdoc IERC721\\n\\tfunction isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n\\t\\treturn _operatorsForAll[owner][operator];\\n\\t}\\n\\n\\t/// @inheritdoc IERC165\\n\\tfunction supportsInterface(bytes4 interfaceID) external pure returns (bool) {\\n\\t\\t/// 0x01ffc9a7 is ERC165.\\n\\t\\t/// 0x80ac58cd is ERC721\\n\\t\\t/// 0x5b5e139f is for ERC721 metadata\\n\\t\\treturn interfaceID == 0x01ffc9a7 || interfaceID == 0x80ac58cd || interfaceID == 0x5b5e139f;\\n\\t}\\n\\n\\t/// @inheritdoc IERC721Metadata\\n\\tfunction name() external pure returns (string memory) {\\n\\t\\treturn 'GemCells';\\n\\t}\\n\\n\\t/// @inheritdoc IERC721Metadata\\n\\tfunction symbol() external pure returns (string memory) {\\n\\t\\treturn 'GEM_CELL';\\n\\t}\\n\\n\\t/// @inheritdoc IERC721Metadata\\n\\tfunction tokenURI(uint256 tokenID) external view returns (string memory) {}\\n\\n\\t/// @inheritdoc IERC721WithBlocknumber\\n\\tfunction ownerAndLastTransferBlockNumberOf(\\n\\t\\tuint256 tokenID\\n\\t) external view override returns (address owner, uint256 blockNumber) {\\n\\t\\t(address currentOwner, uint256 nonce) = _ownerAndNonceOf(tokenID);\\n\\t\\towner = currentOwner;\\n\\t\\tblockNumber = (nonce >> 24);\\n\\t}\\n\\n\\t/// @inheritdoc IERC721WithBlocknumber\\n\\tfunction ownerAndLastTransferBlockNumberList(\\n\\t\\tuint256[] calldata tokenIDs\\n\\t) external view virtual returns (OwnerData[] memory ownersData) {\\n\\t\\townersData = new OwnerData[](tokenIDs.length);\\n\\t\\tfor (uint256 i = 0; i < tokenIDs.length; i++) {\\n\\t\\t\\tuint256 data = _owners[tokenIDs[i]];\\n\\t\\t\\townersData[i].owner = address(uint160(data));\\n\\t\\t\\townersData[i].lastTransferBlockNumber = (data >> 184) & 0xFFFFFFFFFFFFFFFF;\\n\\t\\t}\\n\\t}\\n\\n\\t// --------------------------------------------------------------------------------------------\\n\\t// Setters\\n\\t// --------------------------------------------------------------------------------------------\\n\\n\\t/// @inheritdoc IERC721\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data) public override {\\n\\t\\t(address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n\\t\\tif (owner == address(0)) {\\n\\t\\t\\trevert NonExistentToken(tokenID);\\n\\t\\t}\\n\\t\\tif (owner != from) {\\n\\t\\t\\trevert NotOwner(from, owner);\\n\\t\\t}\\n\\n\\t\\tif (to == address(0) || to == address(this)) {\\n\\t\\t\\trevert InvalidAddress(to);\\n\\t\\t}\\n\\n\\t\\tif (msg.sender != from) {\\n\\t\\t\\tif (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\\n\\t\\t\\t\\trevert NotAuthorized();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_safeTransferFrom(from, to, tokenID, (nonce >> 24) != 0, data);\\n\\t}\\n\\n\\t/// @inheritdoc IERC721\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenID) external override {\\n\\t\\tsafeTransferFrom(from, to, tokenID, '');\\n\\t}\\n\\n\\t/// @inheritdoc IERC721\\n\\tfunction transferFrom(address from, address to, uint256 tokenID) external override {\\n\\t\\t(address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n\\t\\tif (owner == address(0)) {\\n\\t\\t\\trevert NonExistentToken(tokenID);\\n\\t\\t}\\n\\t\\tif (from != owner) {\\n\\t\\t\\trevert NotOwner(from, owner);\\n\\t\\t}\\n\\t\\tif (to == address(0) || to == address(this)) {\\n\\t\\t\\trevert InvalidAddress(to);\\n\\t\\t}\\n\\t\\tif (msg.sender != from) {\\n\\t\\t\\tif (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\\n\\t\\t\\t\\trevert NotAuthorized();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_transferFrom(from, to, tokenID, (nonce >> 24) != 0);\\n\\t}\\n\\n\\t/// @inheritdoc IERC721\\n\\tfunction approve(address operator, uint256 tokenID) external override {\\n\\t\\t(address owner, uint256 nonce) = _ownerAndNonceOf(tokenID);\\n\\t\\tif (owner == address(0)) {\\n\\t\\t\\trevert NonExistentToken(tokenID);\\n\\t\\t}\\n\\t\\tif (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\\n\\t\\t\\trevert NotAuthorized();\\n\\t\\t}\\n\\t\\t_approveFor(owner, nonce, operator, tokenID);\\n\\t}\\n\\n\\t/// @inheritdoc IERC721\\n\\tfunction setApprovalForAll(address operator, bool approved) external override {\\n\\t\\t_setApprovalForAll(msg.sender, operator, approved);\\n\\t}\\n\\n\\t// ------------------------------------------------------------------------------------------------------------------\\n\\t// INTERNALS\\n\\t// ------------------------------------------------------------------------------------------------------------------\\n\\n\\tfunction _safeMint(address to, uint256 tokenID) internal {\\n\\t\\t_safeTransferFrom(address(0), to, tokenID, false, '');\\n\\t}\\n\\n\\tfunction _safeTransferFrom(address from, address to, uint256 tokenID, bool registered, bytes memory data) internal {\\n\\t\\t_transferFrom(from, to, tokenID, registered);\\n\\t\\tif (to.isContract()) {\\n\\t\\t\\tif (!_checkOnERC721Received(msg.sender, from, to, tokenID, data)) {\\n\\t\\t\\t\\trevert TransferRejected();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _transferFrom(address from, address to, uint256 tokenID, bool registered) internal virtual {\\n\\t\\t// unchecked {\\n\\t\\t// \\t_balances[to]++;\\n\\t\\t// \\tif (registered) {\\n\\t\\t// \\t\\t_balances[from]--;\\n\\t\\t// \\t}\\n\\t\\t// }\\n\\n\\t\\t// TODO register in the Gem Generator\\n\\n\\t\\t// We encode the blockNumber in the token nonce. We can then use it for count voting.\\n\\t\\t_owners[tokenID] = (block.number << 184) | uint256(uint160(to));\\n\\t\\temit Transfer(from, to, tokenID);\\n\\t}\\n\\n\\t/// @dev See approve.\\n\\tfunction _approveFor(address owner, uint256 nonce, address operator, uint256 tokenID) internal override {\\n\\t\\tuint256 blockNumber = nonce >> 24;\\n\\t\\tuint256 newNonce = nonce + 1;\\n\\t\\tif (newNonce >> 24 != blockNumber) {\\n\\t\\t\\trevert NonceOverflow();\\n\\t\\t}\\n\\t\\tif (operator == address(0)) {\\n\\t\\t\\t_owners[tokenID] = (newNonce << 160) | uint256(uint160(owner));\\n\\t\\t} else {\\n\\t\\t\\t_owners[tokenID] = OPERATOR_FLAG | ((newNonce << 160) | uint256(uint160(owner)));\\n\\t\\t\\t_operators[tokenID] = operator;\\n\\t\\t}\\n\\t\\temit Approval(owner, operator, tokenID);\\n\\t}\\n\\n\\t/// @dev See setApprovalForAll.\\n\\tfunction _setApprovalForAll(address sender, address operator, bool approved) internal override {\\n\\t\\t_operatorsForAll[sender][operator] = approved;\\n\\n\\t\\temit ApprovalForAll(sender, operator, approved);\\n\\t}\\n\\n\\t/// @dev Check if receiving contract accepts erc721 transfers.\\n\\t/// @param operator The address of the operator.\\n\\t/// @param from The from address, may be different from msg.sender.\\n\\t/// @param to The adddress we want to transfer to.\\n\\t/// @param tokenID The id of the token we would like to transfer.\\n\\t/// @param data Any additional data to send with the transfer.\\n\\t/// @return Whether the expected value of 0x150b7a02 is returned.\\n\\tfunction _checkOnERC721Received(\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 tokenID,\\n\\t\\tbytes memory data\\n\\t) internal returns (bool) {\\n\\t\\tbytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, tokenID, data);\\n\\t\\treturn (retval == ERC721_RECEIVED);\\n\\t}\\n\\n\\t/// @dev Get the owner and operatorEnabled status of a token.\\n\\t/// @param tokenID The token to query.\\n\\t/// @return owner The owner of the token.\\n\\t/// @return operatorEnabled Whether or not operators are enabled for this token.\\n\\tfunction _ownerAndOperatorEnabledOf(\\n\\t\\tuint256 tokenID\\n\\t) internal view virtual returns (address owner, bool operatorEnabled) {\\n\\t\\tuint256 data = _owners[tokenID];\\n\\t\\towner = address(uint160(data));\\n\\t\\toperatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n\\t}\\n\\n\\t/// @dev Get the owner and the permit nonce of a token.\\n\\t/// @param tokenID The token to query.\\n\\t/// @return owner The owner of the token.\\n\\t/// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\\n\\tfunction _ownerAndNonceOf(uint256 tokenID) internal view virtual override returns (address owner, uint256 nonce) {\\n\\t\\tuint256 data = _owners[tokenID];\\n\\t\\towner = address(uint160(data));\\n\\t\\tnonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\\n\\t}\\n\\n\\t// @dev Get the owner, the permit nonce of a token and operatorEnabled status of a token.\\n\\t/// @param tokenID The token to query.\\n\\t/// @return owner The owner of the token.\\n\\t/// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\\n\\t/// @return operatorEnabled Whether or not operators are enabled for this token.\\n\\tfunction _ownerNonceAndOperatorEnabledOf(\\n\\t\\tuint256 tokenID\\n\\t) internal view virtual returns (address owner, uint256 nonce, bool operatorEnabled) {\\n\\t\\tuint256 data = _owners[tokenID];\\n\\t\\towner = address(uint160(data));\\n\\t\\toperatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n\\t\\tnonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\\n\\t}\\n}\\n\",\"keccak256\":\"0x39418b74c10c06bc36e559f00bc08022d91a6cd3728f534bff803d68e6e9f1e8\",\"license\":\"AGPL-3.0\"},\"src/utils/PositionUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary PositionUtils {\\n\\tfunction toXY(uint64 position) internal pure returns (int32 x, int32 y) {\\n\\t\\tx = int32(uint32(position) & 0xFFFFFFFF);\\n\\t\\ty = int32(uint32(position >> 32));\\n\\t}\\n\\n\\tfunction offset(uint64 position, int32 x, int32 y) internal pure returns (uint64 newPosition) {\\n\\t\\tx = int32(uint32(position) & 0xFFFFFFFF) + x;\\n\\t\\ty = int32(uint32(position >> 32)) + y;\\n\\t\\tnewPosition = (uint64(uint32(y)) << 32) + uint64(uint32(x));\\n\\t}\\n}\\n\",\"keccak256\":\"0xa03af20214488f58e3558c9fdfb514b9ff1ca2aaf0818268c0f6a416cf2dc511\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 13897,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_cells",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Cell)11315_storage)"
      },
      {
        "astId": 13901,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_owners",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 13905,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_tokensInReserve",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 13910,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_commitments",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_struct(Commitment)11320_storage)"
      },
      {
        "astId": 13916,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_operatorsForAll",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 13920,
        "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
        "label": "_operators",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_uint256,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes24": {
        "encoding": "inplace",
        "label": "bytes24",
        "numberOfBytes": "24"
      },
      "t_enum(Color)11237": {
        "encoding": "inplace",
        "label": "enum UsingStratagemsTypes.Color",
        "numberOfBytes": "1"
      },
      "t_int8": {
        "encoding": "inplace",
        "label": "int8",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_struct(Commitment)11320_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct UsingStratagemsTypes.Commitment)",
        "numberOfBytes": "32",
        "value": "t_struct(Commitment)11320_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Cell)11315_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct UsingStratagemsTypes.Cell)",
        "numberOfBytes": "32",
        "value": "t_struct(Cell)11315_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Cell)11315_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Cell",
        "members": [
          {
            "astId": 11299,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "lastEpochUpdate",
            "offset": 0,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 11301,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "epochWhenTokenIsAdded",
            "offset": 3,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 11304,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "color",
            "offset": 6,
            "slot": "0",
            "type": "t_enum(Color)11237"
          },
          {
            "astId": 11306,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "life",
            "offset": 7,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11308,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "delta",
            "offset": 8,
            "slot": "0",
            "type": "t_int8"
          },
          {
            "astId": 11310,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "enemyMap",
            "offset": 9,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11312,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "distribution",
            "offset": 10,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11314,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "stake",
            "offset": 11,
            "slot": "0",
            "type": "t_uint8"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Commitment)11320_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Commitment",
        "members": [
          {
            "astId": 11317,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "hash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes24"
          },
          {
            "astId": 11319,
            "contract": "src/game/routes/StratagemsERC721.sol:StratagemsERC721",
            "label": "epoch",
            "offset": 24,
            "slot": "0",
            "type": "t_uint24"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  },
  "userdoc": {
    "errors": {
      "CanStillReveal()": [
        {
          "notice": "Player have to reveal if they can Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal."
        }
      ],
      "CommitmentHashNotMatching()": [
        {
          "notice": "Player have to reveal their commitment using the exact same move values  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal."
        }
      ],
      "GameNotStarted()": [
        {
          "notice": "Game has not started yet, can't perform any action"
        }
      ],
      "InCommitmentPhase()": [
        {
          "notice": "When in Commit phase, player can make new commitment but they cannot reveal their move yet."
        }
      ],
      "InRevealPhase()": [
        {
          "notice": "When in Reveal phase, it is not possible to commit new moves or cancel previous commitment  During Reveal phase, players have to reveal their commitment, if not already done."
        }
      ],
      "InvalidAddress(address)": [
        {
          "notice": "An invalid address is specified (for example: zero address)"
        }
      ],
      "InvalidEpoch()": [
        {
          "notice": "Player can only reveal their move in the same epoch they commited.abi  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`"
        }
      ],
      "InvalidFurtherMoves()": [
        {
          "notice": "Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves  This result in a recursive series of hash that they can then submit in turn while revealing.  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block."
        }
      ],
      "NonExistentToken(uint256)": [
        {
          "notice": "The token does not exist"
        }
      ],
      "NonceOverflow()": [
        {
          "notice": "The Nonce overflowed, make a transfer to self to allow new nonces."
        }
      ],
      "NotAuthorized()": [
        {
          "notice": "Not authorized to perform this operation"
        }
      ],
      "NotOwner(address,address)": [
        {
          "notice": "The address from which the token is sent is not the current owner"
        }
      ],
      "NothingToReveal()": [
        {
          "notice": "Player can only reveal moves they commited."
        }
      ],
      "PreviousCommitmentNotRevealed()": [
        {
          "notice": "Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\"
        }
      ],
      "ReserveTooLow(uint256,uint256)": [
        {
          "notice": "to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase."
        }
      ],
      "TransferRejected()": [
        {
          "notice": "The Transfer was rejected by the destination"
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "notice": "Triggered when a token is approved to be sent by another account  Note tat the approval get reset when a Transfer event for that same token is emitted."
      },
      "ApprovalForAll(address,address,bool)": {
        "notice": "Triggered when an account approve or disaprove another to transfer on its behalf"
      },
      "CommitmentCancelled(address,uint24)": {
        "notice": "A player has cancelled its current commitment (before it reached the reveal phase)"
      },
      "CommitmentMade(address,uint24,bytes24)": {
        "notice": "A player has commited to make a move and reveal it on the reveal phase"
      },
      "CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)": {
        "notice": "Player has revealed its previous commitment"
      },
      "CommitmentVoid(address,uint24,uint256,bytes24)": {
        "notice": "A player has canceled a previous commitment by burning some tokens"
      },
      "MoveProcessed(uint64,address,uint8,uint8)": {
        "notice": "A move has been revealed."
      },
      "MultiPoke(uint24,uint64[])": {
        "notice": "poke multiple cells and update them if needed"
      },
      "ReserveDeposited(address,uint256,uint256)": {
        "notice": "Player has deposited token in the reserve, allowing it to use that much in game"
      },
      "ReserveWithdrawn(address,uint256,uint256)": {
        "notice": "Player have withdrawn token from the reserve"
      },
      "SinglePoke(uint24,uint64)": {
        "notice": "poke cell and update it if needed"
      },
      "Transfer(address,address,uint256)": {
        "notice": "Triggered when a token is transferred"
      }
    },
    "kind": "user",
    "methods": {
      "approve(address,uint256)": {
        "notice": "Approve an operator to transfer a specific token on the senders behalf."
      },
      "balanceOf(address)": {
        "notice": "balanceOf is not implemented, keeping track of this add gas and we did not consider that worth it"
      },
      "getApproved(uint256)": {
        "notice": "Get the approved operator for a specific token."
      },
      "isApprovedForAll(address,address)": {
        "notice": "Check if the sender approved the operator to transfer any of its tokens."
      },
      "name()": {
        "notice": "A descriptive name for a collection of NFTs in this contract"
      },
      "ownerAndLastTransferBlockNumberList(uint256[])": {
        "notice": "Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism."
      },
      "ownerAndLastTransferBlockNumberOf(uint256)": {
        "notice": "Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism."
      },
      "ownerOf(uint256)": {
        "notice": "Get the owner of a token."
      },
      "safeTransferFrom(address,address,uint256)": {
        "notice": "Transfer a token between 2 addresses letting the receiver know of the transfer."
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "notice": "Transfer a token between 2 addresses letting the receiver knows of the transfer."
      },
      "setApprovalForAll(address,bool)": {
        "notice": "Set the approval for an operator to manage all the tokens of the sender."
      },
      "supportsInterface(bytes4)": {
        "notice": "Query if a contract implements an interface"
      },
      "symbol()": {
        "notice": "An abbreviated name for NFTs in this contract"
      },
      "tokenURI(uint256)": {
        "notice": "A distinct Uniform Resource Identifier (URI) for a given asset."
      },
      "transferFrom(address,address,uint256)": {
        "notice": "Transfer a token between 2 addresses."
      }
    },
    "version": 1
  },
  "argsData": "0x00000000000000000000000033a0d701f0619afb407963d6b7f9781dc40f9fcf000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000143700000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000052092c12759ac66d997d402c07d5449b3f2136f8",
  "transaction": {
    "hash": "0xf114430185381dab5b234a7b002fe5a0366eeb6162be90da5955ad7539aae6f3",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "confirmations": 0,
    "blockHash": "0xaa299665bd71937fee376d943da56af9a6acd0e7fab5065409b7c31d2ed2aafc",
    "blockNumber": "0x3e843f",
    "transactionIndex": "0x1"
  }
}