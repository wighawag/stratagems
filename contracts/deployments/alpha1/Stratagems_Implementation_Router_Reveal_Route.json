{
  "address": "0x53b38bd39c7535b1fb4e82eccb74fcc65cde27ad",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract IERC20WithIERC2612",
              "name": "tokens",
              "type": "address"
            },
            {
              "internalType": "address payable",
              "name": "burnAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "commitPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "revealPhaseDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "maxLife",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "numTokensPerGems",
              "type": "uint256"
            },
            {
              "internalType": "contract ITime",
              "name": "time",
              "type": "address"
            },
            {
              "internalType": "contract IOnStakeChange",
              "name": "generator",
              "type": "address"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CanStillReveal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CommitmentHashNotMatching",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "GameNotStarted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ImpossibleConfiguration",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InCommitmentPhase",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InRevealPhase",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEpoch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFurtherMoves",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NothingToReveal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PreviousCommitmentNotRevealed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "inReserve",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expected",
          "type": "uint256"
        }
      ],
      "name": "ReserveTooLow",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        }
      ],
      "name": "CommitmentCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentMade",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": true,
          "internalType": "bytes24",
          "name": "commitmentHash",
          "type": "bytes24"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "enum UsingStratagemsTypes.Color",
              "name": "color",
              "type": "uint8"
            }
          ],
          "indexed": false,
          "internalType": "struct UsingStratagemsTypes.Move[]",
          "name": "moves",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newReserveAmount",
          "type": "uint256"
        }
      ],
      "name": "CommitmentRevealed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountBurnt",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        }
      ],
      "name": "CommitmentVoid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "enum UsingStratagemsTypes.Color",
          "name": "oldColor",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "enum UsingStratagemsTypes.Color",
          "name": "newColor",
          "type": "uint8"
        }
      ],
      "name": "MoveProcessed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint64[]",
          "name": "positions",
          "type": "uint64[]"
        }
      ],
      "name": "MultiPoke",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountDeposited",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "ReserveDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountWithdrawn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAmount",
          "type": "uint256"
        }
      ],
      "name": "ReserveWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint24",
          "name": "epoch",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "position",
          "type": "uint64"
        }
      ],
      "name": "SinglePoke",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "secret",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "enum UsingStratagemsTypes.Color",
              "name": "color",
              "type": "uint8"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Move[]",
          "name": "moves",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        }
      ],
      "name": "acknowledgeMissedReveal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acknowledgeMissedRevealByBurningAllReserve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "player",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "secret",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "position",
              "type": "uint64"
            },
            {
              "internalType": "enum UsingStratagemsTypes.Color",
              "name": "color",
              "type": "uint8"
            }
          ],
          "internalType": "struct UsingStratagemsTypes.Move[]",
          "name": "moves",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes24",
          "name": "furtherMoves",
          "type": "bytes24"
        },
        {
          "internalType": "bool",
          "name": "useReserve",
          "type": "bool"
        },
        {
          "internalType": "address payable",
          "name": "payee",
          "type": "address"
        }
      ],
      "name": "reveal",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "contractName": "StratagemsReveal",
  "sourceName": "src/game/routes/StratagemsReveal.sol",
  "bytecode": "0x6101a03462000294576200432d601f38829003908101601f19168301906001600160401b039081831185841017620002995780859460409485528539610120938491810103126200029457815190838201908111828210176200029957825283516001600160a01b0390818116810362000294578252602085015190808216820362000294576020830191825283860151928481019384526060870151906060810191825260808801516080820190815260a08901519060ff82168203620002945760a0830191825260c08a01519360c0840194855260e08b01519386851694858103620002945760e0820152610100809c01519787891689036200029457878260ff978f8395019b8c52608052511660a0525116976101609889525160c0525160e052518952511686525191610140928352511692610180938452519361407d9586620002b087396080518661134d015260a05186818161039c015281816106db0152818161079801528181610aee0152610cf7015260c051866110ac015260e051866110570152518561107c01525184818161158101528181612ee00152613281015251838181610a36015281816115d801528181611ae601528181611ec301528181611f6d01528181612c8101528181613a1a0152613bd701525182818161069201528181610a9e0152610ca7015251818181611e5801528181611f0901528181612143015281816121d00152818161225b015281816122eb015281816123ab0152818161243f015281816124f201528181612586015281816125dc0152818161266c015281816127120152818161279f0152818161287801528181612905015281816129fe01528181612a9201528181612af201528181612b8601528181613a5601528181613ae80152613ba90152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe60c0604052600436101561001257600080fd5b60003560e01c80631fdd8a6914610bd0578063599a71c6146109055763d40197831461003d57600080fd5b60c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105855761006f610d77565b60443567ffffffffffffffff81116105855761008f903690600401610d9a565b90610098610dcb565b906084359384151585036105855760a4359473ffffffffffffffffffffffffffffffffffffffff861686036105855773ffffffffffffffffffffffffffffffffffffffff821660005260046020526040600020956100f4611055565b9490946108db5787549262ffffff93848160c01c1680156108b15785881603610887578761013491610127368c87610f18565b906024359060401b6111b5565b15610880576000965b610148368284610f18565b938451998a60058102046005148b1517156108515761016960058c02610eeb565b9a6040519b610178908d610e92565b600502808c5261018790610eeb565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00160005b81811061082b5750506040519a6101c28c610dfa565b8b52600060208c01526101d36112c3565b9860005b8c8851821015610237579061022c61021460408e6102208f8f978f916001996102038a61020a956112f3565b519261140a565b9590918451610ffa565b83526020830151610ffa565b60208201520151610ffa565b60408d0152016101d7565b9a999750508a97959773ffffffffffffffffffffffffffffffffffffffff87166000526003602052604060002054906102768b5160208d015190610ffa565b82106107e45773ffffffffffffffffffffffffffffffffffffffff811661061957506102b56040916102af8c6020815191015190610ffa565b90610fb1565b9973ffffffffffffffffffffffffffffffffffffffff881660005260036020528a82600020555b0151806105df575b5060005b60208b015181101561040f578060208c8161032a8473ffffffffffffffffffffffffffffffffffffffff6103206103819886516112f3565b51511693516112f3565b5101516040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9092166004830152602482015292839081906044820190565b0381600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af1918215610403576001926103d4575b50016102e8565b6103f59060203d6020116103fc575b6103ed8183610e92565b810190610ed3565b508c6103cd565b503d6103e3565b6040513d6000823e3d90fd5b5081547fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000009290918a918482169182156105b4576020880361058a5760401c7fffffffffffffffff0000000000000000000000000000000000000000000000008254161790555b60405195806060880160608952526080870197906000905b80821061053f575050509273ffffffffffffffffffffffffffffffffffffffff92869592869560207ffab312c5020dc7093e590463878dbfd0567314a7c155b164a60430ebcc7b3803990152604086015260401b1697169516930390a473ffffffffffffffffffffffffffffffffffffffff811661050757005b600080808093813415610536575b73ffffffffffffffffffffffffffffffffffffffff34921690f11561040357005b506108fc610515565b90919867ffffffffffffffff6105548b610f03565b16815260208a01359060078210156105855760408161057a600194602084950190610fbe565b019a0192019061048d565b600080fd5b60046040517fcc586b45000000000000000000000000000000000000000000000000000000008152fd5b507fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff84169055610475565b604051610613916105ef82610dfa565b73ffffffffffffffffffffffffffffffffffffffff8916825260208201528b613019565b8a6102e4565b909980518061072b575b50602081015180610639575b50604091506102dc565b73ffffffffffffffffffffffffffffffffffffffff604051937f23b872dd00000000000000000000000000000000000000000000000000000000855216600484015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660248401526044830152602082606481600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af1918215610403576040921561062f576107249060203d6020116103fc576103ed8183610e92565b508c61062f565b604051907f23b872dd00000000000000000000000000000000000000000000000000000000825273ffffffffffffffffffffffffffffffffffffffff841660048301523060248301526044820152602081606481600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af180156104035715610623576107dd9060203d6020116103fc576103ed8183610e92565b508c610623565b6044826107f88d6020815191015190610ffa565b604051917f78fe52a600000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b808d602080936040519261083e84610dfa565b60008452600083850152010152016101ac565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b839661013d565b60046040517fd5b25b63000000000000000000000000000000000000000000000000000000008152fd5b60046040517f6599c9aa000000000000000000000000000000000000000000000000000000008152fd5b60046040517f24f7f40f000000000000000000000000000000000000000000000000000000008152fd5b346105855760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105855761093c610d77565b60443567ffffffffffffffff81116105855761095c903690600401610d9a565b91610965610dcb565b9273ffffffffffffffffffffffffffffffffffffffff809216928360005260209160048352604060002095610998611055565b509187549762ffffff94858a60c01c168015908115610bc4575b50610b9a57836109c76109d392853691610f18565b6024358c60401b6111b5565b7fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008316988915610b6c575085820361058a57610a5b9260401c7fffffffffffffffff0000000000000000000000000000000000000000000000008254161790555b7f000000000000000000000000000000000000000000000000000000000000000090610f9e565b9533600052600384526040600020610a74888254610fb1565b90556040517fa9059cbb0000000000000000000000000000000000000000000000000000000081527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16600482015260248101889052948490869060449082906000907f0000000000000000000000000000000000000000000000000000000000000000165af1938415610403577f6337d70daadadd11f8be7f6e7b38e6c04d28710b1f2a2894bb14d8e3eaa8cdb695604095610b4f575b5084519788528701521693a3005b610b6590823d84116103fc576103ed8183610e92565b5088610b41565b610a5b93507fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff169055610a34565b60046040517f175868d7000000000000000000000000000000000000000000000000000000008152fd5b9050868616148b6109b2565b346105855760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105855733600052602060048152604060002090610c17611055565b5091805462ffffff808260c01c169485156108b15716809414610b9a577fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff1690553360009081526003825260408082208054929055517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166004820152602481018290529091808280604481010381600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af191821561040357600092610d5a575b506040519283528201527f6337d70daadadd11f8be7f6e7b38e6c04d28710b1f2a2894bb14d8e3eaa8cdb660403392a3005b610d7090823d84116103fc576103ed8183610e92565b5084610d28565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361058557565b9181601f840112156105855782359167ffffffffffffffff8311610585576020808501948460061b01011161058557565b606435907fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008216820361058557565b6040810190811067ffffffffffffffff821117610e1657604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b610120810190811067ffffffffffffffff821117610e1657604052565b60a0810190811067ffffffffffffffff821117610e1657604052565b67ffffffffffffffff8111610e1657604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610e1657604052565b90816020910312610585575180151581036105855790565b67ffffffffffffffff8111610e165760051b60200190565b359067ffffffffffffffff8216820361058557565b929192610f2482610eeb565b604092610f346040519283610e92565b819581835260208093019160061b84019381851161058557915b848310610f5d57505050505050565b858383031261058557855190610f7282610dfa565b610f7b84610f03565b82528484013590600782101561058557828692838a950152815201920191610f4e565b8181029291811591840414171561085157565b9190820391821161085157565b906007821015610fcb5752565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9190820180921161085157565b8115611011570490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b62ffffff918216908216039190821161085157565b7f0000000000000000000000000000000000000000000000000000000000000000906110a17f000000000000000000000000000000000000000000000000000000000000000083610ffa565b916110aa611336565b7f0000000000000000000000000000000000000000000000000000000000000000808210611136576110db91610fb1565b6110e58482611007565b90600282018092116108515762ffffff809216947ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe86019083821161085157611132936102af9216610f9e565b1090565b60046040517f3a5f7b57000000000000000000000000000000000000000000000000000000008152fd5b90815180825260208080930193019160005b828110611180575050505090565b909192938260406001926111a983895167ffffffffffffffff8151168452015184830190610fbe565b01950193929101611172565b927fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000009283929183168015611272576112099161123b9160405193849260208401968752606060408501526080840190611160565b906060830152037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282610e92565b5190201691160361124857565b60046040517fd13415b5000000000000000000000000000000000000000000000000000000008152fd5b5061123b61129791604051928391602083019586526040808401526060830190611160565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282610e92565b604051906060820182811067ffffffffffffffff821117610e165760405260006040838281528260208201520152565b80518210156113075760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001680156113e5576020600491604051928380927fb80777ea0000000000000000000000000000000000000000000000000000000082525afa908115610403576000916113b6575090565b90506020813d6020116113dd575b816113d160209383610e92565b81010312610585575190565b3d91506113c4565b504290565b9060ff8091169116019060ff821161085157565b6007821015610fcb5752565b9093929192825190600060a05260a0515060405161142781610e45565b60a051815260a051602082015260a051604082015260a051606082015260a051608082015260a05160a082015260a05160c082015260a05160e082015261010060a05191015267ffffffffffffffff60a051921660a0515260a051602052604060a05120916040519261149984610e45565b5462ffffff8116845262ffffff8160181c16602085015262ffffff8160301c1660408501526114d160ff8260481c16606086016113fe565b60ff8160501c1660808501528060581c60a0510b60a085015260ff8160601c1660c085015260ff8160681c1660e085015260ff8160701c166101008501528662ffffff8551169160018310158061300a575b612fcc575b505060a084015160a0510b61154860a0519160ff60c088015116906133d2565b60a0510b13612fa3575b5060ff60e084015116608052612f76575b60208401516007811015611e1057612ea65760ff60808301511660ff7f00000000000000000000000000000000000000000000000000000000000000001614801590612e4e575b612e3e576116026040516115bd81610dfa565b73ffffffffffffffffffffffffffffffffffffffff881681527f0000000000000000000000000000000000000000000000000000000000000000602082015284613019565b67ffffffffffffffff8451166060830151906007821015611e105760208601516007811015611e10576116469061163c6040518095610fbe565b6020840190610fbe565b7f17b85ded3fb12432ee427abc34a3026e1fbbb8bc431e3dbe51bc81215655c25c604073ffffffffffffffffffffffffffffffffffffffff8a1693a360a0516060830151926007841015611e105760ff610100820151169580519760208201519860078a1015611e10576040519687608081011067ffffffffffffffff60808a011117612e0d576080880160405260803689376116e16112c3565b9a6116f463ffffffff841660030b613490565b67ffffffff0000000061171263ffffffff8660201c1660030b6134c5565b60201b1667ffffffffffffffff63ffffffff8316820111612353578d6117b86117a761ffff61178c60405161174681610e62565b67ffffffffffffffff63ffffffff8916880116815262ffffff8c1660208201526002604082015261177a8a606083016113fe565b61178789608083016113fe565b613554565b60a05191939184810b12612dfa575b82604087015116613442565b166040840152825160a0510b613458565b60a0510b905260018060805160041c1614612db9575b50506117e263ffffffff841660030b6134c5565b67ffffffff0000000061180063ffffffff8660201c1660030b613490565b60201b1667ffffffffffffffff63ffffffff8316820111612353578d6118826117a761ffff61186860405161183481610e62565b67ffffffffffffffff63ffffffff8916880116815262ffffff8c1660208201526003604082015261177a8a606083016113fe565b60a05191939184810b12612da65782604087015116613442565b60a0510b905260028060805160041c1614612d62575b50506118ac63ffffffff841660030b613490565b67ffffffff000000006118ca63ffffffff8660201c1660030b61351c565b60201b1667ffffffffffffffff63ffffffff8316820111612353578d61194d6117a761ffff6119336040516118fe81610e62565b67ffffffffffffffff63ffffffff8916880116815262ffffff8c16602082015260a051604082015261177a8a606083016113fe565b60a05191939184810b12612d4f5782604087015116613442565b60a0510b9052600480608051811c1614612d0b575b505067ffffffff0000000061199063ffffffff61198381871660030b61351c565b9560201c1660030b613490565b60201b1667ffffffffffffffff63ffffffff851682011161235357611a23604061ffff8f948897611787611a0a92611a01611a349a62ffffff67ffffffffffffffff889b63ffffffff8b51986119e58a610e62565b1601169d8e8752166020860152600188860152606085016113fe565b608083016113fe565b92909560a0518760a0510b12612cf8575b015116613442565b1660408d01528b5160a0510b613458565b60a0510b8a5260088060805160041c1614612cc7575b50885160a0510b9961ffff604060ff60208d0151169b01511680612c29575b5060a0515b60ff81166004811015611b325760ff91818c8b73ffffffffffffffffffffffffffffffffffffffff611aa260019683613431565b5116611ab3575b5050500116611a6e565b73ffffffffffffffffffffffffffffffffffffffff611ad8611b2a94611b1093613431565b511691611b0a600f608051167f0000000000000000000000000000000000000000000000000000000000000000611007565b90610f9e565b60405191611b1d83610dfa565b825260208201528c613019565b388c8b611aa9565b5050949993989297509450945060208501516007811015611e1057611b5a90606088016113fe565b60a05160e087015273ffffffffffffffffffffffffffffffffffffffff831673ffffffffffffffffffffffffffffffffffffffff611bc467ffffffffffffffff885116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b161480612c19575b15612c09575b60608601516007811015611e1057611f6557505062ffffff80611c0560a087015160a0510b60ff60c089015116906133d2565b9381875116900316816040870151160116604085015260a051608085015260a05161010085015260a051845260a05160a085015260a05160c0850152611c7767ffffffffffffffff845116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b9167ffffffffffffffff845116806040519473ffffffffffffffffffffffffffffffffffffffff60a05191167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60a05160a051a460a05152600160205260a051604060a051205560a0519060a0510b13611e41575b505067ffffffffffffffff905b511660a0515260a051602052604060a051209062ffffff8151169082549165ffffff000000602083015160181b169068ffffff000000000000604084015160301b166060840151926007841015611e1057849369ff0000000000000000006bff00000000000000000000009386959386947fffffffffffffffffffffffffffffffffff0000000000000000000000000000006eff00000000000000000000000000006101006dff0000000000000000000000000060e06cff00000000000000000000000060c060a06aff0000000000000000000060808f015160501b169d015160581b9e015160601b169d015160681b169c015160701b169b161717179160481b16171791161717171790559060a0519060a05190565b7f4e487b710000000000000000000000000000000000000000000000000000000060a051526021600452602460a051fd5b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52577fabe7f1ab00000000000000000000000000000000000000000000000000000000825260a05173ffffffffffffffffffffffffffffffffffffffff90911660048301527f00000000000000000000000000000000000000000000000000000000000000006024830152818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857611f3c575b80611cec565b611f4590610e7e565b60a051611f525738611f36565b60a05180fd5b6040513d60a051823e3d90fd5b9193929095507f000000000000000000000000000000000000000000000000000000000000000095611fa760a087015160a0510b60ff60c089015116906133d2565b9060ff6080880151169360c088015260608701516007811015611e105760061480612bf9575b15612be45760ff6001816101008a01511601168061010089015215612bd7575b60a08701526002608087015262ffffff8216865261203767ffffffffffffffff855116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b9461205260a088015160a0510b60ff60c08a015116906133d2565b9260608801516007811015611e105760060361294e57505073ffffffffffffffffffffffffffffffffffffffff8581161461283f5773ffffffffffffffffffffffffffffffffffffffff8516612219575060a05190810b13905061212c575b73ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff925b8184845116928392167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60a05160a051a460a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a0512055611cf9565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff600482015284602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857612203575b506120b1565b61220c90610e7e565b60a051611f5257386121fd565b60a05190810b139081158080612832575b156123845750505050838060011b04600214841517156123535773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff60048201528460011b602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f585761233d575b5073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff926120d1565b61234690610e7e565b60a051611f525738612318565b7f4e487b710000000000000000000000000000000000000000000000000000000060a051526011600452602460a051fd5b8280612824575b15612490575050505073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517fabe7f1ab00000000000000000000000000000000000000000000000000000000815260a05173ffffffffffffffffffffffffffffffffffffffff8416600483015260248201869052818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f585761233d575073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff926120d1565b80612816575b156124c3575b50505073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff926120d1565b81612807575b506124d6575b808061249c565b156126ed5773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517fabe7f1ab00000000000000000000000000000000000000000000000000000000815260a05173ffffffffffffffffffffffffffffffffffffffff8416600483015260248201869052818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f58576126d7575b50838060011b04600214841517156123535773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff60048201528460011b602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f58576126c1575b5073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff925b92506124cf565b6126ca90610e7e565b60a051611f525738612699565b6126e090610e7e565b60a051611f5257386125b3565b838004600114841517156123535773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff600482015284602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f58576127f1575b5073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff926126ba565b6127fa90610e7e565b60a051611f5257386127cc565b60a05190810b139050386124c9565b5060a05181810b1315612496565b5060a05182810b131561238b565b5060a05182810b1361222a565b509192505060a0519060a0510b13612861575b67ffffffffffffffff90611cf9565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff600482015283602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857612938575b50612852565b61294190610e7e565b60a051611f525738612932565b90955062ffffff919293501662ffffff60208701511614159081612bc8575b50612adb575b60a05190810b136129e7575b73ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff92838351168083831660a0517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60a05160a051a460a05152600160205216604060a0512055611cf9565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815260a05173ffffffffffffffffffffffffffffffffffffffff8416600483015260248201869052818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857612ac5575b5061297f565b612ace90610e7e565b60a051611f525738612abf565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517fabe7f1ab00000000000000000000000000000000000000000000000000000000815260a05173ffffffffffffffffffffffffffffffffffffffff8516600483015260248201879052818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857612bb9575b50612973565b612bc290610e7e565b38612bb3565b60a05190810b1390503861296d565b60ff610100880152611fed565b600161010088015260a0516040880152611fed565b5060ff6080880151161515611fcd565b62ffffff84166020870152611bd2565b5060ff6080870151161515611bcc565b612cc190600c612ca673ffffffffffffffffffffffffffffffffffffffff612c7d67ffffffffffffffff895116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b16927f000000000000000000000000000000000000000000000000000000000000000090610f9e565b0460405191612cb483610dfa565b8252602082015289613019565b38611a69565b60a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a051205416606087015238611a4a565b60208101600860ff825116179052611a1b565b63ffffffff67ffffffffffffffff9216011660a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a05120541660408a01523880611962565b60208601600460ff82511617905261179b565b63ffffffff67ffffffffffffffff9216011660a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a05120541660208a01523880611898565b60208601600260ff82511617905261179b565b63ffffffff67ffffffffffffffff9216011660a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a051205416895238806117ce565b60208601600160ff82511617905261179b565b7f4e487b710000000000000000000000000000000000000000000000000000000060a051526041600452602460a051fd5b60a0519550859450849350915050565b50612e8567ffffffffffffffff855116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b73ffffffffffffffffffffffffffffffffffffffff808816911614156115aa565b62ffffff60208301511662ffffff861614612ec1575b611602565b608082015160ff168015612edc575060066020850152611602565b60ff7f00000000000000000000000000000000000000000000000000000000000000001614801590612f1e575b15612ebc5760a0519550859450849350915050565b50612f5567ffffffffffffffff855116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b73ffffffffffffffffffffffffffffffffffffffff80881691161415612f09565b612f9660c083015160f0612f8c60ff8316613151565b9160041b166113ea565b60805260a0518252611563565b612fc0612fb462ffffff9289611040565b826040870151166130f5565b16604084015238611552565b60ff929350908183612ff19360501c1690848160581c60a0510b9160601c168661320e565b501680608085015262ffffff8716845215908638611528565b5060ff8160501c161515611523565b60005b6020808301518210156130815773ffffffffffffffffffffffffffffffffffffffff8061304a8486516112f3565b515116908551161461305f575060010161301c565b90613073908261307d9495015194516112f3565b5101918251610ffa565b9052565b505060206130c28173ffffffffffffffffffffffffffffffffffffffff855116948451956130b4838701978851906112f3565b5152015192518451906112f3565b51015280517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610851576001019052565b91909162ffffff8080941691160191821161085157565b60ff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9116019060ff821161085157565b9060ff8091169116039060ff821161085157565b6000906000905b60ff90818116156131ae578061316e839261310c565b1692169081146131815760010190613158565b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b5050919050565b60000b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8081146108515760000390565b9060ff169081156110115760ff160490565b9060ff8091169116029060ff821691820361085157565b939194926000958562ffffff9360018583161015806133c6575b613235575b505050505050565b919395965091939650846132498389611040565b169283156133b8579061325b916133d2565b938460000b6000811360001461330857505050906132d46132ba60ff6132da94816132c47f0000000000000000000000000000000000000000000000000000000000000000986132bf6132ae898c61313d565b918416968780936113ea565b61310c565b6131e5565b16808211613300575b50166131f7565b906113ea565b9060ff811660ff8316116132f8575b5091905b38808080808061322d565b9050386132e9565b9050386132cd565b600090979193969597949294126000146133ab57506132ba613329876131b5565b61334d61333c60ff9384938416866113ea565b6133458a6131b5565b8316906131e5565b168087116133a1575b5061337261336861338c9697986131b5565b82168289166131f7565b9082811690821611156133925750506000945b16906130f5565b906132ed565b61339b9161313d565b94613385565b9550613372613356565b90955093506132ed915050565b5050945050905091906132ed565b5060ff84161515613228565b909190600090810b131561340a576001915b600083810b1290816133fe575b506133f857565b60019150565b60ff91501615386133f1565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff916133e4565b9060048110156113075760051b0190565b91909161ffff8080941691160191821161085157565b9060000b9060000b01907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808212607f83131761085157565b60030b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffff800000008212637fffffff83131761085157565b60030b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190637fffffff82137fffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000000083121761085157565b60030b60010190637fffffff82137fffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000000083121761085157565b6000916000809267ffffffffffffffff815116825281602052604082206040519061357e82610e45565b549262ffffff908185168352818560181c166020840152818560301c16604084015260ff9460608401956135b7818360481c16886113fe565b6080850192818360501c16845260a08601928060581c820b84528260c0880191818160601c168352818160681c1660e08a015260701c1661010088015285875116985160078110156136bc57829080151590816136e9575b5060018b101591826136ae575b505061362e575b505050505050505050565b909184819495969798999a9b5051168015158061369f575b15613687575091613670959391816136779a969451169251900b925116926020880151169361320e565b5091613771565b905b388080808080808080613623565b97955050505050506136999350613771565b90613679565b508660208a0151168a10613646565b9091506136bc57388061361c565b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b91509c50608089015160078110156137325783910361370c5760015b9c3861360f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613705565b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b60ff1660ff8111610851576001901b90565b9291600093600091828360ff608087015116151580613fe8575b613fc6575b60e086015190600f60408601926137aa60ff85511661375f565b9060041c16166137bd60ff84511661375f565b14613f29575b60ff6137dc60a0890151830b8260c08b015116906133d2565b9251169060608601516007811015613efc57608087015160078110156136bc57908189959493928203613cbd575b5050505067ffffffffffffffff8551169262ffffff602087015116938152600160205273ffffffffffffffffffffffffffffffffffffffff6040822054169081151580613cb1575b6139db575b5050918160ff9367ffffffffffffffff9695930b136139ae575b86521660808501525116815280602052604081209162ffffff8151169183549265ffffff000000602084015160181b1668ffffff000000000000604085015160301b169160608501519360078510156139815750849369ff00000000000000000085946bff00000000000000000000009486947fffffffffffffffffffffffffffffffffff0000000000000000000000000000006eff00000000000000000000000000006101006dff0000000000000000000000000060e06cff00000000000000000000000060c060a06aff0000000000000000000060808f015160501b169d015160581b9e015160601b169d015160681b169c015160701b169b161717179160481b1617179116171717179055565b807f4e487b7100000000000000000000000000000000000000000000000000000000602492526021600452fd5b6139be62ffffff88511682611040565b62ffffff6139d360408a0192828451166130f5565b169052613871565b909192506139f760a0890151820b60ff60c08b015116906133d2565b8184810b13808091613ca5575b15613b6257505050613a3e60ff610100890151167f0000000000000000000000000000000000000000000000000000000000000000610f9e565b9073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15613b5e576040517fabe7f1ab00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff909116600482015260248101919091528581806044810103818373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015613b535790869291613b37575b509167ffffffffffffffff94939160ff935b91938193959650613857565b613b4390929192610e7e565b613b4f57849038613b19565b8480fd5b6040513d88823e3d90fd5b8680fd5b91809392989796959498159182613c99575b5050613b92575b50509060ff918467ffffffffffffffff9596613b2b565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016613bfb60ff6101008b0151167f0000000000000000000000000000000000000000000000000000000000000000610f9e565b91813b15613c95576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff919091166004820152602481019290925282908290604490829084905af18015613c8a5715613b7b5767ffffffffffffffff955090613c8060ff949392610e7e565b9481929350613b7b565b6040513d84823e3d90fd5b8380fd5b810b1390508238613b74565b508282810b1315613a04565b5060ff86161515613852565b8091929394955015600014613dc3575060608901516007811015613d9657889493929103613d07575050613cf660a0880151840b613ff3565b830b60a08801525b3880808061380a565b90919250600160a0890151850b820b01907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808212607f831317613d69575086929160ff91850b60a08a015281600160c08b0151921b18161660c0880152613cfe565b807f4e487b7100000000000000000000000000000000000000000000000000000000602492526011600452fd5b6024867f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b60608a9493940180516007811015613d96578303613e595750505060ff60018160c08b015116921b161760c08801527ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe60a0880151840b820b0190607f82137fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80831217613d695750820b60a08701528490613cfe565b9591959392935160078110156137325789959493929103613ebd5750908160ff929515600014613eb357613e9560015b60a08c0151830b613458565b900b60a08a015281600160c08b0151921b18161660c0880152613cfe565b613e956002613e89565b9415613ecb575b5050613cfe565b613eda60a08a0151820b613ff3565b900b60a089015260ff60018160c08b015116921b161760c08801523880613ec4565b6024827f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b9750600c60ff610100880151160260ff8116908103613f9957613f5660ff91600f60e08a015116906131e5565b169760e087015160041c60ff8351169060ff82116131815760ff9160f0613f8e926001600f60e08e015116931b191660041b166113ea565b1660e08801526137c3565b6024897f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b60ff613fdd60c088015160f0612f8c848316613151565b1660e0870152613790565b5060ff83161561378b565b60000b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808212607f8313176108515756fea2646970667358221220238855f28e6a7b2f9f80204df33e36772d1b0a2e8cb65b0ab95e6a3b6662964f64736f6c63430008180033",
  "deployedBytecode": "0x60c0604052600436101561001257600080fd5b60003560e01c80631fdd8a6914610bd0578063599a71c6146109055763d40197831461003d57600080fd5b60c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105855761006f610d77565b60443567ffffffffffffffff81116105855761008f903690600401610d9a565b90610098610dcb565b906084359384151585036105855760a4359473ffffffffffffffffffffffffffffffffffffffff861686036105855773ffffffffffffffffffffffffffffffffffffffff821660005260046020526040600020956100f4611055565b9490946108db5787549262ffffff93848160c01c1680156108b15785881603610887578761013491610127368c87610f18565b906024359060401b6111b5565b15610880576000965b610148368284610f18565b938451998a60058102046005148b1517156108515761016960058c02610eeb565b9a6040519b610178908d610e92565b600502808c5261018790610eeb565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00160005b81811061082b5750506040519a6101c28c610dfa565b8b52600060208c01526101d36112c3565b9860005b8c8851821015610237579061022c61021460408e6102208f8f978f916001996102038a61020a956112f3565b519261140a565b9590918451610ffa565b83526020830151610ffa565b60208201520151610ffa565b60408d0152016101d7565b9a999750508a97959773ffffffffffffffffffffffffffffffffffffffff87166000526003602052604060002054906102768b5160208d015190610ffa565b82106107e45773ffffffffffffffffffffffffffffffffffffffff811661061957506102b56040916102af8c6020815191015190610ffa565b90610fb1565b9973ffffffffffffffffffffffffffffffffffffffff881660005260036020528a82600020555b0151806105df575b5060005b60208b015181101561040f578060208c8161032a8473ffffffffffffffffffffffffffffffffffffffff6103206103819886516112f3565b51511693516112f3565b5101516040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9092166004830152602482015292839081906044820190565b0381600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af1918215610403576001926103d4575b50016102e8565b6103f59060203d6020116103fc575b6103ed8183610e92565b810190610ed3565b508c6103cd565b503d6103e3565b6040513d6000823e3d90fd5b5081547fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000009290918a918482169182156105b4576020880361058a5760401c7fffffffffffffffff0000000000000000000000000000000000000000000000008254161790555b60405195806060880160608952526080870197906000905b80821061053f575050509273ffffffffffffffffffffffffffffffffffffffff92869592869560207ffab312c5020dc7093e590463878dbfd0567314a7c155b164a60430ebcc7b3803990152604086015260401b1697169516930390a473ffffffffffffffffffffffffffffffffffffffff811661050757005b600080808093813415610536575b73ffffffffffffffffffffffffffffffffffffffff34921690f11561040357005b506108fc610515565b90919867ffffffffffffffff6105548b610f03565b16815260208a01359060078210156105855760408161057a600194602084950190610fbe565b019a0192019061048d565b600080fd5b60046040517fcc586b45000000000000000000000000000000000000000000000000000000008152fd5b507fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff84169055610475565b604051610613916105ef82610dfa565b73ffffffffffffffffffffffffffffffffffffffff8916825260208201528b613019565b8a6102e4565b909980518061072b575b50602081015180610639575b50604091506102dc565b73ffffffffffffffffffffffffffffffffffffffff604051937f23b872dd00000000000000000000000000000000000000000000000000000000855216600484015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660248401526044830152602082606481600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af1918215610403576040921561062f576107249060203d6020116103fc576103ed8183610e92565b508c61062f565b604051907f23b872dd00000000000000000000000000000000000000000000000000000000825273ffffffffffffffffffffffffffffffffffffffff841660048301523060248301526044820152602081606481600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af180156104035715610623576107dd9060203d6020116103fc576103ed8183610e92565b508c610623565b6044826107f88d6020815191015190610ffa565b604051917f78fe52a600000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b808d602080936040519261083e84610dfa565b60008452600083850152010152016101ac565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b839661013d565b60046040517fd5b25b63000000000000000000000000000000000000000000000000000000008152fd5b60046040517f6599c9aa000000000000000000000000000000000000000000000000000000008152fd5b60046040517f24f7f40f000000000000000000000000000000000000000000000000000000008152fd5b346105855760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105855761093c610d77565b60443567ffffffffffffffff81116105855761095c903690600401610d9a565b91610965610dcb565b9273ffffffffffffffffffffffffffffffffffffffff809216928360005260209160048352604060002095610998611055565b509187549762ffffff94858a60c01c168015908115610bc4575b50610b9a57836109c76109d392853691610f18565b6024358c60401b6111b5565b7fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008316988915610b6c575085820361058a57610a5b9260401c7fffffffffffffffff0000000000000000000000000000000000000000000000008254161790555b7f000000000000000000000000000000000000000000000000000000000000000090610f9e565b9533600052600384526040600020610a74888254610fb1565b90556040517fa9059cbb0000000000000000000000000000000000000000000000000000000081527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16600482015260248101889052948490869060449082906000907f0000000000000000000000000000000000000000000000000000000000000000165af1938415610403577f6337d70daadadd11f8be7f6e7b38e6c04d28710b1f2a2894bb14d8e3eaa8cdb695604095610b4f575b5084519788528701521693a3005b610b6590823d84116103fc576103ed8183610e92565b5088610b41565b610a5b93507fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff169055610a34565b60046040517f175868d7000000000000000000000000000000000000000000000000000000008152fd5b9050868616148b6109b2565b346105855760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105855733600052602060048152604060002090610c17611055565b5091805462ffffff808260c01c169485156108b15716809414610b9a577fffffffffff000000ffffffffffffffffffffffffffffffffffffffffffffffff1690553360009081526003825260408082208054929055517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166004820152602481018290529091808280604481010381600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af191821561040357600092610d5a575b506040519283528201527f6337d70daadadd11f8be7f6e7b38e6c04d28710b1f2a2894bb14d8e3eaa8cdb660403392a3005b610d7090823d84116103fc576103ed8183610e92565b5084610d28565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361058557565b9181601f840112156105855782359167ffffffffffffffff8311610585576020808501948460061b01011161058557565b606435907fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008216820361058557565b6040810190811067ffffffffffffffff821117610e1657604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b610120810190811067ffffffffffffffff821117610e1657604052565b60a0810190811067ffffffffffffffff821117610e1657604052565b67ffffffffffffffff8111610e1657604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610e1657604052565b90816020910312610585575180151581036105855790565b67ffffffffffffffff8111610e165760051b60200190565b359067ffffffffffffffff8216820361058557565b929192610f2482610eeb565b604092610f346040519283610e92565b819581835260208093019160061b84019381851161058557915b848310610f5d57505050505050565b858383031261058557855190610f7282610dfa565b610f7b84610f03565b82528484013590600782101561058557828692838a950152815201920191610f4e565b8181029291811591840414171561085157565b9190820391821161085157565b906007821015610fcb5752565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9190820180921161085157565b8115611011570490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b62ffffff918216908216039190821161085157565b7f0000000000000000000000000000000000000000000000000000000000000000906110a17f000000000000000000000000000000000000000000000000000000000000000083610ffa565b916110aa611336565b7f0000000000000000000000000000000000000000000000000000000000000000808210611136576110db91610fb1565b6110e58482611007565b90600282018092116108515762ffffff809216947ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe86019083821161085157611132936102af9216610f9e565b1090565b60046040517f3a5f7b57000000000000000000000000000000000000000000000000000000008152fd5b90815180825260208080930193019160005b828110611180575050505090565b909192938260406001926111a983895167ffffffffffffffff8151168452015184830190610fbe565b01950193929101611172565b927fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000009283929183168015611272576112099161123b9160405193849260208401968752606060408501526080840190611160565b906060830152037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282610e92565b5190201691160361124857565b60046040517fd13415b5000000000000000000000000000000000000000000000000000000008152fd5b5061123b61129791604051928391602083019586526040808401526060830190611160565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282610e92565b604051906060820182811067ffffffffffffffff821117610e165760405260006040838281528260208201520152565b80518210156113075760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001680156113e5576020600491604051928380927fb80777ea0000000000000000000000000000000000000000000000000000000082525afa908115610403576000916113b6575090565b90506020813d6020116113dd575b816113d160209383610e92565b81010312610585575190565b3d91506113c4565b504290565b9060ff8091169116019060ff821161085157565b6007821015610fcb5752565b9093929192825190600060a05260a0515060405161142781610e45565b60a051815260a051602082015260a051604082015260a051606082015260a051608082015260a05160a082015260a05160c082015260a05160e082015261010060a05191015267ffffffffffffffff60a051921660a0515260a051602052604060a05120916040519261149984610e45565b5462ffffff8116845262ffffff8160181c16602085015262ffffff8160301c1660408501526114d160ff8260481c16606086016113fe565b60ff8160501c1660808501528060581c60a0510b60a085015260ff8160601c1660c085015260ff8160681c1660e085015260ff8160701c166101008501528662ffffff8551169160018310158061300a575b612fcc575b505060a084015160a0510b61154860a0519160ff60c088015116906133d2565b60a0510b13612fa3575b5060ff60e084015116608052612f76575b60208401516007811015611e1057612ea65760ff60808301511660ff7f00000000000000000000000000000000000000000000000000000000000000001614801590612e4e575b612e3e576116026040516115bd81610dfa565b73ffffffffffffffffffffffffffffffffffffffff881681527f0000000000000000000000000000000000000000000000000000000000000000602082015284613019565b67ffffffffffffffff8451166060830151906007821015611e105760208601516007811015611e10576116469061163c6040518095610fbe565b6020840190610fbe565b7f17b85ded3fb12432ee427abc34a3026e1fbbb8bc431e3dbe51bc81215655c25c604073ffffffffffffffffffffffffffffffffffffffff8a1693a360a0516060830151926007841015611e105760ff610100820151169580519760208201519860078a1015611e10576040519687608081011067ffffffffffffffff60808a011117612e0d576080880160405260803689376116e16112c3565b9a6116f463ffffffff841660030b613490565b67ffffffff0000000061171263ffffffff8660201c1660030b6134c5565b60201b1667ffffffffffffffff63ffffffff8316820111612353578d6117b86117a761ffff61178c60405161174681610e62565b67ffffffffffffffff63ffffffff8916880116815262ffffff8c1660208201526002604082015261177a8a606083016113fe565b61178789608083016113fe565b613554565b60a05191939184810b12612dfa575b82604087015116613442565b166040840152825160a0510b613458565b60a0510b905260018060805160041c1614612db9575b50506117e263ffffffff841660030b6134c5565b67ffffffff0000000061180063ffffffff8660201c1660030b613490565b60201b1667ffffffffffffffff63ffffffff8316820111612353578d6118826117a761ffff61186860405161183481610e62565b67ffffffffffffffff63ffffffff8916880116815262ffffff8c1660208201526003604082015261177a8a606083016113fe565b60a05191939184810b12612da65782604087015116613442565b60a0510b905260028060805160041c1614612d62575b50506118ac63ffffffff841660030b613490565b67ffffffff000000006118ca63ffffffff8660201c1660030b61351c565b60201b1667ffffffffffffffff63ffffffff8316820111612353578d61194d6117a761ffff6119336040516118fe81610e62565b67ffffffffffffffff63ffffffff8916880116815262ffffff8c16602082015260a051604082015261177a8a606083016113fe565b60a05191939184810b12612d4f5782604087015116613442565b60a0510b9052600480608051811c1614612d0b575b505067ffffffff0000000061199063ffffffff61198381871660030b61351c565b9560201c1660030b613490565b60201b1667ffffffffffffffff63ffffffff851682011161235357611a23604061ffff8f948897611787611a0a92611a01611a349a62ffffff67ffffffffffffffff889b63ffffffff8b51986119e58a610e62565b1601169d8e8752166020860152600188860152606085016113fe565b608083016113fe565b92909560a0518760a0510b12612cf8575b015116613442565b1660408d01528b5160a0510b613458565b60a0510b8a5260088060805160041c1614612cc7575b50885160a0510b9961ffff604060ff60208d0151169b01511680612c29575b5060a0515b60ff81166004811015611b325760ff91818c8b73ffffffffffffffffffffffffffffffffffffffff611aa260019683613431565b5116611ab3575b5050500116611a6e565b73ffffffffffffffffffffffffffffffffffffffff611ad8611b2a94611b1093613431565b511691611b0a600f608051167f0000000000000000000000000000000000000000000000000000000000000000611007565b90610f9e565b60405191611b1d83610dfa565b825260208201528c613019565b388c8b611aa9565b5050949993989297509450945060208501516007811015611e1057611b5a90606088016113fe565b60a05160e087015273ffffffffffffffffffffffffffffffffffffffff831673ffffffffffffffffffffffffffffffffffffffff611bc467ffffffffffffffff885116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b161480612c19575b15612c09575b60608601516007811015611e1057611f6557505062ffffff80611c0560a087015160a0510b60ff60c089015116906133d2565b9381875116900316816040870151160116604085015260a051608085015260a05161010085015260a051845260a05160a085015260a05160c0850152611c7767ffffffffffffffff845116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b9167ffffffffffffffff845116806040519473ffffffffffffffffffffffffffffffffffffffff60a05191167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60a05160a051a460a05152600160205260a051604060a051205560a0519060a0510b13611e41575b505067ffffffffffffffff905b511660a0515260a051602052604060a051209062ffffff8151169082549165ffffff000000602083015160181b169068ffffff000000000000604084015160301b166060840151926007841015611e1057849369ff0000000000000000006bff00000000000000000000009386959386947fffffffffffffffffffffffffffffffffff0000000000000000000000000000006eff00000000000000000000000000006101006dff0000000000000000000000000060e06cff00000000000000000000000060c060a06aff0000000000000000000060808f015160501b169d015160581b9e015160601b169d015160681b169c015160701b169b161717179160481b16171791161717171790559060a0519060a05190565b7f4e487b710000000000000000000000000000000000000000000000000000000060a051526021600452602460a051fd5b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52577fabe7f1ab00000000000000000000000000000000000000000000000000000000825260a05173ffffffffffffffffffffffffffffffffffffffff90911660048301527f00000000000000000000000000000000000000000000000000000000000000006024830152818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857611f3c575b80611cec565b611f4590610e7e565b60a051611f525738611f36565b60a05180fd5b6040513d60a051823e3d90fd5b9193929095507f000000000000000000000000000000000000000000000000000000000000000095611fa760a087015160a0510b60ff60c089015116906133d2565b9060ff6080880151169360c088015260608701516007811015611e105760061480612bf9575b15612be45760ff6001816101008a01511601168061010089015215612bd7575b60a08701526002608087015262ffffff8216865261203767ffffffffffffffff855116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b9461205260a088015160a0510b60ff60c08a015116906133d2565b9260608801516007811015611e105760060361294e57505073ffffffffffffffffffffffffffffffffffffffff8581161461283f5773ffffffffffffffffffffffffffffffffffffffff8516612219575060a05190810b13905061212c575b73ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff925b8184845116928392167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60a05160a051a460a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a0512055611cf9565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff600482015284602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857612203575b506120b1565b61220c90610e7e565b60a051611f5257386121fd565b60a05190810b139081158080612832575b156123845750505050838060011b04600214841517156123535773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff60048201528460011b602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f585761233d575b5073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff926120d1565b61234690610e7e565b60a051611f525738612318565b7f4e487b710000000000000000000000000000000000000000000000000000000060a051526011600452602460a051fd5b8280612824575b15612490575050505073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517fabe7f1ab00000000000000000000000000000000000000000000000000000000815260a05173ffffffffffffffffffffffffffffffffffffffff8416600483015260248201869052818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f585761233d575073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff926120d1565b80612816575b156124c3575b50505073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff926120d1565b81612807575b506124d6575b808061249c565b156126ed5773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517fabe7f1ab00000000000000000000000000000000000000000000000000000000815260a05173ffffffffffffffffffffffffffffffffffffffff8416600483015260248201869052818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f58576126d7575b50838060011b04600214841517156123535773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff60048201528460011b602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f58576126c1575b5073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff925b92506124cf565b6126ca90610e7e565b60a051611f525738612699565b6126e090610e7e565b60a051611f5257386125b3565b838004600114841517156123535773ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff600482015284602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f58576127f1575b5073ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff926126ba565b6127fa90610e7e565b60a051611f5257386127cc565b60a05190810b139050386124c9565b5060a05181810b1315612496565b5060a05182810b131561238b565b5060a05182810b1361222a565b509192505060a0519060a0510b13612861575b67ffffffffffffffff90611cf9565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff600482015283602482015260a0518160448160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857612938575b50612852565b61294190610e7e565b60a051611f525738612932565b90955062ffffff919293501662ffffff60208701511614159081612bc8575b50612adb575b60a05190810b136129e7575b73ffffffffffffffffffffffffffffffffffffffff67ffffffffffffffff92838351168083831660a0517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60a05160a051a460a05152600160205216604060a0512055611cf9565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815260a05173ffffffffffffffffffffffffffffffffffffffff8416600483015260248201869052818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857612ac5575b5061297f565b612ace90610e7e565b60a051611f525738612abf565b73ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15611f52576040517fabe7f1ab00000000000000000000000000000000000000000000000000000000815260a05173ffffffffffffffffffffffffffffffffffffffff8516600483015260248201879052818060448101038160a05173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015611f5857612bb9575b50612973565b612bc290610e7e565b38612bb3565b60a05190810b1390503861296d565b60ff610100880152611fed565b600161010088015260a0516040880152611fed565b5060ff6080880151161515611fcd565b62ffffff84166020870152611bd2565b5060ff6080870151161515611bcc565b612cc190600c612ca673ffffffffffffffffffffffffffffffffffffffff612c7d67ffffffffffffffff895116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b16927f000000000000000000000000000000000000000000000000000000000000000090610f9e565b0460405191612cb483610dfa565b8252602082015289613019565b38611a69565b60a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a051205416606087015238611a4a565b60208101600860ff825116179052611a1b565b63ffffffff67ffffffffffffffff9216011660a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a05120541660408a01523880611962565b60208601600460ff82511617905261179b565b63ffffffff67ffffffffffffffff9216011660a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a05120541660208a01523880611898565b60208601600260ff82511617905261179b565b63ffffffff67ffffffffffffffff9216011660a05152600160205273ffffffffffffffffffffffffffffffffffffffff604060a051205416895238806117ce565b60208601600160ff82511617905261179b565b7f4e487b710000000000000000000000000000000000000000000000000000000060a051526041600452602460a051fd5b60a0519550859450849350915050565b50612e8567ffffffffffffffff855116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b73ffffffffffffffffffffffffffffffffffffffff808816911614156115aa565b62ffffff60208301511662ffffff861614612ec1575b611602565b608082015160ff168015612edc575060066020850152611602565b60ff7f00000000000000000000000000000000000000000000000000000000000000001614801590612f1e575b15612ebc5760a0519550859450849350915050565b50612f5567ffffffffffffffff855116600052600160205273ffffffffffffffffffffffffffffffffffffffff6040600020541690565b73ffffffffffffffffffffffffffffffffffffffff80881691161415612f09565b612f9660c083015160f0612f8c60ff8316613151565b9160041b166113ea565b60805260a0518252611563565b612fc0612fb462ffffff9289611040565b826040870151166130f5565b16604084015238611552565b60ff929350908183612ff19360501c1690848160581c60a0510b9160601c168661320e565b501680608085015262ffffff8716845215908638611528565b5060ff8160501c161515611523565b60005b6020808301518210156130815773ffffffffffffffffffffffffffffffffffffffff8061304a8486516112f3565b515116908551161461305f575060010161301c565b90613073908261307d9495015194516112f3565b5101918251610ffa565b9052565b505060206130c28173ffffffffffffffffffffffffffffffffffffffff855116948451956130b4838701978851906112f3565b5152015192518451906112f3565b51015280517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610851576001019052565b91909162ffffff8080941691160191821161085157565b60ff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9116019060ff821161085157565b9060ff8091169116039060ff821161085157565b6000906000905b60ff90818116156131ae578061316e839261310c565b1692169081146131815760010190613158565b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b5050919050565b60000b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8081146108515760000390565b9060ff169081156110115760ff160490565b9060ff8091169116029060ff821691820361085157565b939194926000958562ffffff9360018583161015806133c6575b613235575b505050505050565b919395965091939650846132498389611040565b169283156133b8579061325b916133d2565b938460000b6000811360001461330857505050906132d46132ba60ff6132da94816132c47f0000000000000000000000000000000000000000000000000000000000000000986132bf6132ae898c61313d565b918416968780936113ea565b61310c565b6131e5565b16808211613300575b50166131f7565b906113ea565b9060ff811660ff8316116132f8575b5091905b38808080808061322d565b9050386132e9565b9050386132cd565b600090979193969597949294126000146133ab57506132ba613329876131b5565b61334d61333c60ff9384938416866113ea565b6133458a6131b5565b8316906131e5565b168087116133a1575b5061337261336861338c9697986131b5565b82168289166131f7565b9082811690821611156133925750506000945b16906130f5565b906132ed565b61339b9161313d565b94613385565b9550613372613356565b90955093506132ed915050565b5050945050905091906132ed565b5060ff84161515613228565b909190600090810b131561340a576001915b600083810b1290816133fe575b506133f857565b60019150565b60ff91501615386133f1565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff916133e4565b9060048110156113075760051b0190565b91909161ffff8080941691160191821161085157565b9060000b9060000b01907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808212607f83131761085157565b60030b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffff800000008212637fffffff83131761085157565b60030b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190637fffffff82137fffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000000083121761085157565b60030b60010190637fffffff82137fffffffffffffffffffffffffffffffffffffffffffffffffffffffff8000000083121761085157565b6000916000809267ffffffffffffffff815116825281602052604082206040519061357e82610e45565b549262ffffff908185168352818560181c166020840152818560301c16604084015260ff9460608401956135b7818360481c16886113fe565b6080850192818360501c16845260a08601928060581c820b84528260c0880191818160601c168352818160681c1660e08a015260701c1661010088015285875116985160078110156136bc57829080151590816136e9575b5060018b101591826136ae575b505061362e575b505050505050505050565b909184819495969798999a9b5051168015158061369f575b15613687575091613670959391816136779a969451169251900b925116926020880151169361320e565b5091613771565b905b388080808080808080613623565b97955050505050506136999350613771565b90613679565b508660208a0151168a10613646565b9091506136bc57388061361c565b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b91509c50608089015160078110156137325783910361370c5760015b9c3861360f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff613705565b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b60ff1660ff8111610851576001901b90565b9291600093600091828360ff608087015116151580613fe8575b613fc6575b60e086015190600f60408601926137aa60ff85511661375f565b9060041c16166137bd60ff84511661375f565b14613f29575b60ff6137dc60a0890151830b8260c08b015116906133d2565b9251169060608601516007811015613efc57608087015160078110156136bc57908189959493928203613cbd575b5050505067ffffffffffffffff8551169262ffffff602087015116938152600160205273ffffffffffffffffffffffffffffffffffffffff6040822054169081151580613cb1575b6139db575b5050918160ff9367ffffffffffffffff9695930b136139ae575b86521660808501525116815280602052604081209162ffffff8151169183549265ffffff000000602084015160181b1668ffffff000000000000604085015160301b169160608501519360078510156139815750849369ff00000000000000000085946bff00000000000000000000009486947fffffffffffffffffffffffffffffffffff0000000000000000000000000000006eff00000000000000000000000000006101006dff0000000000000000000000000060e06cff00000000000000000000000060c060a06aff0000000000000000000060808f015160501b169d015160581b9e015160601b169d015160681b169c015160701b169b161717179160481b1617179116171717179055565b807f4e487b7100000000000000000000000000000000000000000000000000000000602492526021600452fd5b6139be62ffffff88511682611040565b62ffffff6139d360408a0192828451166130f5565b169052613871565b909192506139f760a0890151820b60ff60c08b015116906133d2565b8184810b13808091613ca5575b15613b6257505050613a3e60ff610100890151167f0000000000000000000000000000000000000000000000000000000000000000610f9e565b9073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000163b15613b5e576040517fabe7f1ab00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff909116600482015260248101919091528581806044810103818373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000165af18015613b535790869291613b37575b509167ffffffffffffffff94939160ff935b91938193959650613857565b613b4390929192610e7e565b613b4f57849038613b19565b8480fd5b6040513d88823e3d90fd5b8680fd5b91809392989796959498159182613c99575b5050613b92575b50509060ff918467ffffffffffffffff9596613b2b565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016613bfb60ff6101008b0151167f0000000000000000000000000000000000000000000000000000000000000000610f9e565b91813b15613c95576040517ff5d82b6b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff919091166004820152602481019290925282908290604490829084905af18015613c8a5715613b7b5767ffffffffffffffff955090613c8060ff949392610e7e565b9481929350613b7b565b6040513d84823e3d90fd5b8380fd5b810b1390508238613b74565b508282810b1315613a04565b5060ff86161515613852565b8091929394955015600014613dc3575060608901516007811015613d9657889493929103613d07575050613cf660a0880151840b613ff3565b830b60a08801525b3880808061380a565b90919250600160a0890151850b820b01907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808212607f831317613d69575086929160ff91850b60a08a015281600160c08b0151921b18161660c0880152613cfe565b807f4e487b7100000000000000000000000000000000000000000000000000000000602492526011600452fd5b6024867f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b60608a9493940180516007811015613d96578303613e595750505060ff60018160c08b015116921b161760c08801527ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe60a0880151840b820b0190607f82137fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80831217613d695750820b60a08701528490613cfe565b9591959392935160078110156137325789959493929103613ebd5750908160ff929515600014613eb357613e9560015b60a08c0151830b613458565b900b60a08a015281600160c08b0151921b18161660c0880152613cfe565b613e956002613e89565b9415613ecb575b5050613cfe565b613eda60a08a0151820b613ff3565b900b60a089015260ff60018160c08b015116921b161760c08801523880613ec4565b6024827f4e487b710000000000000000000000000000000000000000000000000000000081526021600452fd5b9750600c60ff610100880151160260ff8116908103613f9957613f5660ff91600f60e08a015116906131e5565b169760e087015160041c60ff8351169060ff82116131815760ff9160f0613f8e926001600f60e08e015116931b191660041b166113ea565b1660e08801526137c3565b6024897f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b60ff613fdd60c088015160f0612f8c848316613151565b1660e0870152613790565b5060ff83161561378b565b60000b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808212607f8313176108515756fea2646970667358221220238855f28e6a7b2f9f80204df33e36772d1b0a2e8cb65b0ab95e6a3b6662964f64736f6c63430008180033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "errors": {
      "ReserveTooLow(uint256,uint256)": [
        {
          "params": {
            "expected": "amount required to proceed",
            "inReserve": "amount in reserver as the time of the call"
          }
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "params": {
          "approved": "account who can know transfer on the owner's behalf",
          "owner": "current owner of the token",
          "tokenID": "id of the token being approved"
        }
      },
      "ApprovalForAll(address,address,bool)": {
        "params": {
          "approved": "whether it is approved or not",
          "operator": "account who can know transfer on the owner's behalf",
          "owner": "the account granting rights over all of its token"
        }
      },
      "CommitmentCancelled(address,uint24)": {
        "params": {
          "epoch": "epoch number on which this commit belongs to",
          "player": "account taking the staking risk (can be a different account than the one controlling the gems)"
        }
      },
      "CommitmentMade(address,uint24,bytes24)": {
        "params": {
          "commitmentHash": "the hash of moves",
          "epoch": "epoch number on which this commit belongs to",
          "player": "account taking the staking risk (can be a different account than the one controlling the gems)"
        }
      },
      "CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)": {
        "params": {
          "commitmentHash": "the hash of the moves",
          "epoch": "epoch number on which this commit belongs to",
          "furtherMoves": "hash of further moves, unless bytes32(0) which indicate end.",
          "moves": "the moves",
          "newReserveAmount": "new amount in reserve as a result",
          "player": "account who commited"
        }
      },
      "CommitmentVoid(address,uint24,uint256,bytes24)": {
        "params": {
          "amountBurnt": "amount of token to burn",
          "epoch": "epoch number on which this commit belongs to",
          "furtherMoves": "hash of further moves, unless bytes32(0) which indicate end.",
          "player": "the account that made the commitment"
        }
      },
      "MoveProcessed(uint64,address,uint8,uint8)": {
        "params": {
          "newColor": "color that takes over",
          "oldColor": "previous color of the cell",
          "player": "account making the move",
          "position": "cell at which the move take place"
        }
      },
      "MultiPoke(uint24,uint64[])": {
        "params": {
          "epoch": "epoch number at which the poke take place",
          "positions": "cells to poke"
        }
      },
      "ReserveDeposited(address,uint256,uint256)": {
        "params": {
          "amountDeposited": "the number of tokens deposited",
          "newAmount": "the number of tokens in reserver as a result",
          "player": "account receiving the token in the reserve"
        }
      },
      "ReserveWithdrawn(address,uint256,uint256)": {
        "params": {
          "amountWithdrawn": "the number of tokens withdrawnn",
          "newAmount": "the number of tokens in reserver as a result",
          "player": "account withdrawing the tokens"
        }
      },
      "SinglePoke(uint24,uint64)": {
        "params": {
          "epoch": "epoch number at which the poke take place",
          "position": "cell to poke"
        }
      },
      "Transfer(address,address,uint256)": {
        "params": {
          "from": "the account the token is sent from",
          "to": "the account the token is sent to",
          "tokenID": "id of the token being sent"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)": {
        "params": {
          "furtherMoves": "if moves cannot be contained in one tx, further moves are represented by a hash to reveal too",
          "moves": "the actual moves",
          "player": "the account who committed the move",
          "secret": "the secret used to make the commit"
        }
      },
      "reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)": {
        "params": {
          "furtherMoves": "if moves cannot be contained in one tx, further moves are represented by a hash to reveal too  Note that you have to that have enough moves (specified by MAX_NUM_MOVES_PER_HASH = 32)",
          "moves": "the actual moves",
          "payee": "address to send ETH to along the reveal",
          "player": "the account who committed the move",
          "secret": "the secret used to make the commit",
          "useReserve": "whether the tokens are taken from the reserve or from approvals.  This allow player to keep their reserve intact and use it on their next move.  Note that this require the Stratagems contract to have enough allowance."
        }
      }
    },
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "3301800",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)": "infinite",
        "acknowledgeMissedRevealByBurningAllReserve()": "infinite",
        "reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20WithIERC2612\",\"name\":\"tokens\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"burnAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revealPhaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"maxLife\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numTokensPerGems\",\"type\":\"uint256\"},{\"internalType\":\"contract ITime\",\"name\":\"time\",\"type\":\"address\"},{\"internalType\":\"contract IOnStakeChange\",\"name\":\"generator\",\"type\":\"address\"}],\"internalType\":\"struct UsingStratagemsTypes.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CanStillReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CommitmentHashNotMatching\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GameNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ImpossibleConfiguration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InCommitmentPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InRevealPhase\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFurtherMoves\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToReveal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PreviousCommitmentNotRevealed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"ReserveTooLow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"}],\"name\":\"CommitmentCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"}],\"name\":\"CommitmentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"bytes24\",\"name\":\"commitmentHash\",\"type\":\"bytes24\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"color\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct UsingStratagemsTypes.Move[]\",\"name\":\"moves\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveAmount\",\"type\":\"uint256\"}],\"name\":\"CommitmentRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"}],\"name\":\"CommitmentVoid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"oldColor\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"newColor\",\"type\":\"uint8\"}],\"name\":\"MoveProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"positions\",\"type\":\"uint64[]\"}],\"name\":\"MultiPoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ReserveDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"ReserveWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"epoch\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"}],\"name\":\"SinglePoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"color\",\"type\":\"uint8\"}],\"internalType\":\"struct UsingStratagemsTypes.Move[]\",\"name\":\"moves\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"}],\"name\":\"acknowledgeMissedReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acknowledgeMissedRevealByBurningAllReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"position\",\"type\":\"uint64\"},{\"internalType\":\"enum UsingStratagemsTypes.Color\",\"name\":\"color\",\"type\":\"uint8\"}],\"internalType\":\"struct UsingStratagemsTypes.Move[]\",\"name\":\"moves\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes24\",\"name\":\"furtherMoves\",\"type\":\"bytes24\"},{\"internalType\":\"bool\",\"name\":\"useReserve\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ReserveTooLow(uint256,uint256)\":[{\"params\":{\"expected\":\"amount required to proceed\",\"inReserve\":\"amount in reserver as the time of the call\"}}]},\"events\":{\"Approval(address,address,uint256)\":{\"params\":{\"approved\":\"account who can know transfer on the owner's behalf\",\"owner\":\"current owner of the token\",\"tokenID\":\"id of the token being approved\"}},\"ApprovalForAll(address,address,bool)\":{\"params\":{\"approved\":\"whether it is approved or not\",\"operator\":\"account who can know transfer on the owner's behalf\",\"owner\":\"the account granting rights over all of its token\"}},\"CommitmentCancelled(address,uint24)\":{\"params\":{\"epoch\":\"epoch number on which this commit belongs to\",\"player\":\"account taking the staking risk (can be a different account than the one controlling the gems)\"}},\"CommitmentMade(address,uint24,bytes24)\":{\"params\":{\"commitmentHash\":\"the hash of moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"player\":\"account taking the staking risk (can be a different account than the one controlling the gems)\"}},\"CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)\":{\"params\":{\"commitmentHash\":\"the hash of the moves\",\"epoch\":\"epoch number on which this commit belongs to\",\"furtherMoves\":\"hash of further moves, unless bytes32(0) which indicate end.\",\"moves\":\"the moves\",\"newReserveAmount\":\"new amount in reserve as a result\",\"player\":\"account who commited\"}},\"CommitmentVoid(address,uint24,uint256,bytes24)\":{\"params\":{\"amountBurnt\":\"amount of token to burn\",\"epoch\":\"epoch number on which this commit belongs to\",\"furtherMoves\":\"hash of further moves, unless bytes32(0) which indicate end.\",\"player\":\"the account that made the commitment\"}},\"MoveProcessed(uint64,address,uint8,uint8)\":{\"params\":{\"newColor\":\"color that takes over\",\"oldColor\":\"previous color of the cell\",\"player\":\"account making the move\",\"position\":\"cell at which the move take place\"}},\"MultiPoke(uint24,uint64[])\":{\"params\":{\"epoch\":\"epoch number at which the poke take place\",\"positions\":\"cells to poke\"}},\"ReserveDeposited(address,uint256,uint256)\":{\"params\":{\"amountDeposited\":\"the number of tokens deposited\",\"newAmount\":\"the number of tokens in reserver as a result\",\"player\":\"account receiving the token in the reserve\"}},\"ReserveWithdrawn(address,uint256,uint256)\":{\"params\":{\"amountWithdrawn\":\"the number of tokens withdrawnn\",\"newAmount\":\"the number of tokens in reserver as a result\",\"player\":\"account withdrawing the tokens\"}},\"SinglePoke(uint24,uint64)\":{\"params\":{\"epoch\":\"epoch number at which the poke take place\",\"position\":\"cell to poke\"}},\"Transfer(address,address,uint256)\":{\"params\":{\"from\":\"the account the token is sent from\",\"to\":\"the account the token is sent to\",\"tokenID\":\"id of the token being sent\"}}},\"kind\":\"dev\",\"methods\":{\"acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)\":{\"params\":{\"furtherMoves\":\"if moves cannot be contained in one tx, further moves are represented by a hash to reveal too\",\"moves\":\"the actual moves\",\"player\":\"the account who committed the move\",\"secret\":\"the secret used to make the commit\"}},\"reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)\":{\"params\":{\"furtherMoves\":\"if moves cannot be contained in one tx, further moves are represented by a hash to reveal too  Note that you have to that have enough moves (specified by MAX_NUM_MOVES_PER_HASH = 32)\",\"moves\":\"the actual moves\",\"payee\":\"address to send ETH to along the reveal\",\"player\":\"the account who committed the move\",\"secret\":\"the secret used to make the commit\",\"useReserve\":\"whether the tokens are taken from the reserve or from approvals.  This allow player to keep their reserve intact and use it on their next move.  Note that this require the Stratagems contract to have enough allowance.\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"CanStillReveal()\":[{\"notice\":\"Player have to reveal if they can Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal.\"}],\"CommitmentHashNotMatching()\":[{\"notice\":\"Player have to reveal their commitment using the exact same move values  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal.\"}],\"GameNotStarted()\":[{\"notice\":\"Game has not started yet, can't perform any action\"}],\"ImpossibleConfiguration()\":[{\"notice\":\"The cell configuration is invalid This can happen win debug mode where admin can setup cell bypassing moves rules For example when setting up neighborood configuration that would require a cell to have negative life\"}],\"InCommitmentPhase()\":[{\"notice\":\"When in Commit phase, player can make new commitment but they cannot reveal their move yet.\"}],\"InRevealPhase()\":[{\"notice\":\"When in Reveal phase, it is not possible to commit new moves or cancel previous commitment  During Reveal phase, players have to reveal their commitment, if not already done.\"}],\"InvalidEpoch()\":[{\"notice\":\"Player can only reveal their move in the same epoch they commited.abi  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`\"}],\"InvalidFurtherMoves()\":[{\"notice\":\"Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves  This result in a recursive series of hash that they can then submit in turn while revealing.  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block.\"}],\"NothingToReveal()\":[{\"notice\":\"Player can only reveal moves they commited.\"}],\"PreviousCommitmentNotRevealed()\":[{\"notice\":\"Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\\\  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\\\If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\\\\"}],\"ReserveTooLow(uint256,uint256)\":[{\"notice\":\"to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase.\"}]},\"events\":{\"Approval(address,address,uint256)\":{\"notice\":\"Triggered when a token is approved to be sent by another account  Note tat the approval get reset when a Transfer event for that same token is emitted.\"},\"ApprovalForAll(address,address,bool)\":{\"notice\":\"Triggered when an account approve or disaprove another to transfer on its behalf\"},\"CommitmentCancelled(address,uint24)\":{\"notice\":\"A player has cancelled its current commitment (before it reached the reveal phase)\"},\"CommitmentMade(address,uint24,bytes24)\":{\"notice\":\"A player has commited to make a move and reveal it on the reveal phase\"},\"CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)\":{\"notice\":\"Player has revealed its previous commitment\"},\"CommitmentVoid(address,uint24,uint256,bytes24)\":{\"notice\":\"A player has canceled a previous commitment by burning some tokens\"},\"MoveProcessed(uint64,address,uint8,uint8)\":{\"notice\":\"A move has been revealed.\"},\"MultiPoke(uint24,uint64[])\":{\"notice\":\"poke multiple cells and update them if needed\"},\"ReserveDeposited(address,uint256,uint256)\":{\"notice\":\"Player has deposited token in the reserve, allowing it to use that much in game\"},\"ReserveWithdrawn(address,uint256,uint256)\":{\"notice\":\"Player have withdrawn token from the reserve\"},\"SinglePoke(uint24,uint64)\":{\"notice\":\"poke cell and update it if needed\"},\"Transfer(address,address,uint256)\":{\"notice\":\"Triggered when a token is transferred\"}},\"kind\":\"user\",\"methods\":{\"acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)\":{\"notice\":\"called by player if they missed the reveal phase and want to minimze the token loss.  By providing the moves, they will be slashed only the amount of token required to make the moves\"},\"acknowledgeMissedRevealByBurningAllReserve()\":{\"notice\":\"should only be called as last resort this will burn all tokens in reserve If player has access to the secret, better call `acknowledgeMissedReveal`\"},\"reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)\":{\"notice\":\"called by player to reveal their moves  this is where the core logic of the game takes place  This is where the game board evolves  The game is designed so that reveal order does not matter\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/game/routes/StratagemsReveal.sol\":\"StratagemsReveal\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x55f102ea785d8399c0e58d1108e2d289506dde18abc6db1b7f68c1f9f9bc5792\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7e4076e175393767754387c962926577f1660dd9b810187b9002407656be72\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC165/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0bbdb7cf3d2c6acf95398c0ef54cb0e6ae8a3e6ce6f18fafeb0aa55cb74fb8fd\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/ERC2612/interfaces/IERC20WithIERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC20.sol\\\";\\nimport \\\"./IERC2612.sol\\\";\\n\\ninterface IERC20WithIERC2612 is IERC20, IERC2612 {}\\n\",\"keccak256\":\"0x66100d98de50a396d46feb17a2b2b400b13f033f5e01b45e95901e61a4feef05\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/ERC2612/interfaces/IERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingERC2612Errors.sol\\\";\\n\\ninterface IERC2612 {\\n    /// @notice allow `spender` to spend `value` amount of token on behalf of `owner`\\n    /// @param owner owner of the tokens\\n    /// @param spender address allowed to spend on behalf of the owner.\\n    /// @param value amount of token allowed to be spent\\n    /// @param deadline timestamp in seconds after which the permit is not valid.\\n    /// @param v signature part v\\n    /// @param r signature part r\\n    /// @param s signature part s\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /// @notice return the current nonce of the owner\\n    /// @param owner address queried\\n    /// @return nonce nonce value\\n    function nonces(address owner) external view returns (uint256 nonce);\\n\\n    /// @notice EIP-712 Domain separator hash\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x34dfefe126ef9115359eeaf4884977436dc639b991efcf490b386181cd664c06\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/ERC2612/interfaces/UsingERC2612Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC2612Errors {\\n    /// @notice The signature do not match the expected signer\\n    error InvalidSignature();\\n\\n    /// @notice The permit has expired\\n    /// @param currentTime time at which the error happen\\n    /// @param deadline the deadline\\n    error DeadlineOver(uint256 currentTime, uint256 deadline);\\n}\\n\",\"keccak256\":\"0x5d125f2509e60059af45358f0ca405e21f647b2e61502288fdc6d23aded256f6\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingERC20Events.sol\\\";\\n\\ninterface IERC20 is UsingERC20Events {\\n    /// @notice Returns the total token supply.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals the token uses.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the account balance of another account with address `owner`.\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /// @notice Transfers `amount` of tokens to address `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Allows `spender` to withdraw from your account multiple times, up to `amount`.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from address `from` to address `to`.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x3a6bcd5cf1d9e50fbe405f4c6c9c868e97ce2a84ae99fd7c1fb2d916c4d5debd\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC20/interfaces/UsingERC20Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC20Events {\\n    /// @notice trigger when tokens are transferred, including zero value transfers.\\n    /// @param from the account the tokens are sent from\\n    /// @param to the account the tokens are sent to\\n    /// @param value number of tokens sent\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice trigger on approval amount being set.\\n    ///   Note that Transfer events need to be considered to compute the current allowance.\\n    /// @param owner the account approving the `spender`\\n    /// @param spender the account allowed to spend\\n    /// @param value the amount granted\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x15eaa1de7fe9e02ba9e83f262b2b7f33a4bfe0f5a3ae2be4d616b6c4dce1c6fa\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"./UsingERC721Events.sol\\\";\\n\\ninterface IERC721Supply {\\n    /// @notice return the total number of token in existence\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IERC721 is IERC165, UsingERC721Events {\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return balance The number of tokens owned by the address.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Get the owner of a token.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 tokenID) external view returns (address owner);\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes calldata data) external;\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function safeTransferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function transferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param tokenID The id of the token.\\n    function approve(address operator, uint256 tokenID) external;\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param tokenID The id of the token.\\n    /// @return operator The address of the operator.\\n    function getApproved(uint256 tokenID) external view returns (address operator);\\n\\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa2a5afc2f4e761179de9c718ee807e2d682ed4ae39884906ac333c20282a95d1\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface IERC721Metadata is IERC721 {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory name);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory symbol);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `tokenID` is not a valid NFT. URIs are defined in RFC\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    ///  Metadata JSON Schema\\\".\\n    /// @param tokenID id of the token being queried.\\n    function tokenURI(uint256 tokenID) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x8a4ff84c39ad5c6bbf3e5486d3687bc1e15b96835ede5761f1922cf7a72f3354\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC721Events {\\n    /// @notice Triggered when a token is transferred\\n    /// @param from the account the token is sent from\\n    /// @param to the account the token is sent to\\n    /// @param tokenID id of the token being sent\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when a token is approved to be sent by another account\\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\\n    /// @param owner current owner of the token\\n    /// @param approved account who can know transfer on the owner's behalf\\n    /// @param tokenID id of the token being approved\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\\n    /// @param owner the account granting rights over all of its token\\n    /// @param operator account who can know transfer on the owner's behalf\\n    /// @param approved whether it is approved or not\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\",\"keccak256\":\"0x1b0d4ae18443a686be830d3a6ce203d563fe2f42ac9cc3fdf722b702d18152a2\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/debug/time/interfaces/ITime.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./UsingTimeEvents.sol\\\";\\n\\ninterface ITime is UsingTimeEvents {\\n    function timestamp() external view returns (uint256);\\n}\\n\\ninterface ITimeSetter is UsingTimeEvents {\\n    function increaseTime(uint256 delta) external;\\n}\\n\",\"keccak256\":\"0xa81ea4359b841652e020f83fded0488b2df8409ebaaf2c39362f2ef4bdb454e9\",\"license\":\"MIT\"},\"solidity-kit/solc_0_8/debug/time/interfaces/UsingTimeEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingTimeEvents {\\n    event TimeIncreased(uint256 newTime, uint256 delta);\\n}\\n\",\"keccak256\":\"0x73ca9f6cce68bd84d1d487bb3e7bbe4224ab413bc4007ff4a22e0abb04897de4\",\"license\":\"MIT\"},\"src/game/interface/IStratagems.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721Metadata.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"./UsingStratagemsTypes.sol\\\";\\nimport \\\"./UsingStratagemsEvents.sol\\\";\\n\\ninterface IStratagemsGetters is UsingStratagemsTypes, UsingStratagemsEvents {\\n    /// @notice return updated cell (based on current epoch)\\n    /// @param id the cell id\\n    function getCell(uint256 id) external view returns (FullCell memory cell);\\n\\n    /// @notice return the list of updated cells (based on current epoch) whose ids is given\\n    /// @param ids the list of cell ids\\n    function getCells(uint256[] memory ids) external view returns (FullCell[] memory cells);\\n\\n    /// @notice the number of token in reserve per account\\n    ///  This is used to slash player who do not reveal their moves\\n    ///  The amount can be greater than the number of token required for the next move\\n    ///  This allow player to potentially hide their intention.\\n    /// @param account the address to retrived the amount in reserve of.\\n    function getTokensInReserve(address account) external view returns (uint256 amount);\\n\\n    /// @notice The commitment to be revealed. zeroed if no commitment need to be made.\\n    /// @param account the address of which to retrieve the commitment\\n    function getCommitment(address account) external view returns (Commitment memory commitment);\\n\\n    /// @notice return the config used to initialise the Game\\n    function getConfig() external view returns (Config memory config);\\n}\\n\\ninterface IStratagemsCommit is UsingStratagemsTypes, UsingStratagemsEvents {\\n    /// @notice called by players to add tokens to their reserve\\n    /// @param tokensAmountToAdd amount of tokens to add\\n    /// @param permit permit EIP2612, .value = zero if not needed\\n    function addToReserve(uint256 tokensAmountToAdd, Permit calldata permit) external;\\n\\n    /// @notice called by players to commit their moves\\n    ///  this can be called multiple time in the same epoch, the last call overriding the previous.\\n    ///  When a commitment is made, it needs to be revealed in the reveal phase of the same epoch.abi\\n    ///  If missed, player can still reveal its moves but none of them will be resolved.\\n    ///   The player would lose its associated reserved amount.\\n    /// @param commitmentHash the hash of the moves\\n    /// @param payee address to send ETH to along the commitment. Can be used to pay for reveal\\n    function makeCommitment(bytes24 commitmentHash, address payable payee) external payable;\\n\\n    /// @notice called by players to cancel their current commitment\\n    ///  Can only be called during the commit phase in which the commitment was made\\n    ///  It cannot be called afterward\\n    function cancelCommitment() external;\\n\\n    /// @notice called to make a commitment along with tokens to add to the reserve\\n    /// @param commitmentHash the has of the moves\\n    /// @param tokensAmountToAdd amount of tokens to add to the reserve. the resulting total must be enough to cover the moves\\n    /// @param permit permit EIP2612, value = zero if not needed\\n    /// @param payee address to send ETH to along the commitment. Can be used to pay for reveal\\n    function makeCommitmentWithExtraReserve(\\n        bytes24 commitmentHash,\\n        uint256 tokensAmountToAdd,\\n        Permit calldata permit,\\n        address payable payee\\n    ) external payable;\\n\\n    /// @notice called by players to withdraw tokens from the reserve\\n    ///  can only be called if no commitments are pending\\n    ///  Note that while you can withdraw after commiting, note that if you do not have enough tokens\\n    ///  you'll have your commitment failing.\\n    /// @param amount number of tokens to withdraw\\n    function withdrawFromReserve(uint256 amount) external;\\n}\\n\\ninterface IStratagemsReveal is UsingStratagemsTypes, UsingStratagemsEvents {\\n    /// @notice called by player to reveal their moves\\n    ///  this is where the core logic of the game takes place\\n    ///  This is where the game board evolves\\n    ///  The game is designed so that reveal order does not matter\\n    /// @param player the account who committed the move\\n    /// @param secret the secret used to make the commit\\n    /// @param moves the actual moves\\n    /// @param furtherMoves if moves cannot be contained in one tx, further moves are represented by a hash to reveal too\\n    ///  Note that you have to that have enough moves (specified by MAX_NUM_MOVES_PER_HASH = 32)\\n    /// @param useReserve whether the tokens are taken from the reserve or from approvals.\\n    ///  This allow player to keep their reserve intact and use it on their next move.\\n    ///  Note that this require the Stratagems contract to have enough allowance.\\n    /// @param payee address to send ETH to along the reveal\\n    function reveal(\\n        address player,\\n        bytes32 secret,\\n        Move[] calldata moves,\\n        bytes24 furtherMoves,\\n        bool useReserve,\\n        address payable payee\\n    ) external payable;\\n\\n    /// @notice called by player if they missed the reveal phase and want to minimze the token loss.\\n    ///  By providing the moves, they will be slashed only the amount of token required to make the moves\\n    /// @param player the account who committed the move\\n    /// @param secret the secret used to make the commit\\n    /// @param moves the actual moves\\n    /// @param furtherMoves if moves cannot be contained in one tx, further moves are represented by a hash to reveal too\\n    function acknowledgeMissedReveal(\\n        address player,\\n        bytes32 secret,\\n        Move[] calldata moves,\\n        bytes24 furtherMoves\\n    ) external;\\n\\n    /// @notice should only be called as last resort\\n    /// this will burn all tokens in reserve\\n    /// If player has access to the secret, better call `acknowledgeMissedReveal`\\n    function acknowledgeMissedRevealByBurningAllReserve() external;\\n}\\n\\ninterface IStratagemsPoke is UsingStratagemsTypes, UsingStratagemsEvents {\\n    /// @notice poke a position, resolving its virtual state.\\n    //  If dead as a result, it will reward neighboor enemies colors\\n    /// @param position the cell position\\n    function poke(uint64 position) external;\\n\\n    /// @notice poke and collect the tokens won across multiple cells\\n    /// @param positions cell positions to collect from\\n    function pokeMultiple(uint64[] calldata positions) external;\\n}\\n\\ninterface IStratagems is\\n    IStratagemsCommit,\\n    IStratagemsReveal,\\n    IStratagemsPoke,\\n    IStratagemsGetters,\\n    IERC721,\\n    IERC721Metadata\\n{}\\n\",\"keccak256\":\"0x2cfbb31e69d4068aa83a82bed9b488295ac214315b2c3928a601c467f83c3d81\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsErrors.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsTypes.sol\\\";\\n\\ninterface UsingStratagemsErrors is UsingStratagemsTypes {\\n    /// @notice Game has not started yet, can't perform any action\\n    error GameNotStarted();\\n\\n    /// @notice When in Reveal phase, it is not possible to commit new moves or cancel previous commitment\\n    ///  During Reveal phase, players have to reveal their commitment, if not already done.\\n    error InRevealPhase();\\n\\n    /// @notice When in Commit phase, player can make new commitment but they cannot reveal their move yet.\\n    error InCommitmentPhase();\\n\\n    /// @notice Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\\\\\n    ///  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\\\\\n    /// @notice If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\\\\\n    error PreviousCommitmentNotRevealed();\\n\\n    /// @notice to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve\\n    ///  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase.\\n    /// @param inReserve amount in reserver as the time of the call\\n    /// @param expected amount required to proceed\\n    error ReserveTooLow(uint256 inReserve, uint256 expected);\\n\\n    /// @notice Player have to reveal their commitment using the exact same move values\\n    ///  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal.\\n    error CommitmentHashNotMatching();\\n\\n    /// @notice Player can only reveal moves they commited.\\n    error NothingToReveal();\\n\\n    /// @notice Player can only reveal their move in the same epoch they commited.abi\\n    ///  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`\\n    error InvalidEpoch();\\n\\n    /// @notice Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves\\n    ///  This result in a recursive series of hash that they can then submit in turn while revealing.\\n    ///  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block.\\n    error InvalidFurtherMoves();\\n\\n    /// @notice Player have to reveal if they can\\n    /// Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal.\\n    error CanStillReveal();\\n\\n    /// @notice The cell configuration is invalid\\n    /// This can happen win debug mode where admin can setup cell bypassing moves rules\\n    /// For example when setting up neighborood configuration that would require a cell to have negative life\\n    error ImpossibleConfiguration();\\n}\\n\",\"keccak256\":\"0xcaf7c446262b2232597af7ed62d040eea9b5c54fb3db20591b80ac96f341ad17\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsEvents.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsTypes.sol\\\";\\n\\ninterface UsingStratagemsEvents is UsingStratagemsTypes {\\n    /// @notice A player has commited to make a move and reveal it on the reveal phase\\n    /// @param player account taking the staking risk (can be a different account than the one controlling the gems)\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param commitmentHash the hash of moves\\n    event CommitmentMade(address indexed player, uint24 indexed epoch, bytes24 commitmentHash);\\n\\n    /// @notice A player has cancelled its current commitment (before it reached the reveal phase)\\n    /// @param player account taking the staking risk (can be a different account than the one controlling the gems)\\n    /// @param epoch epoch number on which this commit belongs to\\n    event CommitmentCancelled(address indexed player, uint24 indexed epoch);\\n\\n    /// @notice A player has canceled a previous commitment by burning some tokens\\n    /// @param player the account that made the commitment\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param amountBurnt amount of token to burn\\n    /// @param furtherMoves hash of further moves, unless bytes32(0) which indicate end.\\n    event CommitmentVoid(address indexed player, uint24 indexed epoch, uint256 amountBurnt, bytes24 furtherMoves);\\n\\n    /// @notice Player has revealed its previous commitment\\n    /// @param player account who commited\\n    /// @param epoch epoch number on which this commit belongs to\\n    /// @param commitmentHash the hash of the moves\\n    /// @param moves the moves\\n    /// @param furtherMoves hash of further moves, unless bytes32(0) which indicate end.\\n    /// @param newReserveAmount new amount in reserve as a result\\n    event CommitmentRevealed(\\n        address indexed player,\\n        uint24 indexed epoch,\\n        bytes24 indexed commitmentHash,\\n        Move[] moves,\\n        bytes24 furtherMoves,\\n        uint256 newReserveAmount\\n    );\\n\\n    /// @notice poke cell and update it if needed\\n    /// @param position cell to poke\\n    /// @param epoch epoch number at which the poke take place\\n    event SinglePoke(uint24 indexed epoch, uint64 position);\\n\\n    /// @notice poke multiple cells and update them if needed\\n    /// @param positions cells to poke\\n    /// @param epoch epoch number at which the poke take place\\n    event MultiPoke(uint24 indexed epoch, uint64[] positions);\\n\\n    /// @notice Player have withdrawn token from the reserve\\n    /// @param player account withdrawing the tokens\\n    /// @param amountWithdrawn the number of tokens withdrawnn\\n    /// @param newAmount the number of tokens in reserver as a result\\n    event ReserveWithdrawn(address indexed player, uint256 amountWithdrawn, uint256 newAmount);\\n\\n    /// @notice Player has deposited token in the reserve, allowing it to use that much in game\\n    /// @param player account receiving the token in the reserve\\n    /// @param amountDeposited the number of tokens deposited\\n    /// @param newAmount the number of tokens in reserver as a result\\n    event ReserveDeposited(address indexed player, uint256 amountDeposited, uint256 newAmount);\\n\\n    // --------------------------------------------------------------------------------------------\\n    // Event to make it easier to check what is happening\\n    // TODO get rid ?\\n    // --------------------------------------------------------------------------------------------\\n    /// @notice A move has been revealed.\\n    /// @param position cell at which the move take place\\n    /// @param player account making the move\\n    /// @param oldColor previous color of the cell\\n    /// @param newColor color that takes over\\n    event MoveProcessed(uint64 indexed position, address indexed player, Color oldColor, Color newColor);\\n}\\n\",\"keccak256\":\"0xb015b6b04349cd51c8d07426e29d1799be6b0a4aa4672da8156feb5e5a6614e4\",\"license\":\"AGPL-3.0\"},\"src/game/interface/UsingStratagemsTypes.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC20/ERC2612/interfaces/IERC20WithIERC2612.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/debug/time/interfaces/ITime.sol\\\";\\nimport \\\"../../token/interface/IOnStakeChange.sol\\\";\\n\\ninterface UsingStratagemsTypes {\\n    // --------------------------------------------------------------------------------------------\\n    // EXTERNAL TYPES\\n    // --------------------------------------------------------------------------------------------\\n\\n    /// @notice The set of possible color (None indicate the Cell is empty)\\n    enum Color {\\n        None,\\n        Blue,\\n        Red,\\n        Green,\\n        Yellow,\\n        Purple,\\n        Evil\\n    }\\n\\n    /// @notice Move struct that define position and color\\n    struct Move {\\n        uint64 position; // TODO make it bigger ? uint32 * uint32 is probably infinitely big enough\\n        Color color;\\n    }\\n\\n    /// @notice Permit struct to authorize EIP2612 ERC20 contracts\\n    struct Permit {\\n        uint256 value;\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @notice Config struct to configure the game instance\\n    struct Config {\\n        IERC20WithIERC2612 tokens;\\n        address payable burnAddress;\\n        uint256 startTime;\\n        uint256 commitPhaseDuration;\\n        uint256 revealPhaseDuration;\\n        uint8 maxLife;\\n        uint256 numTokensPerGems;\\n        ITime time;\\n        IOnStakeChange generator;\\n    }\\n\\n    /// @notice Cell struct representing the current state of a cell\\n    struct FullCell {\\n        address owner;\\n        uint24 lastEpochUpdate;\\n        uint24 epochWhenTokenIsAdded;\\n        uint24 producingEpochs;\\n        Color color;\\n        uint8 life;\\n        int8 delta;\\n        uint8 enemyMap;\\n        uint8 distribution;\\n        uint8 stake; // for Evil, else always 1\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // STORAGE TYPES\\n    // --------------------------------------------------------------------------------------------\\n\\n    struct Discovered {\\n        uint32 minX;\\n        uint32 maxX;\\n        uint32 minY;\\n        uint32 maxY;\\n    }\\n\\n    struct Cell {\\n        uint24 lastEpochUpdate;\\n        uint24 epochWhenTokenIsAdded;\\n        uint24 producingEpochs;\\n        Color color;\\n        uint8 life;\\n        int8 delta;\\n        uint8 enemyMap;\\n        uint8 distribution; // this encode who is left to be given reward (4 left most bits) and the reard (4 most right bits)\\n        uint8 stake; // for Evil, else always 1\\n    }\\n\\n    struct Commitment {\\n        bytes24 hash;\\n        uint24 epoch;\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // INTERNAL TYPES\\n    // --------------------------------------------------------------------------------------------\\n\\n    struct TokenTransfer {\\n        address payable to;\\n        uint256 amount;\\n    }\\n\\n    struct TokenTransferCollection {\\n        TokenTransfer[] transfers;\\n        uint256 numTransfers;\\n    }\\n\\n    struct MoveTokens {\\n        uint256 tokensPlaced;\\n        uint256 tokensBurnt;\\n        uint256 tokensReturned;\\n    }\\n\\n    struct DisplayData {\\n        string x;\\n        string y;\\n        string life;\\n        string delta;\\n        string creationEpoch;\\n        string factionName;\\n        string factionColor;\\n    }\\n}\\n\",\"keccak256\":\"0xfeb72ac403a20acbd460e4fa32b5bf71e11dd2fed8608a5211db0dfa1d73ed69\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsSetters.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsState.sol\\\";\\nimport \\\"../interface/UsingStratagemsEvents.sol\\\";\\nimport \\\"./UsingStratagemsUtils.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Events.sol\\\";\\n\\nabstract contract UsingStratagemsSetters is UsingStratagemsState, UsingStratagemsUtils, UsingERC721Events {\\n    using PositionUtils for uint64;\\n\\n    constructor(Config memory config) UsingStratagemsState(config) {}\\n\\n    function _makeCommitment(address player, bytes24 commitmentHash, uint256 inReserve) internal {\\n        Commitment storage commitment = _commitments[player];\\n\\n        (uint24 epoch, bool commiting) = _epoch();\\n\\n        if (!commiting) {\\n            revert InRevealPhase();\\n        }\\n        if (commitment.epoch != 0 && commitment.epoch != epoch) {\\n            revert PreviousCommitmentNotRevealed();\\n        }\\n\\n        commitment.hash = commitmentHash;\\n        commitment.epoch = epoch;\\n\\n        // for withdrawal, we still require a minimal reserve so player cannot change their mind without losing at least one token\\n        // TODO we might want to increase that value to 10x as 10 moves might quite common, at least on some networks\\n        // if (inReserve < NUM_TOKENS_PER_GEMS) {\\n        //     // TODO? special error for this case ?\\n        //     revert ReserveTooLow(inReserve, NUM_TOKENS_PER_GEMS);\\n        // }\\n\\n        emit CommitmentMade(player, epoch, commitmentHash);\\n    }\\n\\n    function _resolveMoves(\\n        address player,\\n        uint24 epoch,\\n        Move[] memory moves,\\n        address tokenGiver\\n    ) internal returns (uint256 newReserveAmount) {\\n        // max number of transfer is (4+1) * moves.length\\n        // (for each move's cell's neighbours potentially being a different account)\\n        // limiting the number of move per commitment reveal to 32 or, even more probably, should cover this unlikely scenario\\n        TokenTransferCollection memory transferCollection = TokenTransferCollection({\\n            transfers: new TokenTransfer[](moves.length * 5),\\n            numTransfers: 0\\n        });\\n        MoveTokens memory tokens;\\n        for (uint256 i = 0; i < moves.length; i++) {\\n            (uint256 placed, uint256 burnt, uint256 returned) = _computeMove(\\n                transferCollection,\\n                player,\\n                epoch,\\n                moves[i]\\n            );\\n\\n            tokens.tokensPlaced += placed;\\n            tokens.tokensBurnt += burnt;\\n            tokens.tokensReturned += returned;\\n        }\\n\\n        // logger.logTransfers(0, \\\"resolveMoves\\\", transferCollection);\\n\\n        newReserveAmount = _tokensInReserve[player];\\n\\n        // Note: even if funds can comes from outside the reserve, we still check it\\n        // This ensure player have to have a reserve and cannot escape the slash if not\\n        if (newReserveAmount < tokens.tokensPlaced + tokens.tokensBurnt) {\\n            // TODO add in the tokens.returned from Color.None move\\n            revert ReserveTooLow(newReserveAmount, tokens.tokensPlaced + tokens.tokensBurnt);\\n        }\\n        if (tokenGiver == address(0)) {\\n            newReserveAmount -= tokens.tokensPlaced + tokens.tokensBurnt;\\n            _tokensInReserve[player] = newReserveAmount;\\n        } else {\\n            if (tokens.tokensPlaced != 0) {\\n                TOKENS.transferFrom(tokenGiver, address(this), tokens.tokensPlaced);\\n            }\\n            if (tokens.tokensBurnt != 0) {\\n                TOKENS.transferFrom(tokenGiver, BURN_ADDRESS, tokens.tokensBurnt);\\n            }\\n        }\\n\\n        // TODO option to return in reserve ?\\n        if (tokens.tokensReturned != 0) {\\n            // console.log(\\\"tokensReturned\\\");\\n            // console.log(tokens.tokensReturned);\\n            _collectTransfer(transferCollection, TokenTransfer({to: payable(player), amount: tokens.tokensReturned}));\\n        }\\n\\n        _multiTransfer(TOKENS, transferCollection);\\n    }\\n\\n    function _countBits(uint8 n) internal pure returns (uint8 count) {\\n        while (n != 0) {\\n            n = n & (n - 1);\\n            count++;\\n        }\\n    }\\n\\n    function _placeColor(\\n        address player,\\n        Cell memory currentState,\\n        Move memory move,\\n        uint24 epoch,\\n        int8 newDelta,\\n        uint8 newEnemyMap\\n    ) internal {\\n        int8 oldEffectiveDelta = _effectiveDelta(currentState.delta, currentState.enemyMap);\\n        uint8 oldLife = currentState.life;\\n\\n        currentState.enemyMap = newEnemyMap;\\n\\n        if (currentState.color == Color.Evil && currentState.life != 0) {\\n            unchecked {\\n                currentState.stake += 1;\\n                if (currentState.stake == 0) {\\n                    // we cap it, losing stake there\\n                    // TODO reevaluate\\n                    // send it to special address ?\\n                    currentState.stake = 255;\\n                }\\n            }\\n        } else {\\n            currentState.stake = 1;\\n            currentState.producingEpochs = 0;\\n        }\\n\\n        currentState.delta = newDelta;\\n        currentState.life = 2;\\n        currentState.lastEpochUpdate = epoch;\\n\\n        address oldOwner = _ownerOf(move.position);\\n\\n        int8 newEffectiveDelta = _effectiveDelta(currentState.delta, currentState.enemyMap);\\n\\n        if (currentState.color == Color.Evil) {\\n            if (oldOwner != 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF) {\\n                if (oldOwner == address(0)) {\\n                    if (newEffectiveDelta > 0) {\\n                        GENERATOR.add(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, NUM_TOKENS_PER_GEMS);\\n                    }\\n                } else {\\n                    if (oldEffectiveDelta <= 0 && newEffectiveDelta > 0) {\\n                        GENERATOR.add(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, NUM_TOKENS_PER_GEMS * 2);\\n                    } else if (oldEffectiveDelta > 0 && newEffectiveDelta <= 0) {\\n                        GENERATOR.remove(oldOwner, NUM_TOKENS_PER_GEMS);\\n                    } else if (oldEffectiveDelta <= 0 && newEffectiveDelta <= 0) {} else if (\\n                        oldEffectiveDelta > 0 && newEffectiveDelta > 0\\n                    ) {\\n                        if (oldLife > 0) {\\n                            GENERATOR.remove(oldOwner, NUM_TOKENS_PER_GEMS);\\n                            GENERATOR.add(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, NUM_TOKENS_PER_GEMS * 2);\\n                        } else {\\n                            GENERATOR.add(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, NUM_TOKENS_PER_GEMS * 1);\\n                        }\\n                    }\\n                }\\n\\n                emit Transfer(oldOwner, 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, move.position);\\n                _owners[move.position] = uint256(uint160(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\\n            } else if (newEffectiveDelta > 0) {\\n                GENERATOR.add(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF, NUM_TOKENS_PER_GEMS);\\n            }\\n        } else {\\n            if (currentState.epochWhenTokenIsAdded != epoch && oldEffectiveDelta > 0) {\\n                // here we are dealing with a color replacement and so we need to consider points removal\\n                GENERATOR.remove(player, NUM_TOKENS_PER_GEMS);\\n            }\\n            if (newEffectiveDelta > 0) {\\n                GENERATOR.add(player, NUM_TOKENS_PER_GEMS);\\n            }\\n            emit Transfer(address(0), player, move.position);\\n            _owners[move.position] = uint256(uint160(player));\\n        }\\n    }\\n\\n    // Note on COLLISION\\n    // If one color was used more than other, we could consider the cell having N owner and N times the number of tokens\\n    // such cells would be a good target for others\\n    // On the other end, on winning agains other cells, owner of such cell would have to divide the winnings\\n    // TODO revisit this\\n    // we could also refund the part\\n    // so if there is 3 green 2 blue and 1 red, then green win and the cell become green\\n    // player who put blue or red get refunded their respective gems\\n    // the players who put green get refunded 2/3 so that the cell still contains only 1\\n    // if there was 3 green and 3 blue and 1 red then the cell becomes black\\n    // every player get refunded 6/7 so that the black cell only has 1\\n    // note that the issue with green winning above is that winnings need to be distributed to all 3 players who put green\\n    // and since the number is technically unbounded, we have to use a splitter contract where player withdraw their winnings\\n    // this add UX complexity and some cost for withdrawals\\n    // it also remove the ability to transfer the cell unless agreement and implementation for this\\n    // So the conclusion is to make it black in all cases and keep the amount\\n    function _computeMove(\\n        TokenTransferCollection memory transferCollection,\\n        address player,\\n        uint24 epoch,\\n        Move memory move\\n    ) internal returns (uint256 tokensPlaced, uint256 tokensBurnt, uint256 tokensReturned) {\\n        (Cell memory currentState, bool justDied) = _getUpdatedCell(move.position, epoch);\\n\\n        // logger.logPosition(\\\"move\\\", move.position);\\n        // logger.logCell(0, string.concat(\\\"_computeMove at epoch \\\", Strings.toString(epoch)), move.position, currentState, address(uint160(_owners[move.position])));\\n\\n        // we might have distribution still to do\\n        uint8 distribution = currentState.distribution;\\n        if (justDied) {\\n            // if we just died\\n            // we have to distribute to all\\n            distribution = (currentState.enemyMap << 4) + _countBits(currentState.enemyMap);\\n\\n            /// we are now dead for real\\n            currentState.lastEpochUpdate = 0;\\n        }\\n\\n        // we then apply our move:\\n\\n        // first we do some validity checks\\n        if (move.color == Color.None) {\\n            if (currentState.life != MAX_LIFE || _ownerOf(move.position) != player) {\\n                // invalid move\\n                // return (0, 0, NUM_TOKENS_PER_GEMS); // This is wrong ?\\n                return (0, 0, 0); // TODO return tokens\\n            }\\n\\n            _collectTransfer(transferCollection, TokenTransfer({to: payable(player), amount: NUM_TOKENS_PER_GEMS}));\\n        }\\n        // then we consider the case of collision and transform such move as Color Evil\\n        else if (currentState.epochWhenTokenIsAdded == epoch) {\\n            if (currentState.life != 0) {\\n                move.color = Color.Evil;\\n            } else {\\n                if (currentState.life != MAX_LIFE || _ownerOf(move.position) != player) {\\n                    // invalid move\\n                    // return (0, 0, NUM_TOKENS_PER_GEMS); // This is wrong ?\\n                    return (0, 0, 0); // TODO return tokens\\n                }\\n            }\\n            // we keep currentState.epochWhenTokenIsAdded as we do not want to be overwritten by conflcit: black\\n        }\\n        emit MoveProcessed(move.position, player, currentState.color, move.color);\\n\\n        return _completeMove(transferCollection, player, epoch, move, currentState, distribution);\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER \\\", Strings.toString(epoch)),move.position,currentState,address(uint160(_owners[move.position])));\\n    }\\n\\n    function _completeMove(\\n        TokenTransferCollection memory transferCollection,\\n        address player,\\n        uint24 epoch,\\n        Move memory move,\\n        Cell memory currentState,\\n        uint8 distribution\\n    ) internal returns (uint256 tokensPlaced, uint256 tokensBurnt, uint256 tokensReturned) {\\n        unchecked {\\n            // this is not so much newDelta than delta\\n            (int8 newDelta, uint8 newEnemyMap) = _propagate(\\n                transferCollection,\\n                move,\\n                epoch,\\n                currentState.color,\\n                distribution,\\n                currentState.stake\\n            );\\n\\n            currentState.color = move.color;\\n            currentState.distribution = 0;\\n            if (!(_ownerOf(move.position) == player && currentState.life > 0)) {\\n                // we do not reset \\\"epochWhenTokenIsAdded\\\" when same player\\n                // this prevent other player to place color while it replace color\\n                currentState.epochWhenTokenIsAdded = epoch; // used to prevent overwriting, even Color.None\\n            }\\n\\n            if (currentState.color == Color.None) {\\n                int8 oldEffectiveDelta = _effectiveDelta(currentState.delta, currentState.enemyMap);\\n                currentState.producingEpochs += epoch - currentState.lastEpochUpdate;\\n                currentState.life = 0;\\n                currentState.stake = 0;\\n                currentState.lastEpochUpdate = 0;\\n                currentState.delta = 0;\\n                currentState.enemyMap = 0;\\n                emit Transfer(_ownerOf(move.position), address(0), move.position);\\n                _owners[move.position] = 0;\\n                // tokensReturned = NUM_TOKENS_PER_GEMS; // TODO enable when we check reserve for this amount\\n                if (oldEffectiveDelta > 0) {\\n                    GENERATOR.remove(player, NUM_TOKENS_PER_GEMS);\\n                }\\n            } else {\\n                tokensPlaced = NUM_TOKENS_PER_GEMS;\\n\\n                _placeColor(player, currentState, move, epoch, newDelta, newEnemyMap);\\n            }\\n\\n            _cells[move.position] = currentState;\\n        }\\n    }\\n\\n    // this can work like in conquest as even though the world works in epoch\\n    //  we do not mind if a player could use another play moves to go further\\n    //  they would just need to ensure their reveal is in order\\n    //  In practise though player would not need this as the discovery gap should be big enough\\n    // But an alternative to tracking the 4 discovery point, would be to ask player to provide land position\\n    //  for the 4 direction. THey could also provide only one position for all 4 if that is enough\\n    // NOTE: would need to set initial discovery:\\n    // `_discovered = Discovered({\\n    //         minX: _initialSpaceExpansion,\\n    //         maxX: _initialSpaceExpansion,\\n    //         minY: _initialSpaceExpansion,\\n    //         maxY: _initialSpaceExpansion\\n    //     });\\n    //     emit Initialized(\\n    //         _initialSpaceExpansion,\\n    //     );`\\n    // // solhint-disable-next-line code-complexity\\n    // function _setDiscoveryAfterStaking(uint256 location) internal returns (bool invalid) {\\n    //     Discovered memory discovered = _discovered;\\n    //     uint32 _expansionDelta = 12;\\n\\n    //     (int32 x32, int32 y32) = PositionUtils.toXY(uint64(location));\\n    //     int256 x = (int40(x32));\\n    //     int256 y = (int40(y32));\\n\\n    //     int40 UINT32_MAX = 0xffffffff;\\n\\n    //     bool changes = false;\\n    //     if (x < 0) {\\n    //         if (-x > int256(uint256(discovered.minX))) {\\n    //             return false;\\n    //         }\\n    //         x = -x + int32(_expansionDelta);\\n    //         if (x > UINT32_MAX) {\\n    //             x = UINT32_MAX;\\n    //         }\\n    //         if (int256(uint256(discovered.minX)) < x) {\\n    //             discovered.minX = uint32(uint256(x));\\n    //             changes = true;\\n    //         }\\n    //     } else {\\n    //         if (x > int256(uint256(discovered.maxX))) {\\n    //             return false;\\n    //         }\\n    //         x = x + int32(_expansionDelta);\\n    //         if (x > UINT32_MAX) {\\n    //             x = UINT32_MAX;\\n    //         }\\n    //         if (discovered.maxX < uint32(uint256(x))) {\\n    //             discovered.maxX = uint32(uint256(x));\\n    //             changes = true;\\n    //         }\\n    //     }\\n\\n    //     if (y < 0) {\\n    //         if (-y > int256(uint256(discovered.minY))) {\\n    //             return false;\\n    //         }\\n    //         y = -y + int32(_expansionDelta);\\n    //         if (y > UINT32_MAX) {\\n    //             y = UINT32_MAX;\\n    //         }\\n    //         if (int256(uint256(discovered.minY)) < y) {\\n    //             discovered.minY = uint32(uint256(y));\\n    //             changes = true;\\n    //         }\\n    //     } else {\\n    //         if (y > int256(uint256(discovered.maxY))) {\\n    //             return false;\\n    //         }\\n    //         y = y + int32(_expansionDelta);\\n    //         if (y > UINT32_MAX) {\\n    //             y = UINT32_MAX;\\n    //         }\\n    //         if (int256(uint256(discovered.maxY)) < y) {\\n    //             discovered.maxY = uint32(uint256(y));\\n    //             changes = true;\\n    //         }\\n    //     }\\n    //     if (changes) {\\n    //         _discovered = discovered;\\n    //     }\\n    // }\\n\\n    function _propagate(\\n        TokenTransferCollection memory transferCollection,\\n        Move memory move,\\n        uint24 epoch,\\n        Color color,\\n        uint8 distribution,\\n        uint8 stake\\n    ) internal returns (int8 newDelta, uint8 newEnemyMap) {\\n        (\\n            int8 newComputedDelta,\\n            uint8 newComputedEnemyMap,\\n            uint16 numDue,\\n            address[4] memory ownersToPay\\n        ) = _updateNeighbours(move.position, epoch, color, move.color, distribution);\\n\\n        if (numDue > 0) {\\n            _collectTransfer(\\n                transferCollection,\\n                TokenTransfer({to: payable(_ownerOf(move.position)), amount: (numDue * NUM_TOKENS_PER_GEMS) / 12})\\n            );\\n        }\\n        for (uint8 i = 0; i < 4; i++) {\\n            if (ownersToPay[i] != address(0)) {\\n                _collectTransfer(\\n                    transferCollection,\\n                    TokenTransfer({\\n                        to: payable(ownersToPay[i]),\\n                        amount: stake * (NUM_TOKENS_PER_GEMS / (distribution & 0x0f))\\n                    })\\n                );\\n            }\\n        }\\n        newDelta = newComputedDelta;\\n        newEnemyMap = newComputedEnemyMap;\\n    }\\n\\n    function _poke(TokenTransferCollection memory transferCollection, uint64 position, uint24 epoch) internal {\\n        (Cell memory currentState, bool justDied) = _getUpdatedCell(position, epoch);\\n\\n        // logger.logCell(0,string.concat(\\\"_poke at epoch \\\", Strings.toString(epoch)),position,currentState,address(uint160(_owners[position])));\\n\\n        // we might have distribution still to do\\n        uint8 distribution = currentState.distribution;\\n        if (justDied) {\\n            // if we just died\\n            // we have to distribute to all\\n            distribution = (currentState.enemyMap << 4) + _countBits(currentState.enemyMap);\\n\\n            /// we are now dead for real\\n            currentState.lastEpochUpdate = 0;\\n        }\\n\\n        (, , uint16 numDue, address[4] memory ownersToPay) = _updateNeighbours(\\n            position,\\n            epoch,\\n            currentState.color,\\n            currentState.color,\\n            distribution\\n        );\\n\\n        if (numDue > 0) {\\n            _collectTransfer(\\n                transferCollection,\\n                TokenTransfer({to: payable(_ownerOf(position)), amount: (numDue * NUM_TOKENS_PER_GEMS) / 12})\\n            );\\n        }\\n        for (uint8 i = 0; i < 4; i++) {\\n            if (ownersToPay[i] != address(0)) {\\n                _collectTransfer(\\n                    transferCollection,\\n                    TokenTransfer({\\n                        to: payable(ownersToPay[i]),\\n                        amount: currentState.stake * (NUM_TOKENS_PER_GEMS / (distribution & 0x0f))\\n                    })\\n                );\\n            }\\n        }\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER poke (before zeroed distribution) at epoch \\\", Strings.toString(epoch)),position,currentState,address(uint160(_owners[position])));\\n\\n        currentState.distribution = 0;\\n        _cells[position] = currentState;\\n    }\\n\\n    struct CellUpdate {\\n        int8 delta;\\n        uint8 enemymap;\\n        uint16 due;\\n    }\\n    function _updateUP(\\n        address[4] memory ownersToPay,\\n        CellUpdate memory cellUpdate,\\n        uint64 position,\\n        uint24 epoch,\\n        uint8 distribution,\\n        Color oldColor,\\n        Color newColor\\n    ) internal {\\n        uint64 upPosition = position.offset(0, -1);\\n        (int8 enemyOrFriend, uint16 due) = _updateCell(\\n            CellUpdateData({\\n                position: upPosition,\\n                epoch: epoch,\\n                neighbourIndex: 2,\\n                oldColor: oldColor,\\n                newColor: newColor\\n            })\\n        );\\n        if (enemyOrFriend < 0) {\\n            cellUpdate.enemymap = cellUpdate.enemymap | 1;\\n        }\\n        cellUpdate.due += due;\\n        cellUpdate.delta += enemyOrFriend;\\n\\n        if ((distribution >> 4) & 1 == 1) {\\n            ownersToPay[0] = _ownerOf(upPosition);\\n        }\\n    }\\n    function _updateLEFT(\\n        address[4] memory ownersToPay,\\n        CellUpdate memory cellUpdate,\\n        uint64 position,\\n        uint24 epoch,\\n        uint8 distribution,\\n        Color oldColor,\\n        Color newColor\\n    ) internal {\\n        uint64 leftPosition = position.offset(-1, 0);\\n        (int8 enemyOrFriend, uint16 due) = _updateCell(\\n            CellUpdateData({\\n                position: leftPosition,\\n                epoch: epoch,\\n                neighbourIndex: 3,\\n                oldColor: oldColor,\\n                newColor: newColor\\n            })\\n        );\\n        if (enemyOrFriend < 0) {\\n            cellUpdate.enemymap = cellUpdate.enemymap | 2;\\n        }\\n        cellUpdate.due += due;\\n        cellUpdate.delta += enemyOrFriend;\\n\\n        if ((distribution >> 4) & 2 == 2) {\\n            ownersToPay[1] = _ownerOf(leftPosition);\\n        }\\n    }\\n\\n    function _updateDOWN(\\n        address[4] memory ownersToPay,\\n        CellUpdate memory cellUpdate,\\n        uint64 position,\\n        uint24 epoch,\\n        uint8 distribution,\\n        Color oldColor,\\n        Color newColor\\n    ) internal {\\n        uint64 downPosition = position.offset(0, 1);\\n        (int8 enemyOrFriend, uint16 due) = _updateCell(\\n            CellUpdateData({\\n                position: downPosition,\\n                epoch: epoch,\\n                neighbourIndex: 0,\\n                oldColor: oldColor,\\n                newColor: newColor\\n            })\\n        );\\n        if (enemyOrFriend < 0) {\\n            cellUpdate.enemymap = cellUpdate.enemymap | 4;\\n        }\\n        cellUpdate.due += due;\\n        cellUpdate.delta += enemyOrFriend;\\n\\n        if ((distribution >> 4) & 4 == 4) {\\n            ownersToPay[2] = _ownerOf(downPosition);\\n        }\\n    }\\n\\n    function _updateRIGHT(\\n        address[4] memory ownersToPay,\\n        CellUpdate memory cellUpdate,\\n        uint64 position,\\n        uint24 epoch,\\n        uint8 distribution,\\n        Color oldColor,\\n        Color newColor\\n    ) internal {\\n        uint64 rightPosition = position.offset(1, 0);\\n        (int8 enemyOrFriend, uint16 due) = _updateCell(\\n            CellUpdateData({\\n                position: rightPosition,\\n                epoch: epoch,\\n                neighbourIndex: 1,\\n                oldColor: oldColor,\\n                newColor: newColor\\n            })\\n        );\\n        if (enemyOrFriend < 0) {\\n            cellUpdate.enemymap = cellUpdate.enemymap | 8;\\n        }\\n        cellUpdate.due += due;\\n        cellUpdate.delta += enemyOrFriend;\\n\\n        if ((distribution >> 4) & 8 == 8) {\\n            ownersToPay[3] = _ownerOf(rightPosition);\\n        }\\n    }\\n\\n    function _updateNeighbours(\\n        uint64 position,\\n        uint24 epoch,\\n        Color oldColor,\\n        Color newColor,\\n        uint8 distribution\\n    ) internal returns (int8 newDelta, uint8 newEnemyMap, uint16 numDue, address[4] memory ownersToPay) {\\n        CellUpdate memory cellUpdate;\\n        _updateUP(ownersToPay, cellUpdate, position, epoch, distribution, oldColor, newColor);\\n        _updateLEFT(ownersToPay, cellUpdate, position, epoch, distribution, oldColor, newColor);\\n        _updateDOWN(ownersToPay, cellUpdate, position, epoch, distribution, oldColor, newColor);\\n        _updateRIGHT(ownersToPay, cellUpdate, position, epoch, distribution, oldColor, newColor);\\n        newDelta = cellUpdate.delta;\\n        newEnemyMap = cellUpdate.enemymap;\\n        numDue = cellUpdate.due;\\n    }\\n\\n    struct CellUpdateData {\\n        uint64 position; // position to update\\n        uint24 epoch;\\n        uint8 neighbourIndex; // index from point of view of cell being updated\\n        Color oldColor; // old Color of the neighbor\\n        Color newColor; // new color of the neighbor\\n    }\\n    /// @dev This update the cell in storage\\n    function _updateCell(CellUpdateData memory data) internal returns (int8 enemyOrFriend, uint16 due) {\\n        Cell memory cell = _cells[data.position];\\n\\n        uint24 lastUpdate = cell.lastEpochUpdate;\\n        Color color = cell.color;\\n        if (color != Color.None) {\\n            // if the color of the cell being update is not Nome\\n            // we then check the neighbor new color\\n            // if it same as the cell color, then we report the cell as friendly to the neighbor\\n            // else it is an enemy\\n            // note that _updateCell should only be called if oldColor != newColor\\n            enemyOrFriend = color == data.newColor ? int8(1) : int8(-1);\\n        }\\n        if (lastUpdate >= 1 && color != Color.None) {\\n            // we only consider cell with color that are not dead\\n            if (cell.life > 0 && lastUpdate < data.epoch) {\\n                // of there is life to update we compute the new life\\n                (uint8 newLife, ) = _computeNewLife(lastUpdate, cell.enemyMap, cell.delta, cell.life, data.epoch);\\n                due = _updateCellFromNeighbor(data, cell, newLife);\\n            } else {\\n                due = _updateCellFromNeighbor(data, cell, cell.life);\\n            }\\n        }\\n    }\\n\\n    function _updateCellFromNeighbor(\\n        CellUpdateData memory data,\\n        Cell memory cell, // cell to be updated\\n        uint8 newLife // new life value for the cell\\n    ) internal returns (uint16 due) {\\n        if (cell.life > 0 && newLife == 0) {\\n            // we just died, we establish the distributionMap and counts\\n            // logger.logPosition(\\\"new distribution\\\", position);\\n            cell.distribution = (cell.enemyMap << 4) + _countBits(cell.enemyMap);\\n            // console.log(\\\"%i %i\\\", cell.distribution >> 4, cell.distribution & 0x0F);\\n        }\\n\\n        // logger.logCell(0,string.concat(\\\"_updateCellFromNeighbor  index\\\", Strings.toString(neighbourIndex)),position,cell,address(uint160(_owners[position])));\\n\\n        if ((cell.distribution >> 4) & (2 ** data.neighbourIndex) == 2 ** data.neighbourIndex) {\\n            due = (cell.stake * 12) / (cell.distribution & 0x0f); // TODO if stake too high we have a problem\\n\\n            cell.distribution =\\n                (uint8(uint256(cell.distribution >> 4) & (~(2 ** uint256(data.neighbourIndex)))) << 4) +\\n                (cell.distribution & 0x0f);\\n        }\\n\\n        int8 oldEffectiveDelta = _effectiveDelta(cell.delta, cell.enemyMap);\\n\\n        _handleColor(cell, data.neighbourIndex, data.oldColor, data.newColor);\\n\\n        _setCell(data.position, cell, newLife, data.epoch, oldEffectiveDelta);\\n\\n        // logger.logCell(0,string.concat(\\\"AFTER _updateCellFromNeighbor  index\\\", Strings.toString(neighbourIndex)),position,cell,address(uint160(_owners[position])));\\n\\n        _cells[data.position] = cell;\\n    }\\n\\n    function _setCell(\\n        uint64 position, // position of the cell to be updated\\n        Cell memory cell, // cell to be updated\\n        uint8 newLife, // new life value for the celll\\n        uint24 epoch, // epoch at which the update occured (epochUsed TODO: confirm its use)\\n        int8 oldEffectiveDelta\\n    ) internal {\\n        address owner = _ownerOf(position);\\n        if (owner != address(0) && newLife > 0) {\\n            int8 newEffectiveDelta = _effectiveDelta(cell.delta, cell.enemyMap);\\n            if (oldEffectiveDelta > 0 && newEffectiveDelta <= 0) {\\n                GENERATOR.remove(owner, NUM_TOKENS_PER_GEMS * cell.stake);\\n            } else if (oldEffectiveDelta <= 0 && newEffectiveDelta > 0) {\\n                GENERATOR.add(owner, NUM_TOKENS_PER_GEMS * cell.stake);\\n            }\\n        }\\n\\n        if (oldEffectiveDelta > 0) {\\n            cell.producingEpochs += epoch - cell.lastEpochUpdate;\\n        }\\n\\n        cell.lastEpochUpdate = epoch;\\n        cell.life = newLife;\\n    }\\n\\n    function _handleColor(\\n        Cell memory cell, // cell to be updated\\n        uint8 neighbourIndex, // the neighbor triggering the update and for which we return whether it should receive its due\\n        Color oldColor, // old color of that neighbor\\n        Color newColor // new color of that neighbor\\n    ) internal pure {\\n        if (oldColor != newColor) {\\n            if (newColor == Color.None) {\\n                if (cell.color == oldColor) {\\n                    cell.delta -= 1;\\n                } else {\\n                    cell.delta += 1;\\n                    cell.enemyMap = cell.enemyMap & uint8((1 << neighbourIndex) ^ 0xFF);\\n                }\\n            } else if (cell.color == oldColor) {\\n                // then newColor is different (see assert above)\\n                cell.enemyMap = cell.enemyMap | uint8(1 << neighbourIndex);\\n                cell.delta -= 2;\\n            } else if (cell.color == newColor) {\\n                // then old color was different\\n                cell.delta += (oldColor == Color.None ? int8(1) : int8(2));\\n                cell.enemyMap = cell.enemyMap & uint8((1 << neighbourIndex) ^ 0xFF);\\n            } else if (oldColor == Color.None) {\\n                // if there were no oldCOlor and the newColor is not your (already checked in previous if clause)\\n                cell.delta -= 1;\\n                cell.enemyMap = cell.enemyMap | uint8(1 << neighbourIndex);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8527ccbf59b0dcaf31dcc515fc0973de2433a748b798eca30459d28e00fa82e0\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsState.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingStratagemsStore.sol\\\";\\nimport \\\"../interface/UsingStratagemsEvents.sol\\\";\\nimport \\\"../interface/UsingStratagemsErrors.sol\\\";\\nimport \\\"./UsingVirtualTime.sol\\\";\\nimport \\\"../../utils/PositionUtils.sol\\\";\\n\\n// TODO use hardhat-preprocessor\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../../utils/StringUtils.sol\\\";\\n\\nlibrary logger {\\n    using PositionUtils for uint64;\\n\\n    address constant CONSOLE_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(staticcall(gas(), consoleAddress, add(payload, 32), mload(payload), 0, 0))\\n        }\\n    }\\n\\n    // _sendLogPayload(abi.encodeWithSignature('log(string,int256,int256)', 'cell %s', x, y));\\n\\n    function logPosition(string memory title, uint64 pos) internal view {\\n        (int32 x, int32 y) = pos.toXY();\\n        console.log(\\\"%s: (%s,%s)\\\", title, StringUtils.toString(x), StringUtils.toString(y));\\n    }\\n\\n    function logCell(\\n        uint8 ii,\\n        string memory title,\\n        uint64 id,\\n        UsingStratagemsTypes.Cell memory cell,\\n        address owner\\n    ) internal view {\\n        string memory indent = ii == 0\\n            ? \\\"\\\"\\n            : ii == 1\\n                ? \\\"    \\\"\\n                : ii == 2\\n                    ? \\\"        \\\"\\n                    : \\\"            \\\";\\n        // string memory indent = '';\\n        console.log(\\\"%s%s\\\", indent, title);\\n        (int32 x, int32 y) = id.toXY();\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        console.log(\\\"%scell (%s,%s)\\\", indent, StringUtils.toString(x), StringUtils.toString(y));\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        console.log(\\\"%s - lastEpochUpdate:  %s\\\", indent, cell.lastEpochUpdate);\\n        console.log(\\\"%s - epochWhenTokenIsAdded:  %s\\\", indent, cell.epochWhenTokenIsAdded);\\n        console.log(\\\"%s - color:  %s\\\", indent, uint8(cell.color));\\n        console.log(\\\"%s - life:  %s\\\", indent, cell.life);\\n        console.log(\\\"%s - distribution:  %s\\\", indent, cell.distribution);\\n        console.log(\\\"%s - owner:  %s\\\", indent, owner);\\n        console.log(\\\"%s - delta: %s\\\", indent, StringUtils.toString(cell.delta));\\n        console.log(\\\"%s - enemyMap:  %s\\\", indent, cell.enemyMap);\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n    }\\n\\n    function logTransfers(\\n        uint8 ii,\\n        string memory title,\\n        UsingStratagemsTypes.TokenTransferCollection memory transferCollection\\n    ) internal pure {\\n        string memory indent = ii == 0\\n            ? \\\"\\\"\\n            : ii == 1\\n                ? \\\"    \\\"\\n                : ii == 2\\n                    ? \\\"        \\\"\\n                    : \\\"            \\\";\\n        // string memory indent = '';\\n        console.log(\\\"%s%s\\\", indent, title);\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n        for (uint256 i = 0; i < transferCollection.numTransfers; i++) {\\n            console.log(\\n                \\\"%stransfer (%s,%s)\\\",\\n                indent,\\n                transferCollection.transfers[i].to,\\n                StringUtils.toString(transferCollection.transfers[i].amount)\\n            );\\n        }\\n        console.log(\\\"%s-------------------------------------------------------------\\\", indent);\\n    }\\n}\\n\\nabstract contract UsingStratagemsState is\\n    UsingStratagemsStore,\\n    UsingStratagemsEvents,\\n    UsingStratagemsErrors,\\n    UsingVirtualTime\\n{\\n    /// @notice The token used for the game. Each gems on the board contains that token\\n    IERC20WithIERC2612 internal immutable TOKENS;\\n    /// @notice the timestamp (in seconds) at which the game start, it start in the commit phase\\n    uint256 internal immutable START_TIME;\\n    /// @notice the duration of the commit phase in seconds\\n    uint256 internal immutable COMMIT_PHASE_DURATION;\\n    /// @notice the duration of the reveal phase in seconds\\n    uint256 internal immutable REVEAL_PHASE_DURATION;\\n    /// @notice the max number of level a cell can reach in the game\\n    uint8 internal immutable MAX_LIFE;\\n    /// @notice the number of tokens underlying each gems on the board.\\n    uint256 internal immutable NUM_TOKENS_PER_GEMS;\\n    /// @notice the address to send the token to when burning\\n    address payable internal immutable BURN_ADDRESS;\\n    /// @notice the generator that will be called whenever a player stake state change\\n    IOnStakeChange internal immutable GENERATOR;\\n\\n    /// @notice the number of moves a hash represent, after that players make use of furtherMoves\\n    uint8 internal constant MAX_NUM_MOVES_PER_HASH = 32;\\n\\n    /// @notice Create an instance of a Stratagems game\\n    /// @param config configuration options for the game\\n    constructor(Config memory config) UsingVirtualTime(config) {\\n        TOKENS = config.tokens;\\n        BURN_ADDRESS = config.burnAddress;\\n        START_TIME = config.startTime;\\n        COMMIT_PHASE_DURATION = config.commitPhaseDuration;\\n        REVEAL_PHASE_DURATION = config.revealPhaseDuration;\\n        MAX_LIFE = config.maxLife;\\n        NUM_TOKENS_PER_GEMS = config.numTokensPerGems;\\n        GENERATOR = config.generator;\\n    }\\n\\n    function _epoch() internal view virtual returns (uint24 epoch, bool commiting) {\\n        uint256 epochDuration = COMMIT_PHASE_DURATION + REVEAL_PHASE_DURATION;\\n        uint256 time = _timestamp();\\n        if (time < START_TIME) {\\n            revert GameNotStarted();\\n        }\\n        uint256 timePassed = time - START_TIME;\\n        epoch = uint24(timePassed / epochDuration + 2); // epoch start at 2, this make the hypothetical previous reveal phase's epoch to be 1\\n        commiting = timePassed - ((epoch - 2) * epochDuration) < COMMIT_PHASE_DURATION;\\n    }\\n\\n    function _computeNewLife(\\n        uint24 lastUpdate,\\n        uint8 enemyMap,\\n        int8 delta,\\n        uint8 life,\\n        uint24 epoch\\n    ) internal view returns (uint8 newLife, uint24 epochUsed) {\\n        epochUsed = lastUpdate;\\n        if (lastUpdate >= 1 && life > 0) {\\n            uint256 epochDelta = epoch - lastUpdate;\\n            if (epochDelta > 0) {\\n                int8 effectiveDelta = _effectiveDelta(delta, enemyMap);\\n                if (effectiveDelta > 0) {\\n                    // if (life < MAX_LIFE) {\\n                    uint8 maxEpoch = ((MAX_LIFE - life) + uint8(effectiveDelta) - 1) / uint8(effectiveDelta);\\n                    if (epochDelta > maxEpoch) {\\n                        epochDelta = maxEpoch;\\n                    }\\n\\n                    life += uint8(epochDelta) * uint8(effectiveDelta);\\n                    if (life > MAX_LIFE) {\\n                        life = MAX_LIFE;\\n                    }\\n                    newLife = life;\\n\\n                    // we don not use the following: lastUpdate + epochDelta;\\n                    //   because no state change is foreseen with no life increase\\n                    epochUsed = epoch;\\n                    // } else {\\n                    // \\tnewLife = life;\\n                    // \\tepochUsed = lastUpdate;\\n                    // }\\n                } else if (effectiveDelta < 0) {\\n                    uint8 numEpochBeforeDying = (life + uint8(-effectiveDelta) - 1) / uint8(-effectiveDelta);\\n                    if (epochDelta > numEpochBeforeDying) {\\n                        epochDelta = numEpochBeforeDying;\\n                    }\\n                    uint8 lifeLoss = uint8(epochDelta) * uint8(-effectiveDelta);\\n                    if (lifeLoss > life) {\\n                        newLife = 0;\\n                    } else {\\n                        newLife = life - lifeLoss;\\n                    }\\n\\n                    // since we need to track when the cell died, we upate lastUpdate only to\\n                    //   the corresponding epoch where life reached 0\\n                    epochUsed = lastUpdate + uint24(epochDelta);\\n                } else {\\n                    newLife = life;\\n\\n                    // we don not use the following: lastUpdate + epochDelta;\\n                    //   because no state change is foreseen with no life change\\n                    epochUsed = epoch;\\n                }\\n            } else {\\n                newLife = life;\\n\\n                // no change, no need to update lastUpdate either ?\\n                epochUsed = lastUpdate;\\n            }\\n        }\\n    }\\n\\n    function _effectiveDelta(int8 delta, uint8 enemyMap) internal pure returns (int8 effectiveDelta) {\\n        // effectiveDelta = delta != 0 ? delta : -1;\\n        effectiveDelta = delta > 0 ? int8(1) : -1;\\n        if (effectiveDelta < 0 && enemyMap == 0) {\\n            effectiveDelta = int8(1);\\n            // effectiveDelta = int8(0);\\n        }\\n    }\\n\\n    function _getUpdatedCell(\\n        uint64 position,\\n        uint24 epoch\\n    ) internal view returns (Cell memory updatedCell, bool justDied) {\\n        // load from state\\n        updatedCell = _cells[position];\\n        uint24 lastUpdate = updatedCell.lastEpochUpdate;\\n        int8 delta = updatedCell.delta;\\n        uint8 life = updatedCell.life;\\n        // logger.logCell(0, 'before update', position, updatedCell, address(uint160(_owners[position])));\\n        if (lastUpdate >= 1 && life > 0) {\\n            (uint8 newLife, ) = _computeNewLife(lastUpdate, updatedCell.enemyMap, delta, life, epoch);\\n            updatedCell.life = newLife;\\n            updatedCell.lastEpochUpdate = epoch; // TODO check if this is useful to cap it to epoch where it died\\n            justDied = newLife == 0;\\n        }\\n        int8 effectiveDelta = _effectiveDelta(updatedCell.delta, updatedCell.enemyMap);\\n        if (effectiveDelta > 0) {\\n            updatedCell.producingEpochs += epoch - lastUpdate;\\n        }\\n    }\\n\\n    /// @dev Get the owner of a token.\\n    /// @param tokenID The token to query.\\n    function _ownerOf(uint256 tokenID) internal view virtual returns (address owner) {\\n        owner = address(uint160(_owners[tokenID]));\\n    }\\n}\\n\",\"keccak256\":\"0x79f384f1a05b132fa376a318fd299a2681ef49fea4066b2efd86240884bceb6c\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsStore.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\n\\ncontract UsingStratagemsStore is UsingStratagemsTypes {\\n    mapping(uint256 => Cell) internal _cells;\\n    mapping(uint256 => uint256) internal _owners; //owner + approval + ... erc721\\n\\n    Discovered _discovered;\\n\\n    mapping(address => uint256) internal _tokensInReserve;\\n    mapping(address => Commitment) internal _commitments;\\n\\n    // Operators (also used by ERC721)\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    // ERC721 balanceOf\\n    // mapping(address => uint256) internal _balances;\\n}\\n\",\"keccak256\":\"0x1530946719faf48cdbe553a506e9604a9e9633820d884e0e37d278115ba53ed1\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingStratagemsUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\nimport \\\"../interface/UsingStratagemsErrors.sol\\\";\\n\\nabstract contract UsingStratagemsUtils is UsingStratagemsTypes, UsingStratagemsErrors {\\n    function _checkHash(\\n        bytes24 commitmentHash,\\n        bytes32 secret,\\n        Move[] memory moves,\\n        bytes24 furtherMoves\\n    ) internal pure {\\n        if (furtherMoves != bytes24(0)) {\\n            bytes24 computedHash = bytes24(keccak256(abi.encode(secret, moves, furtherMoves)));\\n            if (commitmentHash != computedHash) {\\n                revert CommitmentHashNotMatching();\\n            }\\n        } else {\\n            bytes24 computedHash = bytes24(keccak256(abi.encode(secret, moves)));\\n            if (commitmentHash != computedHash) {\\n                revert CommitmentHashNotMatching();\\n            }\\n        }\\n    }\\n\\n    function _collectTransfer(\\n        TokenTransferCollection memory transferCollection,\\n        TokenTransfer memory newTransfer\\n    ) internal pure {\\n        // we look for the newTransfer address in case it is already present\\n        for (uint256 k = 0; k < transferCollection.numTransfers; k++) {\\n            if (transferCollection.transfers[k].to == newTransfer.to) {\\n                // if we found we add the amount\\n                transferCollection.transfers[k].amount += newTransfer.amount;\\n                return;\\n            }\\n        }\\n        // if we did not find that address we add it to the end\\n        transferCollection.transfers[transferCollection.numTransfers].to = newTransfer.to;\\n        transferCollection.transfers[transferCollection.numTransfers].amount = newTransfer.amount;\\n        // and increase the size to lookup for next time\\n        transferCollection.numTransfers++;\\n    }\\n\\n    function _multiTransfer(IERC20WithIERC2612 token, TokenTransferCollection memory transferCollection) internal {\\n        for (uint256 i = 0; i < transferCollection.numTransfers; i++) {\\n            token.transfer(transferCollection.transfers[i].to, transferCollection.transfers[i].amount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62eaa33b438ebcfce77a86f2da6c6fa83853b7bf949ae5524490766d282deccb\",\"license\":\"AGPL-3.0\"},\"src/game/internal/UsingVirtualTime.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/UsingStratagemsTypes.sol\\\";\\n\\nabstract contract UsingVirtualTime {\\n    // TODO use hardhat-preprocessor\\n\\n    ITime immutable _time;\\n\\n    constructor(UsingStratagemsTypes.Config memory config) {\\n        _time = config.time;\\n    }\\n\\n    function _timestamp() internal view returns (uint256) {\\n        if (address(_time) == address(0)) {\\n            return block.timestamp;\\n        }\\n        return _time.timestamp();\\n    }\\n}\\n\",\"keccak256\":\"0xc879b36cc8d50d6e3e9f086845bbd62dcaddeb99b1242400314b8c6b69a211b3\",\"license\":\"AGPL-3.0\"},\"src/game/routes/StratagemsReveal.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/IStratagems.sol\\\";\\nimport \\\"../internal/UsingStratagemsSetters.sol\\\";\\nimport \\\"../internal/UsingStratagemsUtils.sol\\\";\\n\\ncontract StratagemsReveal is IStratagemsReveal, UsingStratagemsSetters {\\n    constructor(Config memory config) UsingStratagemsSetters(config) {}\\n\\n    /// @inheritdoc IStratagemsReveal\\n    function reveal(\\n        address player,\\n        bytes32 secret,\\n        Move[] calldata moves,\\n        bytes24 furtherMoves,\\n        bool useReserve,\\n        address payable payee\\n    ) external payable {\\n        Commitment storage commitment = _commitments[player];\\n        (uint24 epoch, bool commiting) = _epoch();\\n\\n        if (commiting) {\\n            revert InCommitmentPhase();\\n        }\\n        if (commitment.epoch == 0) {\\n            revert NothingToReveal();\\n        }\\n        if (commitment.epoch != epoch) {\\n            revert InvalidEpoch();\\n        }\\n\\n        _checkHash(commitment.hash, secret, moves, furtherMoves);\\n\\n        uint256 newReserveAmount = _resolveMoves(player, epoch, moves, useReserve ? address(0) : player);\\n\\n        bytes24 hashRevealed = commitment.hash;\\n        if (furtherMoves != bytes24(0)) {\\n            if (moves.length != MAX_NUM_MOVES_PER_HASH) {\\n                revert InvalidFurtherMoves();\\n            }\\n            commitment.hash = furtherMoves;\\n        } else {\\n            commitment.epoch = 0; // used\\n        }\\n\\n        emit CommitmentRevealed(player, epoch, hashRevealed, moves, furtherMoves, newReserveAmount);\\n\\n        if (payee != address(0)) {\\n            payee.transfer(msg.value);\\n        }\\n    }\\n\\n    /// @inheritdoc IStratagemsReveal\\n    function acknowledgeMissedReveal(\\n        address player,\\n        bytes32 secret,\\n        Move[] calldata moves,\\n        bytes24 furtherMoves\\n    ) external {\\n        Commitment storage commitment = _commitments[player];\\n        (uint24 epoch, ) = _epoch();\\n        if (commitment.epoch == 0 || commitment.epoch == epoch) {\\n            revert CanStillReveal();\\n        }\\n\\n        uint256 numMoves = moves.length;\\n\\n        _checkHash(commitment.hash, secret, moves, furtherMoves);\\n\\n        if (furtherMoves != bytes24(0)) {\\n            if (numMoves != MAX_NUM_MOVES_PER_HASH) {\\n                revert InvalidFurtherMoves();\\n            }\\n            commitment.hash = furtherMoves;\\n        } else {\\n            commitment.epoch = 0; // used\\n        }\\n\\n        uint256 amount = moves.length * NUM_TOKENS_PER_GEMS;\\n        _tokensInReserve[msg.sender] -= amount;\\n        TOKENS.transfer(BURN_ADDRESS, amount);\\n        emit CommitmentVoid(player, epoch, amount, furtherMoves);\\n    }\\n\\n    /// @inheritdoc IStratagemsReveal\\n    function acknowledgeMissedRevealByBurningAllReserve() external {\\n        Commitment storage commitment = _commitments[msg.sender];\\n        (uint24 epoch, ) = _epoch();\\n\\n        if (commitment.epoch == 0) {\\n            revert NothingToReveal();\\n        }\\n\\n        if (commitment.epoch == epoch) {\\n            revert CanStillReveal();\\n        }\\n\\n        commitment.epoch = 0;\\n        uint256 amount = _tokensInReserve[msg.sender];\\n        _tokensInReserve[msg.sender] = 0;\\n        TOKENS.transfer(BURN_ADDRESS, amount);\\n\\n        // here we cannot know whether there were further move or even any moves\\n        // we just burn all tokens in reserve\\n        emit CommitmentVoid(msg.sender, epoch, amount, bytes24(0));\\n    }\\n}\\n\",\"keccak256\":\"0x51f20bc49aab612cbba0e8d0d577ef03fb4e4f20356ba05144f52562ff0422a8\",\"license\":\"AGPL-3.0\"},\"src/token/interface/IOnStakeChange.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IOnStakeChange {\\n    function add(address account, uint256 amount) external;\\n\\n    function remove(address account, uint256 amount) external;\\n\\n    function move(address from, address to, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0xb73017e0afe41fc34d5ce6382ae3f67bc08eaffeedcf7064ca4205e54035dc38\",\"license\":\"AGPL-3.0\"},\"src/utils/PositionUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary PositionUtils {\\n    function toXY(uint64 position) internal pure returns (int32 x, int32 y) {\\n        x = int32(uint32(position) & 0xFFFFFFFF);\\n        y = int32(uint32(position >> 32));\\n    }\\n\\n    function offset(uint64 position, int32 x, int32 y) internal pure returns (uint64 newPosition) {\\n        x = int32(uint32(position) & 0xFFFFFFFF) + x;\\n        y = int32(uint32(position >> 32)) + y;\\n        newPosition = (uint64(uint32(y)) << 32) + uint64(uint32(x));\\n    }\\n}\\n\",\"keccak256\":\"0x82dcff44b73db30e108027baaa503a39f30c3e1accbf0133c52f4615e8f5d70c\",\"license\":\"AGPL-3.0\"},\"src/utils/StringUtils.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nlibrary StringUtils {\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        return Strings.toString(value);\\n    }\\n\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", Strings.toString(SignedMath.abs(value))));\\n    }\\n}\\n\",\"keccak256\":\"0x012166e145b476899e290961b2ddd6415b57604e8b6bde82c982e00b50a5105a\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 14579,
        "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
        "label": "_cells",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Cell)11534_storage)"
      },
      {
        "astId": 14583,
        "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
        "label": "_owners",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 14586,
        "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
        "label": "_discovered",
        "offset": 0,
        "slot": "2",
        "type": "t_struct(Discovered)11514_storage"
      },
      {
        "astId": 14590,
        "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
        "label": "_tokensInReserve",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 14595,
        "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
        "label": "_commitments",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_struct(Commitment)11539_storage)"
      },
      {
        "astId": 14601,
        "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
        "label": "_operatorsForAll",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 14605,
        "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
        "label": "_operators",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes24": {
        "encoding": "inplace",
        "label": "bytes24",
        "numberOfBytes": "24"
      },
      "t_enum(Color)11440": {
        "encoding": "inplace",
        "label": "enum UsingStratagemsTypes.Color",
        "numberOfBytes": "1"
      },
      "t_int8": {
        "encoding": "inplace",
        "label": "int8",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_struct(Commitment)11539_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct UsingStratagemsTypes.Commitment)",
        "numberOfBytes": "32",
        "value": "t_struct(Commitment)11539_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Cell)11534_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct UsingStratagemsTypes.Cell)",
        "numberOfBytes": "32",
        "value": "t_struct(Cell)11534_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Cell)11534_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Cell",
        "members": [
          {
            "astId": 11516,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "lastEpochUpdate",
            "offset": 0,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 11518,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "epochWhenTokenIsAdded",
            "offset": 3,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 11520,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "producingEpochs",
            "offset": 6,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 11523,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "color",
            "offset": 9,
            "slot": "0",
            "type": "t_enum(Color)11440"
          },
          {
            "astId": 11525,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "life",
            "offset": 10,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11527,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "delta",
            "offset": 11,
            "slot": "0",
            "type": "t_int8"
          },
          {
            "astId": 11529,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "enemyMap",
            "offset": 12,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11531,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "distribution",
            "offset": 13,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 11533,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "stake",
            "offset": 14,
            "slot": "0",
            "type": "t_uint8"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Commitment)11539_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Commitment",
        "members": [
          {
            "astId": 11536,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "hash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes24"
          },
          {
            "astId": 11538,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "epoch",
            "offset": 24,
            "slot": "0",
            "type": "t_uint24"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Discovered)11514_storage": {
        "encoding": "inplace",
        "label": "struct UsingStratagemsTypes.Discovered",
        "members": [
          {
            "astId": 11507,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "minX",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 11509,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "maxX",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 11511,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "minY",
            "offset": 8,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 11513,
            "contract": "src/game/routes/StratagemsReveal.sol:StratagemsReveal",
            "label": "maxY",
            "offset": 12,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  },
  "userdoc": {
    "errors": {
      "CanStillReveal()": [
        {
          "notice": "Player have to reveal if they can Stratagems will prevent them from acknowledging missed reveal if there is still time to reveal."
        }
      ],
      "CommitmentHashNotMatching()": [
        {
          "notice": "Player have to reveal their commitment using the exact same move values  If they provide different value, the commitment hash will differ and Stratagems will reject their reveal."
        }
      ],
      "GameNotStarted()": [
        {
          "notice": "Game has not started yet, can't perform any action"
        }
      ],
      "ImpossibleConfiguration()": [
        {
          "notice": "The cell configuration is invalid This can happen win debug mode where admin can setup cell bypassing moves rules For example when setting up neighborood configuration that would require a cell to have negative life"
        }
      ],
      "InCommitmentPhase()": [
        {
          "notice": "When in Commit phase, player can make new commitment but they cannot reveal their move yet."
        }
      ],
      "InRevealPhase()": [
        {
          "notice": "When in Reveal phase, it is not possible to commit new moves or cancel previous commitment  During Reveal phase, players have to reveal their commitment, if not already done."
        }
      ],
      "InvalidEpoch()": [
        {
          "notice": "Player can only reveal their move in the same epoch they commited.abi  If a player reveal later it can only do to minimize the reserve burn cost by calling : `acknowledgeMissedReveal`"
        }
      ],
      "InvalidFurtherMoves()": [
        {
          "notice": "Player can make arbitrary number of moves per epoch. To do so they group moves into (MAX_NUM_MOVES_PER_HASH = 32) moves  This result in a recursive series of hash that they can then submit in turn while revealing.  The limit  (MAX_NUM_MOVES_PER_HASH = 32) ensure a reveal batch fits in a block."
        }
      ],
      "NothingToReveal()": [
        {
          "notice": "Player can only reveal moves they commited."
        }
      ],
      "PreviousCommitmentNotRevealed()": [
        {
          "notice": "Previous commitment need to be revealed before making a new one. Even if the corresponding reveal phase has passed.\\  It is also not possible to withdraw any amount from reserve until the commitment is revealed.\\If player lost the information to reveal, it can acknowledge failure which will burn all its reserve.\\"
        }
      ],
      "ReserveTooLow(uint256,uint256)": [
        {
          "notice": "to make a commitment you always need at least one `config.numTokensPerGems` amount in reserve  Player also need one `config.numTokensPerGems`  per moves during the Reveal phase."
        }
      ]
    },
    "events": {
      "Approval(address,address,uint256)": {
        "notice": "Triggered when a token is approved to be sent by another account  Note tat the approval get reset when a Transfer event for that same token is emitted."
      },
      "ApprovalForAll(address,address,bool)": {
        "notice": "Triggered when an account approve or disaprove another to transfer on its behalf"
      },
      "CommitmentCancelled(address,uint24)": {
        "notice": "A player has cancelled its current commitment (before it reached the reveal phase)"
      },
      "CommitmentMade(address,uint24,bytes24)": {
        "notice": "A player has commited to make a move and reveal it on the reveal phase"
      },
      "CommitmentRevealed(address,uint24,bytes24,(uint64,uint8)[],bytes24,uint256)": {
        "notice": "Player has revealed its previous commitment"
      },
      "CommitmentVoid(address,uint24,uint256,bytes24)": {
        "notice": "A player has canceled a previous commitment by burning some tokens"
      },
      "MoveProcessed(uint64,address,uint8,uint8)": {
        "notice": "A move has been revealed."
      },
      "MultiPoke(uint24,uint64[])": {
        "notice": "poke multiple cells and update them if needed"
      },
      "ReserveDeposited(address,uint256,uint256)": {
        "notice": "Player has deposited token in the reserve, allowing it to use that much in game"
      },
      "ReserveWithdrawn(address,uint256,uint256)": {
        "notice": "Player have withdrawn token from the reserve"
      },
      "SinglePoke(uint24,uint64)": {
        "notice": "poke cell and update it if needed"
      },
      "Transfer(address,address,uint256)": {
        "notice": "Triggered when a token is transferred"
      }
    },
    "kind": "user",
    "methods": {
      "acknowledgeMissedReveal(address,bytes32,(uint64,uint8)[],bytes24)": {
        "notice": "called by player if they missed the reveal phase and want to minimze the token loss.  By providing the moves, they will be slashed only the amount of token required to make the moves"
      },
      "acknowledgeMissedRevealByBurningAllReserve()": {
        "notice": "should only be called as last resort this will burn all tokens in reserve If player has access to the secret, better call `acknowledgeMissedReveal`"
      },
      "reveal(address,bytes32,(uint64,uint8)[],bytes24,bool,address)": {
        "notice": "called by player to reveal their moves  this is where the core logic of the game takes place  This is where the game board evolves  The game is designed so that reveal order does not matter"
      }
    },
    "version": 1
  },
  "argsData": "0x000000000000000000000000f1afa696204e3f1c07838280bd2db799c660da1c000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000143700000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b0855eaf94bf7f122af4f444141e83b7408cc7a7",
  "transaction": {
    "hash": "0x1cc51a78e5790a38049343ec525819bf63c9090c120b11a5afd1e14d9b807d1f",
    "origin": "0xbe19b59e8c588d68f475a407c7ba5fe813aeb792"
  },
  "receipt": {
    "confirmations": 0,
    "blockHash": "0x48987e935f6a7e392f9f602a562e56efa48704cb8f17cf4c7132e8dfb59cd751",
    "blockNumber": "0xcdfb77",
    "transactionIndex": "0x1f"
  }
}